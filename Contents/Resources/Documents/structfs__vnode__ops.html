<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: fs_vnode_ops Struct Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="structfs__vnode__ops-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fs_vnode_ops Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Operations vector for a node.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">VNode Operations</div></td></tr>
<tr class="memitem:a8f42b700e62d2750df7607234a9d0f87" id="r_a8f42b700e62d2750df7607234a9d0f87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f42b700e62d2750df7607234a9d0f87">lookup</a> )(fs_volume *volume, fs_vnode *dir, const char *name, ino_t *_id)</td></tr>
<tr class="memdesc:a8f42b700e62d2750df7607234a9d0f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up the node a directory entry refers to.  <br /></td></tr>
<tr class="separator:a8f42b700e62d2750df7607234a9d0f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e45189c413dd69b09bc5f419b5d61f" id="r_a91e45189c413dd69b09bc5f419b5d61f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e45189c413dd69b09bc5f419b5d61f">get_vnode_name</a> )(fs_volume *volume, fs_vnode *vnode, char *buffer, size_t bufferSize)</td></tr>
<tr class="memdesc:a91e45189c413dd69b09bc5f419b5d61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the file name of a directory vnode.  <br /></td></tr>
<tr class="separator:a91e45189c413dd69b09bc5f419b5d61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad230d461e05b460a42fb89aeab816d39" id="r_ad230d461e05b460a42fb89aeab816d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad230d461e05b460a42fb89aeab816d39">put_vnode</a> )(fs_volume *volume, fs_vnode *vnode, bool reenter)</td></tr>
<tr class="memdesc:ad230d461e05b460a42fb89aeab816d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the private data handle associated with the specified node.  <br /></td></tr>
<tr class="separator:ad230d461e05b460a42fb89aeab816d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b85433ea7269cfdfe13a6d2fcd17733" id="r_a8b85433ea7269cfdfe13a6d2fcd17733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b85433ea7269cfdfe13a6d2fcd17733">remove_vnode</a> )(fs_volume *volume, fs_vnode *vnode, bool reenter)</td></tr>
<tr class="memdesc:a8b85433ea7269cfdfe13a6d2fcd17733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the private data handle associated with the specified node.  <br /></td></tr>
<tr class="separator:a8b85433ea7269cfdfe13a6d2fcd17733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">VM file access</div></td></tr>
<tr class="memitem:a1c83c9a961a1083fe98f3ff6470b522c" id="r_a1c83c9a961a1083fe98f3ff6470b522c"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c83c9a961a1083fe98f3ff6470b522c">can_page</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:a1c83c9a961a1083fe98f3ff6470b522c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <br /></td></tr>
<tr class="separator:a1c83c9a961a1083fe98f3ff6470b522c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765a08560a2f3e24b4cd73b0548f8bf8" id="r_a765a08560a2f3e24b4cd73b0548f8bf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a765a08560a2f3e24b4cd73b0548f8bf8">read_pages</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</td></tr>
<tr class="memdesc:a765a08560a2f3e24b4cd73b0548f8bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <br /></td></tr>
<tr class="separator:a765a08560a2f3e24b4cd73b0548f8bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67535c8aba96beb607e3fced9e513b3" id="r_ab67535c8aba96beb607e3fced9e513b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab67535c8aba96beb607e3fced9e513b3">write_pages</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</td></tr>
<tr class="memdesc:ab67535c8aba96beb607e3fced9e513b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated.  <br /></td></tr>
<tr class="separator:ab67535c8aba96beb607e3fced9e513b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Asynchronous I/O</div></td></tr>
<tr class="memitem:a1cb50407f8e001fd5a070037d4c7e523" id="r_a1cb50407f8e001fd5a070037d4c7e523"><td class="memItemLeft" align="right" valign="top"><a id="a1cb50407f8e001fd5a070037d4c7e523" name="a1cb50407f8e001fd5a070037d4c7e523"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>io</b> )(fs_volume *volume, fs_vnode *vnode, void *cookie, io_request *request)</td></tr>
<tr class="memdesc:a1cb50407f8e001fd5a070037d4c7e523"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a1cb50407f8e001fd5a070037d4c7e523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82970a8cbf9a44466702c7af998b78af" id="r_a82970a8cbf9a44466702c7af998b78af"><td class="memItemLeft" align="right" valign="top"><a id="a82970a8cbf9a44466702c7af998b78af" name="a82970a8cbf9a44466702c7af998b78af"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>cancel_io</b> )(fs_volume *volume, fs_vnode *vnode, void *cookie, io_request *request)</td></tr>
<tr class="memdesc:a82970a8cbf9a44466702c7af998b78af"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a82970a8cbf9a44466702c7af998b78af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cache File Access</div></td></tr>
<tr class="memitem:a81c3ed9e3d5e389e8e4c747ed5c75cd5" id="r_a81c3ed9e3d5e389e8e4c747ed5c75cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81c3ed9e3d5e389e8e4c747ed5c75cd5">get_file_map</a> )(fs_volume *volume, fs_vnode *vnode, off_t offset, size_t size, struct <a class="el" href="structfile__io__vec.html">file_io_vec</a> *vecs, size_t *_count)</td></tr>
<tr class="memdesc:a81c3ed9e3d5e389e8e4c747ed5c75cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <em>vecs</em> with the extents of the file data stream.  <br /></td></tr>
<tr class="separator:a81c3ed9e3d5e389e8e4c747ed5c75cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Standard Operations</div></td></tr>
<tr class="memitem:aacb3eefa89843a544f277bf93d7f9024" id="r_aacb3eefa89843a544f277bf93d7f9024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacb3eefa89843a544f277bf93d7f9024">ioctl</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> op, void *buffer, size_t length)</td></tr>
<tr class="memdesc:aacb3eefa89843a544f277bf93d7f9024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform file system specific operations.  <br /></td></tr>
<tr class="separator:aacb3eefa89843a544f277bf93d7f9024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698091aebd4ae2ead026bc8cfa98f03a" id="r_a698091aebd4ae2ead026bc8cfa98f03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a698091aebd4ae2ead026bc8cfa98f03a">set_flags</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, int flags)</td></tr>
<tr class="memdesc:a698091aebd4ae2ead026bc8cfa98f03a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the open mode flags for an opened file.  <br /></td></tr>
<tr class="separator:a698091aebd4ae2ead026bc8cfa98f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc0377c3b870447b86b362ded75a5db" id="r_a5fc0377c3b870447b86b362ded75a5db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fc0377c3b870447b86b362ded75a5db">select</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> event, selectsync *sync)</td></tr>
<tr class="memdesc:a5fc0377c3b870447b86b362ded75a5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the specified <em>vnode</em> with the specified <em>events</em>.  <br /></td></tr>
<tr class="separator:a5fc0377c3b870447b86b362ded75a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae727de6c87d28174caa0086c7d68f461" id="r_ae727de6c87d28174caa0086c7d68f461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae727de6c87d28174caa0086c7d68f461">deselect</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> event, selectsync *sync)</td></tr>
<tr class="memdesc:ae727de6c87d28174caa0086c7d68f461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deselects the specified <em>vnode</em> from a previous <a class="el" href="#a5fc0377c3b870447b86b362ded75a5db" title="Selects the specified vnode with the specified events.">select()</a> call.  <br /></td></tr>
<tr class="separator:ae727de6c87d28174caa0086c7d68f461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8aa6478f2f3fdee52aea7c06c8cc3f" id="r_a0b8aa6478f2f3fdee52aea7c06c8cc3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b8aa6478f2f3fdee52aea7c06c8cc3f">fsync</a> )(fs_volume *volume, fs_vnode *vnode)</td></tr>
<tr class="memdesc:a0b8aa6478f2f3fdee52aea7c06c8cc3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the buffers with the on disk data.  <br /></td></tr>
<tr class="separator:a0b8aa6478f2f3fdee52aea7c06c8cc3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d3579f9fc913f5bf58c5650c3f99b0" id="r_a21d3579f9fc913f5bf58c5650c3f99b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21d3579f9fc913f5bf58c5650c3f99b0">read_symlink</a> )(fs_volume *volume, fs_vnode *<a class="el" href="#ad8b6609f4e2bfdcd3d236af05b567040">link</a>, char *buffer, size_t *_bufferSize)</td></tr>
<tr class="memdesc:a21d3579f9fc913f5bf58c5650c3f99b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of a symbolic link.  <br /></td></tr>
<tr class="separator:a21d3579f9fc913f5bf58c5650c3f99b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145f690de388f442e06a7585bb82501d" id="r_a145f690de388f442e06a7585bb82501d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a145f690de388f442e06a7585bb82501d">create_symlink</a> )(fs_volume *volume, fs_vnode *dir, const char *name, const char *path, int mode)</td></tr>
<tr class="memdesc:a145f690de388f442e06a7585bb82501d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new symbolic link.  <br /></td></tr>
<tr class="separator:a145f690de388f442e06a7585bb82501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6609f4e2bfdcd3d236af05b567040" id="r_ad8b6609f4e2bfdcd3d236af05b567040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8b6609f4e2bfdcd3d236af05b567040">link</a> )(fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *vnode)</td></tr>
<tr class="memdesc:ad8b6609f4e2bfdcd3d236af05b567040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new hard link.  <br /></td></tr>
<tr class="separator:ad8b6609f4e2bfdcd3d236af05b567040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307d6e1fe8617538909f98be9c8f073c" id="r_a307d6e1fe8617538909f98be9c8f073c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307d6e1fe8617538909f98be9c8f073c">unlink</a> )(fs_volume *volume, fs_vnode *dir, const char *name)</td></tr>
<tr class="memdesc:a307d6e1fe8617538909f98be9c8f073c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a non-directory entry.  <br /></td></tr>
<tr class="separator:a307d6e1fe8617538909f98be9c8f073c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a4d2b7c43c13b599fe1aeb48e3f3a1" id="r_a87a4d2b7c43c13b599fe1aeb48e3f3a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87a4d2b7c43c13b599fe1aeb48e3f3a1">rename</a> )(fs_volume *volume, fs_vnode *fromDir, const char *fromName, fs_vnode *toDir, const char *toName)</td></tr>
<tr class="memdesc:a87a4d2b7c43c13b599fe1aeb48e3f3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename and/or relocate an entry.  <br /></td></tr>
<tr class="separator:a87a4d2b7c43c13b599fe1aeb48e3f3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ce0f48bdfdf368b0af73a0416557e3" id="r_ac9ce0f48bdfdf368b0af73a0416557e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9ce0f48bdfdf368b0af73a0416557e3">access</a> )(fs_volume *volume, fs_vnode *vnode, int mode)</td></tr>
<tr class="memdesc:ac9ce0f48bdfdf368b0af73a0416557e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the current user is allowed to access the node in the specified way.  <br /></td></tr>
<tr class="separator:ac9ce0f48bdfdf368b0af73a0416557e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacff0be7a1befc7dc296beee49fa08c0" id="r_aacff0be7a1befc7dc296beee49fa08c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacff0be7a1befc7dc296beee49fa08c0">read_stat</a> )(fs_volume *volume, fs_vnode *vnode, struct stat *stat)</td></tr>
<tr class="memdesc:aacff0be7a1befc7dc296beee49fa08c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the stat data for a given node.  <br /></td></tr>
<tr class="separator:aacff0be7a1befc7dc296beee49fa08c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8094be85bc8ad80b707ea2661be0ad75" id="r_a8094be85bc8ad80b707ea2661be0ad75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8094be85bc8ad80b707ea2661be0ad75">write_stat</a> )(fs_volume *volume, fs_vnode *vnode, const struct stat *stat, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> statMask)</td></tr>
<tr class="memdesc:a8094be85bc8ad80b707ea2661be0ad75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the stats for a vnode.  <br /></td></tr>
<tr class="separator:a8094be85bc8ad80b707ea2661be0ad75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">File Operations</div></td></tr>
<tr class="memitem:a76e5fa5833fd60e59d9857d08f69a3a3" id="r_a76e5fa5833fd60e59d9857d08f69a3a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e5fa5833fd60e59d9857d08f69a3a3">create</a> )(fs_volume *volume, fs_vnode *dir, const char *name, int openMode, int perms, void **_cookie, ino_t *_newVnodeID)</td></tr>
<tr class="memdesc:a76e5fa5833fd60e59d9857d08f69a3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and opens a new file.  <br /></td></tr>
<tr class="separator:a76e5fa5833fd60e59d9857d08f69a3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21345ca2c44e9879d6b7f5370f56738" id="r_af21345ca2c44e9879d6b7f5370f56738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af21345ca2c44e9879d6b7f5370f56738">open</a> )(fs_volume *volume, fs_vnode *vnode, int openMode, void **_cookie)</td></tr>
<tr class="memdesc:af21345ca2c44e9879d6b7f5370f56738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the given node.  <br /></td></tr>
<tr class="separator:af21345ca2c44e9879d6b7f5370f56738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c661fb13103e266cf5d8e0ea0b2d078" id="r_a2c661fb13103e266cf5d8e0ea0b2d078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c661fb13103e266cf5d8e0ea0b2d078">close</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:a2c661fb13103e266cf5d8e0ea0b2d078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the given node cookie.  <br /></td></tr>
<tr class="separator:a2c661fb13103e266cf5d8e0ea0b2d078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430cbc03b0f99b198096ef4200994a80" id="r_a430cbc03b0f99b198096ef4200994a80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a430cbc03b0f99b198096ef4200994a80">free_cookie</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:a430cbc03b0f99b198096ef4200994a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given node cookie.  <br /></td></tr>
<tr class="separator:a430cbc03b0f99b198096ef4200994a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26db810bf5f5f84ab13e801b51b45b78" id="r_a26db810bf5f5f84ab13e801b51b45b78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26db810bf5f5f84ab13e801b51b45b78">read</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</td></tr>
<tr class="memdesc:a26db810bf5f5f84ab13e801b51b45b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a file.  <br /></td></tr>
<tr class="separator:a26db810bf5f5f84ab13e801b51b45b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cb4e8381ea0fe3b01b91e508d5efed" id="r_a30cb4e8381ea0fe3b01b91e508d5efed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30cb4e8381ea0fe3b01b91e508d5efed">write</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</td></tr>
<tr class="memdesc:a30cb4e8381ea0fe3b01b91e508d5efed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to a file.  <br /></td></tr>
<tr class="separator:a30cb4e8381ea0fe3b01b91e508d5efed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Directory Operations</div></td></tr>
<tr class="memitem:ae840fe167f2b6d930ac58dae2b4331bd" id="r_ae840fe167f2b6d930ac58dae2b4331bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae840fe167f2b6d930ac58dae2b4331bd">create_dir</a> )(fs_volume *volume, fs_vnode *parent, const char *name, int perms)</td></tr>
<tr class="memdesc:ae840fe167f2b6d930ac58dae2b4331bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new directory.  <br /></td></tr>
<tr class="separator:ae840fe167f2b6d930ac58dae2b4331bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294304db2b0ca1ef5df39f7efb34616b" id="r_a294304db2b0ca1ef5df39f7efb34616b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a294304db2b0ca1ef5df39f7efb34616b">remove_dir</a> )(fs_volume *volume, fs_vnode *parent, const char *name)</td></tr>
<tr class="memdesc:a294304db2b0ca1ef5df39f7efb34616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a directory.  <br /></td></tr>
<tr class="separator:a294304db2b0ca1ef5df39f7efb34616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254b8384dfb4d16de0dfc0c339acc09d" id="r_a254b8384dfb4d16de0dfc0c339acc09d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a254b8384dfb4d16de0dfc0c339acc09d">open_dir</a> )(fs_volume *volume, fs_vnode *vnode, void **_cookie)</td></tr>
<tr class="memdesc:a254b8384dfb4d16de0dfc0c339acc09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the given directory node.  <br /></td></tr>
<tr class="separator:a254b8384dfb4d16de0dfc0c339acc09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e157f5000d841c49d90982d5b6ce102" id="r_a9e157f5000d841c49d90982d5b6ce102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e157f5000d841c49d90982d5b6ce102">close_dir</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:a9e157f5000d841c49d90982d5b6ce102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the given directory cookie.  <br /></td></tr>
<tr class="separator:a9e157f5000d841c49d90982d5b6ce102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90814f141ac61656a0538d90df3dbb56" id="r_a90814f141ac61656a0538d90df3dbb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90814f141ac61656a0538d90df3dbb56">free_dir_cookie</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:a90814f141ac61656a0538d90df3dbb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given directory cookie.  <br /></td></tr>
<tr class="separator:a90814f141ac61656a0538d90df3dbb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db0d6e2faacb789b7c12e14b915e412" id="r_a9db0d6e2faacb789b7c12e14b915e412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9db0d6e2faacb789b7c12e14b915e412">read_dir</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td></tr>
<tr class="memdesc:a9db0d6e2faacb789b7c12e14b915e412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next one or more directory entries.  <br /></td></tr>
<tr class="separator:a9db0d6e2faacb789b7c12e14b915e412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddacf6e778fed957f50a2e4964b82fe" id="r_acddacf6e778fed957f50a2e4964b82fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acddacf6e778fed957f50a2e4964b82fe">rewind_dir</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:acddacf6e778fed957f50a2e4964b82fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the directory cookie to the first entry of the directory.  <br /></td></tr>
<tr class="separator:acddacf6e778fed957f50a2e4964b82fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute Directory Operations</div></td></tr>
<tr class="memitem:a10e3347cf421be918a4702766902ff28" id="r_a10e3347cf421be918a4702766902ff28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10e3347cf421be918a4702766902ff28">open_attr_dir</a> )(fs_volume *volume, fs_vnode *vnode, void **_cookie)</td></tr>
<tr class="memdesc:a10e3347cf421be918a4702766902ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a 'directory' of attributes for a <em>vnode</em>.  <br /></td></tr>
<tr class="separator:a10e3347cf421be918a4702766902ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd62fcd4de0b9da05b25868bce756dc" id="r_aacd62fcd4de0b9da05b25868bce756dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacd62fcd4de0b9da05b25868bce756dc">close_attr_dir</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:aacd62fcd4de0b9da05b25868bce756dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a 'directory' of attributes for a <em>vnode</em>.  <br /></td></tr>
<tr class="separator:aacd62fcd4de0b9da05b25868bce756dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7f6bd882c5793de946e0e3f0f7d89b" id="r_aad7f6bd882c5793de946e0e3f0f7d89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7f6bd882c5793de946e0e3f0f7d89b">free_attr_dir_cookie</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:aad7f6bd882c5793de946e0e3f0f7d89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the <em>cookie</em> to an attribute 'directory'.  <br /></td></tr>
<tr class="separator:aad7f6bd882c5793de946e0e3f0f7d89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a5cf9baa4bdbb32b74559a179aa7ff" id="r_a01a5cf9baa4bdbb32b74559a179aa7ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a5cf9baa4bdbb32b74559a179aa7ff">read_attr_dir</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td></tr>
<tr class="memdesc:a01a5cf9baa4bdbb32b74559a179aa7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next one or more attribute directory entries.  <br /></td></tr>
<tr class="separator:a01a5cf9baa4bdbb32b74559a179aa7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fc1db89cf969429d879a28c61aa413" id="r_ab0fc1db89cf969429d879a28c61aa413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0fc1db89cf969429d879a28c61aa413">rewind_attr_dir</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:ab0fc1db89cf969429d879a28c61aa413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewind the attribute directory iterator to the first entry.  <br /></td></tr>
<tr class="separator:ab0fc1db89cf969429d879a28c61aa413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Attribute Operations</div></td></tr>
<tr class="memitem:a47e20f1d2c106f161f651f065532a864" id="r_a47e20f1d2c106f161f651f065532a864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47e20f1d2c106f161f651f065532a864">create_attr</a> )(fs_volume *volume, fs_vnode *vnode, const char *name, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> type, int openMode, void **_cookie)</td></tr>
<tr class="memdesc:a47e20f1d2c106f161f651f065532a864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new attribute.  <br /></td></tr>
<tr class="separator:a47e20f1d2c106f161f651f065532a864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd27cc66fcba3c7fe5a9c88d127cb4" id="r_aefdd27cc66fcba3c7fe5a9c88d127cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefdd27cc66fcba3c7fe5a9c88d127cb4">open_attr</a> )(fs_volume *volume, fs_vnode *vnode, const char *name, int openMode, void **_cookie)</td></tr>
<tr class="memdesc:aefdd27cc66fcba3c7fe5a9c88d127cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open an existing attribute.  <br /></td></tr>
<tr class="separator:aefdd27cc66fcba3c7fe5a9c88d127cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557b761b7d8ba7b2f9a2f89a4ba48bca" id="r_a557b761b7d8ba7b2f9a2f89a4ba48bca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a557b761b7d8ba7b2f9a2f89a4ba48bca">close_attr</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:a557b761b7d8ba7b2f9a2f89a4ba48bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close access to an attribute.  <br /></td></tr>
<tr class="separator:a557b761b7d8ba7b2f9a2f89a4ba48bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27077f1f6788be75abe2ce8b2f6c965" id="r_ad27077f1f6788be75abe2ce8b2f6c965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad27077f1f6788be75abe2ce8b2f6c965">free_attr_cookie</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie)</td></tr>
<tr class="memdesc:ad27077f1f6788be75abe2ce8b2f6c965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the cookie of an attribute.  <br /></td></tr>
<tr class="separator:ad27077f1f6788be75abe2ce8b2f6c965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfda67268ee8f8e9c4215fb2279edb1" id="r_a4cfda67268ee8f8e9c4215fb2279edb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cfda67268ee8f8e9c4215fb2279edb1">read_attr</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</td></tr>
<tr class="memdesc:a4cfda67268ee8f8e9c4215fb2279edb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read attribute data.  <br /></td></tr>
<tr class="separator:a4cfda67268ee8f8e9c4215fb2279edb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e344c86fc5d2cc525bd12a57a1e07d7" id="r_a5e344c86fc5d2cc525bd12a57a1e07d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e344c86fc5d2cc525bd12a57a1e07d7">write_attr</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</td></tr>
<tr class="memdesc:a5e344c86fc5d2cc525bd12a57a1e07d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write attribute data.  <br /></td></tr>
<tr class="separator:a5e344c86fc5d2cc525bd12a57a1e07d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24778f496711108ba579c82aa916ca8b" id="r_a24778f496711108ba579c82aa916ca8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24778f496711108ba579c82aa916ca8b">read_attr_stat</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, struct stat *stat)</td></tr>
<tr class="memdesc:a24778f496711108ba579c82aa916ca8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the stats for an attribute.  <br /></td></tr>
<tr class="separator:a24778f496711108ba579c82aa916ca8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9488dfef299234a99c8f86c6cf905e6e" id="r_a9488dfef299234a99c8f86c6cf905e6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9488dfef299234a99c8f86c6cf905e6e">write_attr_stat</a> )(fs_volume *volume, fs_vnode *vnode, void *cookie, const struct stat *stat, int statMask)</td></tr>
<tr class="memdesc:a9488dfef299234a99c8f86c6cf905e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the stats of an attribute.  <br /></td></tr>
<tr class="separator:a9488dfef299234a99c8f86c6cf905e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b86590c425849a43953c790f84dde9" id="r_a20b86590c425849a43953c790f84dde9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a20b86590c425849a43953c790f84dde9">rename_attr</a> )(fs_volume *volume, fs_vnode *fromVnode, const char *fromName, fs_vnode *toVnode, const char *toName)</td></tr>
<tr class="memdesc:a20b86590c425849a43953c790f84dde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename and/or relocate an attribute.  <br /></td></tr>
<tr class="separator:a20b86590c425849a43953c790f84dde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e405048c470a1446b842a244f02eb9" id="r_a08e405048c470a1446b842a244f02eb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e405048c470a1446b842a244f02eb9">remove_attr</a> )(fs_volume *volume, fs_vnode *vnode, const char *name)</td></tr>
<tr class="memdesc:a08e405048c470a1446b842a244f02eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an attribute.  <br /></td></tr>
<tr class="separator:a08e405048c470a1446b842a244f02eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node and FS Layers</div></td></tr>
<tr class="memitem:a1b6d9a5caef702b80469873c37088a3a" id="r_a1b6d9a5caef702b80469873c37088a3a"><td class="memItemLeft" align="right" valign="top"><a id="a1b6d9a5caef702b80469873c37088a3a" name="a1b6d9a5caef702b80469873c37088a3a"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>create_special_node</b> )(fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *subVnode, mode_t mode, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags, fs_vnode *_superVnode, ino_t *_nodeID)</td></tr>
<tr class="memdesc:a1b6d9a5caef702b80469873c37088a3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a1b6d9a5caef702b80469873c37088a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d2989e387b9a4d0517a822cce12d2c" id="r_a84d2989e387b9a4d0517a822cce12d2c"><td class="memItemLeft" align="right" valign="top"><a id="a84d2989e387b9a4d0517a822cce12d2c" name="a84d2989e387b9a4d0517a822cce12d2c"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>get_super_vnode</b> )(fs_volume *volume, fs_vnode *vnode, fs_volume *superVolume, fs_vnode *superVnode)</td></tr>
<tr class="memdesc:a84d2989e387b9a4d0517a822cce12d2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a84d2989e387b9a4d0517a822cce12d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Operations vector for a node. </p>
<p>See the <a class="el" href="fs_modules.html">introduction to file system modules</a> for an introduction to writing file systems. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="ac9ce0f48bdfdf368b0af73a0416557e3" name="ac9ce0f48bdfdf368b0af73a0416557e3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/access" class="dashAnchor">&nbsp;</a><a href="#ac9ce0f48bdfdf368b0af73a0416557e3">&#9670;&#160;</a></span>access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::access) (fs_volume *volume, fs_vnode *vnode, int mode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the current user is allowed to access the node in the specified way. </p>
<p><em>mode</em> is a bitwise combination of:</p><ul>
<li><code>R_OK:</code> Read access.</li>
<li><code>W_OK:</code> Write access.</li>
<li><code>X_OK:</code> Execution.</li>
</ul>
<p>If the current user does not have any of the access permissions represented by the set bits, the function shall return <code>B_NOT_ALLOWED</code>. As a special case, if the volume is read-only and write access is requested, <code>B_READ_ONLY_DEVICE</code> shall be returned. If the requested access mode complies with the user's access permissions, the function shall return <code>B_OK</code>.</p>
<p>For most FSs the permissions a user has are defined by the <code>st_mode</code>, <code>st_uid</code>, and <code>st_gid</code> fields of the node's stat data. As a special exception, the root user (<code>geteuid() == 0</code>) does always have read and write permissions, execution permission only when at least one of the execution permission bits are set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">mode</td><td>The access mode mask. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The user has the permissions to access the node in the requested way. </td></tr>
    <tr><td class="paramname">B_READ_ONLY_DEVICE</td><td>The volume is read-only, but the write access has been requested. </td></tr>
    <tr><td class="paramname">B_NOT_ALLOWED</td><td>The user does not have all permissions to access the node in the requested way. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c83c9a961a1083fe98f3ff6470b522c" name="a1c83c9a961a1083fe98f3ff6470b522c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/can_page" class="dashAnchor">&nbsp;</a><a href="#a1c83c9a961a1083fe98f3ff6470b522c">&#9670;&#160;</a></span>can_page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* fs_vnode_ops::can_page) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>

</div>
</div>
<a id="a2c661fb13103e266cf5d8e0ea0b2d078" name="a2c661fb13103e266cf5d8e0ea0b2d078"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/close" class="dashAnchor">&nbsp;</a><a href="#a2c661fb13103e266cf5d8e0ea0b2d078">&#9670;&#160;</a></span>close</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::close) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the given node cookie. </p>
<p>The hook is invoked, when closing the node has been requested. At this point other threads might still use the cookie, i.e. still execute hooks to which the cookie has been passed. If the FS supports blocking I/O operations, this hook should make sure to unblock all currently blocking threads performing an operation using the cookie, and mark the cookie such that no further threads will block using it.</p>
<p>For many FSs this hook is a no-op &ndash; it's mandatory to be exported, though.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The node cookie as returned by <a class="el" href="#af21345ca2c44e9879d6b7f5370f56738" title="Opens the given node.">open()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a557b761b7d8ba7b2f9a2f89a4ba48bca" name="a557b761b7d8ba7b2f9a2f89a4ba48bca"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/close_attr" class="dashAnchor">&nbsp;</a><a href="#a557b761b7d8ba7b2f9a2f89a4ba48bca">&#9670;&#160;</a></span>close_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::close_attr) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close access to an attribute. </p>
<p>Note that you should not delete the cookie yet, you should do that when the VFS calls <a class="el" href="#ad27077f1f6788be75abe2ce8b2f6c965" title="Free the cookie of an attribute.">free_attr_cookie()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie you associated with this attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="aacd62fcd4de0b9da05b25868bce756dc" name="aacd62fcd4de0b9da05b25868bce756dc"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/close_attr_dir" class="dashAnchor">&nbsp;</a><a href="#aacd62fcd4de0b9da05b25868bce756dc">&#9670;&#160;</a></span>close_attr_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::close_attr_dir) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a 'directory' of attributes for a <em>vnode</em>. </p>
<p>Note that you should free the cookie in the <a class="el" href="#aad7f6bd882c5793de946e0e3f0f7d89b" title="Free the cookie to an attribute &#39;directory&#39;.">free_attr_dir_cookie()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie associated with this 'directory'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a9e157f5000d841c49d90982d5b6ce102" name="a9e157f5000d841c49d90982d5b6ce102"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/close_dir" class="dashAnchor">&nbsp;</a><a href="#a9e157f5000d841c49d90982d5b6ce102">&#9670;&#160;</a></span>close_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::close_dir) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the given directory cookie. </p>
<p>Generally the situation is similar to the one described for <a class="el" href="#a2c661fb13103e266cf5d8e0ea0b2d078" title="Closes the given node cookie.">close()</a>. In practice it is a bit different, though, since directory cookies are exclusively used for directory iteration, and it normally doesn't make sense to have multiple threads read the same directory concurrently. Furthermore usually reading a directory will not block. Therefore for most FSs this hook is a no-op.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The directory cookie as returned by <a class="el" href="#a254b8384dfb4d16de0dfc0c339acc09d" title="Opens the given directory node.">open_dir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a76e5fa5833fd60e59d9857d08f69a3a3" name="a76e5fa5833fd60e59d9857d08f69a3a3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/create" class="dashAnchor">&nbsp;</a><a href="#a76e5fa5833fd60e59d9857d08f69a3a3">&#9670;&#160;</a></span>create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::create) (fs_volume *volume, fs_vnode *dir, const char *name, int openMode, int perms, void **_cookie, ino_t *_newVnodeID)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and opens a new file. </p>
<p>The hook is similar to <a class="el" href="#af21345ca2c44e9879d6b7f5370f56738">open() </a>, with the difference that, if an entry with the name <em>name</em> does not already exist in the given directory, a new file with that name is created first. If the entry does already exist and <em>openMode</em> specifies the <code>O_EXCL</code> flag, the function shall fail with <code>B_FILE_EXISTS</code> (aka <code>EEXIST</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">dir</td><td>The node object for the directory where the file should appear. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The name of the new file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">openMode</td><td>The mode associated to the file. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">perms</td><td>The permissions the new file should have. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_cookie</td><td>In case of success, the storage where you can put your FS specific cookie for the open node. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_newVnodeID</td><td>In case of success, you can store the new vnode id in this variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If opening the node succeeded (after creating it first, if necessary), <code>B_OK</code> shall be returned and <em>_cookie</em> and <em>_newVnodeID</em> shall be set. Otherwise an error code shall be returned. </dd></dl>

</div>
</div>
<a id="a47e20f1d2c106f161f651f065532a864" name="a47e20f1d2c106f161f651f065532a864"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/create_attr" class="dashAnchor">&nbsp;</a><a href="#a47e20f1d2c106f161f651f065532a864">&#9670;&#160;</a></span>create_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::create_attr) (fs_volume *volume, fs_vnode *vnode, const char *name, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> type, int openMode, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new attribute. </p>
<p>If the attribute already exists, you should open it in truncated mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The name of the attribute. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>The <code>type_code</code> of the attribute. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">openMode</td><td>The openMode of the associated attribute. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_cookie</td><td>A pointer where you can store an associated file system cookie. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="ae840fe167f2b6d930ac58dae2b4331bd" name="ae840fe167f2b6d930ac58dae2b4331bd"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/create_dir" class="dashAnchor">&nbsp;</a><a href="#ae840fe167f2b6d930ac58dae2b4331bd">&#9670;&#160;</a></span>create_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::create_dir) (fs_volume *volume, fs_vnode *parent, const char *name, int perms)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">parent</td><td>The node object for the directory in which to create the new directory. </td></tr>
    <tr><td class="paramname">name</td><td>The name the new directory should have. </td></tr>
    <tr><td class="paramname">perms</td><td>The permissions the new directory should have. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if the directory was created successfully, an error code otherwise. </dd></dl>

</div>
</div>
<a id="a145f690de388f442e06a7585bb82501d" name="a145f690de388f442e06a7585bb82501d"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/create_symlink" class="dashAnchor">&nbsp;</a><a href="#a145f690de388f442e06a7585bb82501d">&#9670;&#160;</a></span>create_symlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::create_symlink) (fs_volume *volume, fs_vnode *dir, const char *name, const char *path, int mode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new symbolic link. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">dir</td><td>The node object for the directory the symbolic link should be created in. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the new symbolic link. </td></tr>
    <tr><td class="paramname">path</td><td>The path the symbolic link should refer to. </td></tr>
    <tr><td class="paramname">mode</td><td>The permissions for the newly created symbolic link. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if you succeeded, or an error code if you failed. </dd></dl>

</div>
</div>
<a id="ae727de6c87d28174caa0086c7d68f461" name="ae727de6c87d28174caa0086c7d68f461"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/deselect" class="dashAnchor">&nbsp;</a><a href="#ae727de6c87d28174caa0086c7d68f461">&#9670;&#160;</a></span>deselect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::deselect) (fs_volume *volume, fs_vnode *vnode, void *cookie, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> event, selectsync *sync)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deselects the specified <em>vnode</em> from a previous <a class="el" href="#a5fc0377c3b870447b86b362ded75a5db" title="Selects the specified vnode with the specified events.">select()</a> call. </p>
<p>This function is called by the VFS whenever a <a class="el" href="#a5fc0377c3b870447b86b362ded75a5db" title="Selects the specified vnode with the specified events.">select()</a> or poll() function exits that previously called file_system_module_info::select() on that <em>vnode</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The file system provided cookie associated with the opened file. </td></tr>
    <tr><td class="paramname">event</td><td>The event to be deselected. </td></tr>
    <tr><td class="paramname">sync</td><td>Opaque pointer to be passed to notify_select_event(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if the operation succeeded, or else an error code. </dd></dl>

</div>
</div>
<a id="ad27077f1f6788be75abe2ce8b2f6c965" name="ad27077f1f6788be75abe2ce8b2f6c965"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/free_attr_cookie" class="dashAnchor">&nbsp;</a><a href="#ad27077f1f6788be75abe2ce8b2f6c965">&#9670;&#160;</a></span>free_attr_cookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::free_attr_cookie) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the cookie of an attribute. </p>
<p>The VFS calls this hook when all operations on the attribute have ceased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie to the attribute that should be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="aad7f6bd882c5793de946e0e3f0f7d89b" name="aad7f6bd882c5793de946e0e3f0f7d89b"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/free_attr_dir_cookie" class="dashAnchor">&nbsp;</a><a href="#aad7f6bd882c5793de946e0e3f0f7d89b">&#9670;&#160;</a></span>free_attr_dir_cookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::free_attr_dir_cookie) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the <em>cookie</em> to an attribute 'directory'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie associated that should be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a430cbc03b0f99b198096ef4200994a80" name="a430cbc03b0f99b198096ef4200994a80"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/free_cookie" class="dashAnchor">&nbsp;</a><a href="#a430cbc03b0f99b198096ef4200994a80">&#9670;&#160;</a></span>free_cookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::free_cookie) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given node cookie. </p>
<p>The hook is invoked after <a class="el" href="#a2c661fb13103e266cf5d8e0ea0b2d078" title="Closes the given node cookie.">close()</a>, when no other thread uses or is going to use the cookie. All resources associated with the cookie must be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The node cookie as returned by <a class="el" href="#af21345ca2c44e9879d6b7f5370f56738" title="Opens the given node.">open()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a90814f141ac61656a0538d90df3dbb56" name="a90814f141ac61656a0538d90df3dbb56"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/free_dir_cookie" class="dashAnchor">&nbsp;</a><a href="#a90814f141ac61656a0538d90df3dbb56">&#9670;&#160;</a></span>free_dir_cookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::free_dir_cookie) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given directory cookie. </p>
<p>The hook is invoked after <a class="el" href="#a9e157f5000d841c49d90982d5b6ce102" title="Closes the given directory cookie.">close_dir()</a>, when no other thread uses or is going to use the cookie. All resources associated with the cookie must be freed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The directory cookie as returned by <a class="el" href="#a254b8384dfb4d16de0dfc0c339acc09d" title="Opens the given directory node.">open_dir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a0b8aa6478f2f3fdee52aea7c06c8cc3f" name="a0b8aa6478f2f3fdee52aea7c06c8cc3f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/fsync" class="dashAnchor">&nbsp;</a><a href="#a0b8aa6478f2f3fdee52aea7c06c8cc3f">&#9670;&#160;</a></span>fsync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::fsync) (fs_volume *volume, fs_vnode *vnode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize the buffers with the on disk data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if the operation succeeded, or else an error code. </dd></dl>

</div>
</div>
<a id="a81c3ed9e3d5e389e8e4c747ed5c75cd5" name="a81c3ed9e3d5e389e8e4c747ed5c75cd5"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_file_map" class="dashAnchor">&nbsp;</a><a href="#a81c3ed9e3d5e389e8e4c747ed5c75cd5">&#9670;&#160;</a></span>get_file_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::get_file_map) (fs_volume *volume, fs_vnode *vnode, off_t offset, size_t size, struct <a class="el" href="structfile__io__vec.html">file_io_vec</a> *vecs, size_t *_count)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <em>vecs</em> with the extents of the file data stream. </p>
<p>This function is called only when you are using the file cache, but if you use it, its implementation is mandatory.</p>
<p>TODO: complete me </p>

</div>
</div>
<a id="a91e45189c413dd69b09bc5f419b5d61f" name="a91e45189c413dd69b09bc5f419b5d61f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_vnode_name" class="dashAnchor">&nbsp;</a><a href="#a91e45189c413dd69b09bc5f419b5d61f">&#9670;&#160;</a></span>get_vnode_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::get_vnode_name) (fs_volume *volume, fs_vnode *vnode, char *buffer, size_t bufferSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the file name of a directory vnode. </p>
<p>Normally file systems don't support hard links for directories, which means that a directory can be addressed by a unique path. This hook returns the name of the directory's entry in its parent directory.</p>
<p>Note that you don't have to implement this call if it can't be easily done; it's completely optional. If you don't implement it, you'll have to export a NULL pointer for this function in the module definition. In this case, the VFS will find the name by iterating over its parent directory.</p>
<p>If invoked for a non-directory node the hook is allowed to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer that the name can be copied into. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>You successfully copied the file name into the <em>buffer</em>. </td></tr>
    <tr><td class="paramname">other errors</td><td>There was some error looking up or copying the name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aacb3eefa89843a544f277bf93d7f9024" name="aacb3eefa89843a544f277bf93d7f9024"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/ioctl" class="dashAnchor">&nbsp;</a><a href="#aacb3eefa89843a544f277bf93d7f9024">&#9670;&#160;</a></span>ioctl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::ioctl) (fs_volume *volume, fs_vnode *vnode, void *cookie, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> op, void *buffer, size_t length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform file system specific operations. </p>
<p>You can implement a customized API using this call. This can be extremely handy for debugging purposes. There are no obligatory operations for you to implement.</p>
<p>If you don't want to use this feature, you don't have to implement it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The file system provided cookie associated with, for example, an open file (if applicable). </td></tr>
    <tr><td class="paramname">op</td><td>The operation code. You will have to define them yourself. </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer (if applicable). </td></tr>
    <tr><td class="paramname">length</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return any of your status codes. </dd></dl>

</div>
</div>
<a id="ad8b6609f4e2bfdcd3d236af05b567040" name="ad8b6609f4e2bfdcd3d236af05b567040"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/link" class="dashAnchor">&nbsp;</a><a href="#ad8b6609f4e2bfdcd3d236af05b567040">&#9670;&#160;</a></span>link</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::link) (fs_volume *volume, fs_vnode *dir, const char *name, fs_vnode *vnode)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new hard link. </p>
<p>The virtual file system will request the creation of symbolic links with <a class="el" href="#a145f690de388f442e06a7585bb82501d" title="Create a new symbolic link.">create_symlink()</a>.</p>
<p>If you don't implement this function, the VFS will return <code>EROFS</code> when a hard link is requested. So, if you don't support hard links implement this hook and return an appropriate error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">dir</td><td>The node object for the directory where the link should be created. </td></tr>
    <tr><td class="paramname">name</td><td>The name the link should have. </td></tr>
    <tr><td class="paramname">vnode</td><td>The vnode the new link should resolve to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The hard link is properly created. </td></tr>
    <tr><td class="paramname">B_NOT_ALLOWED</td><td>The user does not have the proper permissions. </td></tr>
    <tr><td class="paramname">other errors</td><td>Another error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f42b700e62d2750df7607234a9d0f87" name="a8f42b700e62d2750df7607234a9d0f87"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/lookup" class="dashAnchor">&nbsp;</a><a href="#a8f42b700e62d2750df7607234a9d0f87">&#9670;&#160;</a></span>lookup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::lookup) (fs_volume *volume, fs_vnode *dir, const char *name, ino_t *_id)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up the node a directory entry refers to. </p>
<p>The VFS uses this hook to resolve path names to vnodes. It is used quite often and should be implemented efficiently.</p>
<p>If the parameter <em>dir</em> does not specify a directory, the function shall fail. It shall also fail, if it is a directory, but does not contain an entry with the given name <em>name</em>. Otherwise the function shall invoke <a class="el" href="fs__interface_8h.html#a2cfcf01bba17eee0ad3f84115051b281" title="Retrieves the private data handle for the node with the given ID.">get_vnode()</a> for the node the entry refers to and pass back the ID of the node in <em>_id</em>.</p>
<p>Note that a directory must contain the special entries <code>"."</code> and <code>".."</code>, referring to the same directory and the parent directory respectively. <a class="el" href="#a8f42b700e62d2750df7607234a9d0f87" title="Looks up the node a directory entry refers to.">lookup()</a> must resolve the nodes accordingly. <code>".."</code> for the root directory of the volume shall be resolved to the root directory itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">dir</td><td>The node object for the directory. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the directory entry. </td></tr>
    <tr><td class="paramname">_id</td><td>Pointer to a pre-allocated variable the ID of the found node shall be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Everything went fine. </td></tr>
    <tr><td class="paramname">B_NOT_A_DIRECTORY</td><td>The given node is not a directory. </td></tr>
    <tr><td class="paramname">B_ENTRY_NOT_FOUND</td><td>The given directory does not contain an entry with the given name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af21345ca2c44e9879d6b7f5370f56738" name="af21345ca2c44e9879d6b7f5370f56738"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/open" class="dashAnchor">&nbsp;</a><a href="#af21345ca2c44e9879d6b7f5370f56738">&#9670;&#160;</a></span>open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::open) (fs_volume *volume, fs_vnode *vnode, int openMode, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the given node. </p>
<p>The hook is invoked whenever a file is opened (e.g. via the <a class="el" href="#af21345ca2c44e9879d6b7f5370f56738" title="Opens the given node.">open()</a> POSIX function).</p>
<p>The hook can create a node cookie, and store it in the variable <em>_cookie</em> points to. The cookie will be passed to all hooks that operate on open files.</p>
<p>The open mode <em>openMode</em> is encoded in the same way as the parameter of the POSIX function <code><a class="el" href="#af21345ca2c44e9879d6b7f5370f56738" title="Opens the given node.">open()</a></code>, i.e. it is either <code>O_RDONLY</code>, <code>O_WRONLY</code>, or <code>O_RDWR</code>, bitwise or'ed with flags. The only relevant flags for this hook are <code>O_TRUNC</code> and <code>O_NONBLOCK</code>. You will normally want to store the open mode in the file cookie, since you'll have to check in <a class="el" href="#a26db810bf5f5f84ab13e801b51b45b78" title="Reads data from a file.">read()</a> and <a class="el" href="#a30cb4e8381ea0fe3b01b91e508d5efed" title="Write data to a file.">write()</a> whether the the respective operation is allowed by the open mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">openMode</td><td>The open mode. </td></tr>
    <tr><td class="paramname">_cookie</td><td>Pointer to a pre-allocated variable the node cookie shall be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="aefdd27cc66fcba3c7fe5a9c88d127cb4" name="aefdd27cc66fcba3c7fe5a9c88d127cb4"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/open_attr" class="dashAnchor">&nbsp;</a><a href="#aefdd27cc66fcba3c7fe5a9c88d127cb4">&#9670;&#160;</a></span>open_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::open_attr) (fs_volume *volume, fs_vnode *vnode, const char *name, int openMode, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open an existing attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>The name of the attribute. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">openMode</td><td>The mode in which you want to open the attribute data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_cookie</td><td>A pointer where you can store an associated file system cookie. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a10e3347cf421be918a4702766902ff28" name="a10e3347cf421be918a4702766902ff28"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/open_attr_dir" class="dashAnchor">&nbsp;</a><a href="#a10e3347cf421be918a4702766902ff28">&#9670;&#160;</a></span>open_attr_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::open_attr_dir) (fs_volume *volume, fs_vnode *vnode, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a 'directory' of attributes for a <em>vnode</em>. </p>
<p>See <a class="el" href="fs_modules.html#concepts">Generic Concepts</a> on directories and iterators. Basically, the VFS uses the same way of traversing through attributes as it traverses through a directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_cookie</td><td>Pointer where the file system can store a directory cookie if the attribute directory is succesfully opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a254b8384dfb4d16de0dfc0c339acc09d" name="a254b8384dfb4d16de0dfc0c339acc09d"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/open_dir" class="dashAnchor">&nbsp;</a><a href="#a254b8384dfb4d16de0dfc0c339acc09d">&#9670;&#160;</a></span>open_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::open_dir) (fs_volume *volume, fs_vnode *vnode, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens the given directory node. </p>
<p>If the specified node is not a directory, the function shall fail. Otherwise it shall allocate a directory cookie and store it in the variable <em>_cookie</em> points to. A subsequent <a class="el" href="#a9db0d6e2faacb789b7c12e14b915e412" title="Reads the next one or more directory entries.">read_dir()</a> using the cookie shall start reading the first entry of the directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">_cookie</td><td>Pointer to a pre-allocated variable the directory cookie shall be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="ad230d461e05b460a42fb89aeab816d39" name="ad230d461e05b460a42fb89aeab816d39"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/put_vnode" class="dashAnchor">&nbsp;</a><a href="#ad230d461e05b460a42fb89aeab816d39">&#9670;&#160;</a></span>put_vnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::put_vnode) (fs_volume *volume, fs_vnode *vnode, bool reenter)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the private data handle associated with the specified node. </p>
<p>Invoked by the VFS when it deletes the vnode for the respective node and the node is not marked removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">reenter</td><td><code>true</code> if the hook invocation has been caused by the FS itself, e.g. by invoking <a class="el" href="#ad230d461e05b460a42fb89aeab816d39" title="Deletes the private data handle associated with the specified node.">put_vnode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a26db810bf5f5f84ab13e801b51b45b78" name="a26db810bf5f5f84ab13e801b51b45b78"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read" class="dashAnchor">&nbsp;</a><a href="#a26db810bf5f5f84ab13e801b51b45b78">&#9670;&#160;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read) (fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from a file. </p>
<p>This function should fail if</p><ul>
<li>the node is not a file,</li>
<li>the cookie has not been opened for reading,</li>
<li><em>pos</em> is negative, or</li>
<li>some other error occurs while trying to read the data, and no data have been read at all.</li>
</ul>
<p>The number of bytes to be read is stored in the variable pointed to by <em>length</em>. If less data is available at file position <em>pos</em>, or if <em>pos</em> if greater than the size of the file, only as many data as available shall be read, the function shall store the number of bytes actually read into the variable pointed to by <em>length</em>, and return <code>B_OK</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The node cookie as returned by <a class="el" href="#af21345ca2c44e9879d6b7f5370f56738" title="Opens the given node.">open()</a>. </td></tr>
    <tr><td class="paramname">pos</td><td>The file position where to start reading data. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a pre-allocated buffer the read data shall be written to. </td></tr>
    <tr><td class="paramname">length</td><td>Pointer to a pre-allocated variable containing the size of the buffer when invoked, and into which the size of the data actually read shall be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a4cfda67268ee8f8e9c4215fb2279edb1" name="a4cfda67268ee8f8e9c4215fb2279edb1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_attr" class="dashAnchor">&nbsp;</a><a href="#a4cfda67268ee8f8e9c4215fb2279edb1">&#9670;&#160;</a></span>read_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_attr) (fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, void *buffer, size_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read attribute data. </p>
<p>Read until the <em>buffer</em> with size <em>length</em> is full, or until you are out of data, in which case you should update <em>length</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie you associated with this attribute. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to start reading from. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer the data should be copied in. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the buffer. Update this variable to the actual amount of bytes read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a01a5cf9baa4bdbb32b74559a179aa7ff" name="a01a5cf9baa4bdbb32b74559a179aa7ff"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_attr_dir" class="dashAnchor">&nbsp;</a><a href="#a01a5cf9baa4bdbb32b74559a179aa7ff">&#9670;&#160;</a></span>read_attr_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_attr_dir) (fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next one or more attribute directory entries. </p>
<p>This method should perform the same tasks as <a class="el" href="#a9db0d6e2faacb789b7c12e14b915e412" title="Reads the next one or more directory entries.">read_dir()</a>, except that the '.' and '..' entries do not have to be present. Also, only the <code>d_name</code> and <code>d_reclen</code> fields have to be filled in. </p>

</div>
</div>
<a id="a24778f496711108ba579c82aa916ca8b" name="a24778f496711108ba579c82aa916ca8b"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_attr_stat" class="dashAnchor">&nbsp;</a><a href="#a24778f496711108ba579c82aa916ca8b">&#9670;&#160;</a></span>read_attr_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_attr_stat) (fs_volume *volume, fs_vnode *vnode, void *cookie, struct stat *stat)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the stats for an attribute. </p>
<p>Only the <code>st_size</code> and <code>st_type</code> fields need to be filled in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie you associated with this attribute. </td></tr>
    <tr><td class="paramname">stat</td><td>A pointer to a stat structure you should fill. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a9db0d6e2faacb789b7c12e14b915e412" name="a9db0d6e2faacb789b7c12e14b915e412"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_dir" class="dashAnchor">&nbsp;</a><a href="#a9db0d6e2faacb789b7c12e14b915e412">&#9670;&#160;</a></span>read_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_dir) (fs_volume *volume, fs_vnode *vnode, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the next one or more directory entries. </p>
<p>The number of entries to be read at maximum is stored in the variable <em>_num</em> points to.</p>
<p>Per read <code>dirent</code> the following fields have to be filled in:</p><ul>
<li><code>d_dev:</code> The volume ID.</li>
<li><code>d_ino:</code> The ID of the node the entry refers to.</li>
<li><code>d_name:</code> The null-terminated name of the entry.</li>
<li><code>d_reclen:</code> The size of the <code>dirent</code> structure in bytes, starting from the beginning of the structure, counting all bytes up to and including the null-termination char of the name stored in <code>d_name</code>.</li>
</ul>
<p>If more than one entry is read, the corresponding <code>dirent</code> structures are tightly packed, i.e. the second entry can begin directly after the end of the first one (i.e. <code>d_reclen</code> bytes after the beginning of the first one). The file system should make sure that the dirents are 8-byte aligned, i.e. when another entry follows, <code>d_reclen</code> of the previous one should be aligned. A FS doesn't have to read more than one entry at a time, but it is recommended to support that for performance reasons.</p>
<p>If the provided buffer is too small to contain even the single next entry, <code>B_BUFFER_OVERFLOW</code> shall be returned. It shall not fail, if at least one entry has been read, and the buffer is just too small to hold as many entries as requested. When the function is invoked after the end of the directory has been reached, it shall set the variable <em>_num</em> points to <code>0</code> and return <code>B_OK</code>. Usually the function is invoked repeatedly until then to get more entries. The <code>cookie</code> parameter must be used to track the position in the directory.</p>
<p>Note that a directory is expected to contain the special entries <code>"."</code> and <code>".."</code>, referring to the same directory and the parent directory respectively. The <code>dirent</code> structure returned for the <code>".."</code> entry of the volume's root directory shall refer to the root node itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The directory cookie as returned by <a class="el" href="#a254b8384dfb4d16de0dfc0c339acc09d" title="Opens the given directory node.">open_dir()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a pre-allocated buffer the directory entries shall be written to. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of <em>buffer</em> in bytes. </td></tr>
    <tr><td class="paramname">_num</td><td>Pointer to a pre-allocated variable, when invoked, containing the number of directory entries to be read, and into which the number of entries actually read shall be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a765a08560a2f3e24b4cd73b0548f8bf8" name="a765a08560a2f3e24b4cd73b0548f8bf8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_pages" class="dashAnchor">&nbsp;</a><a href="#a765a08560a2f3e24b4cd73b0548f8bf8">&#9670;&#160;</a></span>read_pages</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_pages) (fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>

</div>
</div>
<a id="aacff0be7a1befc7dc296beee49fa08c0" name="aacff0be7a1befc7dc296beee49fa08c0"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_stat" class="dashAnchor">&nbsp;</a><a href="#aacff0be7a1befc7dc296beee49fa08c0">&#9670;&#160;</a></span>read_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_stat) (fs_volume *volume, fs_vnode *vnode, struct stat *stat)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the stat data for a given node. </p>
<p>All values of the <code>struct stat</code> save <code>st_dev</code>, <code>st_ino</code>, <code>st_rdev</code>, and <code>st_type</code> need to be filled in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">stat</td><td>Pointer to a pre-allocated variable the stat data shall be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a21d3579f9fc913f5bf58c5650c3f99b0" name="a21d3579f9fc913f5bf58c5650c3f99b0"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_symlink" class="dashAnchor">&nbsp;</a><a href="#a21d3579f9fc913f5bf58c5650c3f99b0">&#9670;&#160;</a></span>read_symlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::read_symlink) (fs_volume *volume, fs_vnode *<a class="el" href="#ad8b6609f4e2bfdcd3d236af05b567040">link</a>, char *buffer, size_t *_bufferSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the value of a symbolic link. </p>
<p>If the function is successful, the symlink string shall be written to the buffer. It does not need to be null-terminated. If the buffer is too small to hold the complete string, only the first <code>*_bufferSize</code> bytes of the string shall be written to the buffer; the buffer shall not be null-terminated in this case. Furthermore the variable <em>_bufferSize</em> shall be set to the length of the symlink contents, even if the entire contents did not fit in the provided <em>buffer</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">link</td><td>The node object. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a pre-allocated buffer the link value shall be written to. </td></tr>
    <tr><td class="paramname">_bufferSize</td><td>Pointer to a pre-allocated variable containing the size of the buffer supplied to the function. Upon successful completion the hook shall store the length of the symlink contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Everything went fine. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td><em>link</em> does not identify a symbolic link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08e405048c470a1446b842a244f02eb9" name="a08e405048c470a1446b842a244f02eb9"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/remove_attr" class="dashAnchor">&nbsp;</a><a href="#a08e405048c470a1446b842a244f02eb9">&#9670;&#160;</a></span>remove_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::remove_attr) (fs_volume *volume, fs_vnode *vnode, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the attribute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a294304db2b0ca1ef5df39f7efb34616b" name="a294304db2b0ca1ef5df39f7efb34616b"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/remove_dir" class="dashAnchor">&nbsp;</a><a href="#a294304db2b0ca1ef5df39f7efb34616b">&#9670;&#160;</a></span>remove_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::remove_dir) (fs_volume *volume, fs_vnode *parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a directory. </p>
<p>The function shall fail, if the entry does not refer to a directory, or if it refers to a directory that is not empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">parent</td><td>The node object for the parent directory containing the directory to be removed. </td></tr>
    <tr><td class="paramname">name</td><td>The <em>name</em> of the directory that needs to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Operation succeeded. </td></tr>
    <tr><td class="paramname">B_ENTRY_NOT_FOUND</td><td>There is no entry with this <em>name</em>. </td></tr>
    <tr><td class="paramname">B_NOT_A_DIRECTORY</td><td>The entry is not a directory. </td></tr>
    <tr><td class="paramname">B_DIRECTORY_NOT_EMPTY</td><td>The directory is not empty. The virtual file system expects directories to be emptied before they can be removed. </td></tr>
    <tr><td class="paramname">other errors</td><td>Other errors occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b85433ea7269cfdfe13a6d2fcd17733" name="a8b85433ea7269cfdfe13a6d2fcd17733"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/remove_vnode" class="dashAnchor">&nbsp;</a><a href="#a8b85433ea7269cfdfe13a6d2fcd17733">&#9670;&#160;</a></span>remove_vnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::remove_vnode) (fs_volume *volume, fs_vnode *vnode, bool reenter)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the private data handle associated with the specified node. </p>
<p>Invoked by the VFS when it deletes the vnode for the respective node and the node has been marked removed by a call to <a class="el" href="#a8b85433ea7269cfdfe13a6d2fcd17733" title="Deletes the private data handle associated with the specified node.">remove_vnode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">reenter</td><td><code>true</code> if the hook invocation has been caused by the FS itself, e.g. by invoking <a class="el" href="#ad230d461e05b460a42fb89aeab816d39" title="Deletes the private data handle associated with the specified node.">put_vnode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a87a4d2b7c43c13b599fe1aeb48e3f3a1" name="a87a4d2b7c43c13b599fe1aeb48e3f3a1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/rename" class="dashAnchor">&nbsp;</a><a href="#a87a4d2b7c43c13b599fe1aeb48e3f3a1">&#9670;&#160;</a></span>rename</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::rename) (fs_volume *volume, fs_vnode *fromDir, const char *fromName, fs_vnode *toDir, const char *toName)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename and/or relocate an entry. </p>
<p>The virtual file system merely relays the request, so make sure the user is not changing the file name to something like '.', '..' or anything starting with '/'.</p>
<p>This also means that it if the entry refers to a directory, that it should not be moved into one of its own children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">fromDir</td><td>The node object for the parent directory the entry should be moved from. </td></tr>
    <tr><td class="paramname">fromName</td><td>The old entry name. </td></tr>
    <tr><td class="paramname">toDir</td><td>The node object for the parent directory the entry should be moved to. </td></tr>
    <tr><td class="paramname">toName</td><td>The new entry name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The renaming and relocating succeeded. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>One of the supplied parameters were invalid. </td></tr>
    <tr><td class="paramname">B_NOT_ALLOWED</td><td>The user does not have the proper permissions. </td></tr>
    <tr><td class="paramname">other errors</td><td>Another error condition was encountered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20b86590c425849a43953c790f84dde9" name="a20b86590c425849a43953c790f84dde9"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/rename_attr" class="dashAnchor">&nbsp;</a><a href="#a20b86590c425849a43953c790f84dde9">&#9670;&#160;</a></span>rename_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::rename_attr) (fs_volume *volume, fs_vnode *fromVnode, const char *fromName, fs_vnode *toVnode, const char *toName)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename and/or relocate an attribute. </p>
<p>Currently there's no userland or kernel API moving an attribute from one node to another. So this hook is to allowed to only support the case where <em>fromVnode</em> and <em>toVnode</em> are equal and fail otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">fromVnode</td><td>The node object for the vnode the attribute currently belongs to. </td></tr>
    <tr><td class="paramname">fromName</td><td>The old name of the attribute. </td></tr>
    <tr><td class="paramname">toVnode</td><td>The node object for the vnode the attribute should be moved to. This can be the same as <em>fromVnode</em>, in which case it only means the attribute should be renamed. </td></tr>
    <tr><td class="paramname">toName</td><td>The new name of the attribute. This can be the same as <em>fromName</em>, in which case it only means the attribute should be relocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The renaming and/or relocating succeeded. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>One of the supplied parameters were invalid. </td></tr>
    <tr><td class="paramname">B_NOT_ALLOWED</td><td>The user does not have the proper permissions. </td></tr>
    <tr><td class="paramname">other errors</td><td>Another error condition was encountered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0fc1db89cf969429d879a28c61aa413" name="ab0fc1db89cf969429d879a28c61aa413"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/rewind_attr_dir" class="dashAnchor">&nbsp;</a><a href="#ab0fc1db89cf969429d879a28c61aa413">&#9670;&#160;</a></span>rewind_attr_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::rewind_attr_dir) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewind the attribute directory iterator to the first entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie associated with this 'directory'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="acddacf6e778fed957f50a2e4964b82fe" name="acddacf6e778fed957f50a2e4964b82fe"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/rewind_dir" class="dashAnchor">&nbsp;</a><a href="#acddacf6e778fed957f50a2e4964b82fe">&#9670;&#160;</a></span>rewind_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::rewind_dir) (fs_volume *volume, fs_vnode *vnode, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the directory cookie to the first entry of the directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The directory cookie as returned by <a class="el" href="#a254b8384dfb4d16de0dfc0c339acc09d" title="Opens the given directory node.">open_dir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a5fc0377c3b870447b86b362ded75a5db" name="a5fc0377c3b870447b86b362ded75a5db"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/select" class="dashAnchor">&nbsp;</a><a href="#a5fc0377c3b870447b86b362ded75a5db">&#9670;&#160;</a></span>select</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::select) (fs_volume *volume, fs_vnode *vnode, void *cookie, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> event, selectsync *sync)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the specified <em>vnode</em> with the specified <em>events</em>. </p>
<p>This function is called by the VFS whenever <a class="el" href="#a5fc0377c3b870447b86b362ded75a5db" title="Selects the specified vnode with the specified events.">select()</a> or poll() is called on a file descriptor that points to your file system.</p>
<p>You have to check if the condition of the <a class="el" href="#a5fc0377c3b870447b86b362ded75a5db" title="Selects the specified vnode with the specified events.">select()</a> (ie. if there is data available if event is B_SELECT_READ) is already satisfied, and call notify_select_event() with the <em>sync</em> and <em>ref</em> arguments you retrieve here.</p>
<p>Additionally, when a vnode is selected this way, you have to call notify_select_event() whenever the condition becomes true until the vnode is deselected again via file_system_module_info::deselect().</p>
<p>This function is optional. If you don't export it, the default implementation in the VFS will call notify_select_event() directly which will be sufficient for most file systems.</p>
<p>Note that while <a class="el" href="#a5fc0377c3b870447b86b362ded75a5db" title="Selects the specified vnode with the specified events.">select()</a> and the corresponding <a class="el" href="#ae727de6c87d28174caa0086c7d68f461" title="Deselects the specified vnode from a previous select() call.">deselect()</a> are invoked by the same thread, notifications are usually generated by other threads. It is your responsibility to make sure that notify_select_event() is never called for a selectsync object for which <a class="el" href="#ae727de6c87d28174caa0086c7d68f461" title="Deselects the specified vnode from a previous select() call.">deselect()</a> has already returned. This is commonly done by holding the same lock when invoking notify_select_event() and when removing the selectsync object from the cookie in <a class="el" href="#ae727de6c87d28174caa0086c7d68f461" title="Deselects the specified vnode from a previous select() call.">deselect()</a>. Such a lock can be any lock, usually one that is associated with the node or the volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The file system provided cookie associated with the opened file. </td></tr>
    <tr><td class="paramname">event</td><td>The event to be selected. One of:<ul>
<li><code>B_SELECT_READ:</code> File ready for reading.</li>
<li><code>B_SELECT_WRITE:</code> File ready for writing.</li>
<li><code>B_SELECT_ERROR:</code> I/O error condition.</li>
<li><code>B_SELECT_PRI_READ:</code> File ready for priority read.</li>
<li><code>B_SELECT_PRI_WRITE:</code> File ready for priority write.</li>
<li><code>B_SELECT_HIGH_PRI_READ:</code> File ready for high priority read.</li>
<li><code>B_SELECT_HIGH_PRI_WRITE:</code> File ready for high priority write.</li>
<li><code>B_SELECT_DISCONNECTED:</code> Socket/FIFO/... has been disconnected. </li>
</ul>
</td></tr>
    <tr><td class="paramname">sync</td><td>Opaque pointer to be passed to notify_select_event(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if the operation succeeded, or else an error code. </dd></dl>

</div>
</div>
<a id="a698091aebd4ae2ead026bc8cfa98f03a" name="a698091aebd4ae2ead026bc8cfa98f03a"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/set_flags" class="dashAnchor">&nbsp;</a><a href="#a698091aebd4ae2ead026bc8cfa98f03a">&#9670;&#160;</a></span>set_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::set_flags) (fs_volume *volume, fs_vnode *vnode, void *cookie, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the open mode flags for an opened file. </p>
<p>This function should change the open flags for an opened file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The file system provided cookie associated with the opened file. </td></tr>
    <tr><td class="paramname">flags</td><td>The new flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if the operation succeeded, or else an error code. </dd></dl>

</div>
</div>
<a id="a307d6e1fe8617538909f98be9c8f073c" name="a307d6e1fe8617538909f98be9c8f073c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/unlink" class="dashAnchor">&nbsp;</a><a href="#a307d6e1fe8617538909f98be9c8f073c">&#9670;&#160;</a></span>unlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::unlink) (fs_volume *volume, fs_vnode *dir, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a non-directory entry. </p>
<p>Remove an entry that does refer to a non-directory node. For removing directories the <a class="el" href="#a294304db2b0ca1ef5df39f7efb34616b" title="Remove a directory.">remove_dir()</a> hook is used. If invoked on a directory, this hook shall fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">dir</td><td>The node object for the directory containing the entry to be removed. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the entry that should be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Removal succeeded. </td></tr>
    <tr><td class="paramname">B_ENTRY_NOT_FOUND</td><td>The entry does not exist. </td></tr>
    <tr><td class="paramname">B_NOT_ALLOWED</td><td>The user does not have the proper permissions. </td></tr>
    <tr><td class="paramname">B_IS_A_DIRECTORY</td><td>The entry refers to a directory. </td></tr>
    <tr><td class="paramname">other errors</td><td>Another error occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30cb4e8381ea0fe3b01b91e508d5efed" name="a30cb4e8381ea0fe3b01b91e508d5efed"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/write" class="dashAnchor">&nbsp;</a><a href="#a30cb4e8381ea0fe3b01b91e508d5efed">&#9670;&#160;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::write) (fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to a file. </p>
<p>This function should fail if</p><ul>
<li>the node is not a file,</li>
<li>the cookie has not been opened for writing,</li>
<li><em>pos</em> is negative, or</li>
<li>some other error occurs while trying to write the data, and no data have been written at all.</li>
</ul>
<p>The number of bytes to be written is stored in the variable pointed to by <em>length</em>. If not all bytes could be written, that variable must be updated to reflect the amount of actually written bytes. If any bytes have been written, the function shall not fail, if an error prevents you from writing the full amount. Only when the error prevented you from writing any data at all an error shall be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The file system provided cookie associated with the file. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to start writing. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer that contains the data that will need to be written. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data that needs to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a5e344c86fc5d2cc525bd12a57a1e07d7" name="a5e344c86fc5d2cc525bd12a57a1e07d7"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/write_attr" class="dashAnchor">&nbsp;</a><a href="#a5e344c86fc5d2cc525bd12a57a1e07d7">&#9670;&#160;</a></span>write_attr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::write_attr) (fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const void *buffer, size_t *length)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write attribute data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie you associated with this attribute. </td></tr>
    <tr><td class="paramname">pos</td><td>The position to start writing to. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer the data should be copied from. </td></tr>
    <tr><td class="paramname">length</td><td>The size of the buffer. Update this variable to the actual amount of bytes written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a9488dfef299234a99c8f86c6cf905e6e" name="a9488dfef299234a99c8f86c6cf905e6e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/write_attr_stat" class="dashAnchor">&nbsp;</a><a href="#a9488dfef299234a99c8f86c6cf905e6e">&#9670;&#160;</a></span>write_attr_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::write_attr_stat) (fs_volume *volume, fs_vnode *vnode, void *cookie, const struct stat *stat, int statMask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the stats of an attribute. </p>
<p>Currently on the attribute size (B_STAT_SIZE) can be set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie you associated with this attribute. </td></tr>
    <tr><td class="paramname">stat</td><td>A pointer to the new stats you should write. </td></tr>
    <tr><td class="paramname">statMask</td><td>One or more of the values of write_stat_mask that tell you which fields of <em>stat</em> are to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="ab67535c8aba96beb607e3fced9e513b3" name="ab67535c8aba96beb607e3fced9e513b3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/write_pages" class="dashAnchor">&nbsp;</a><a href="#ab67535c8aba96beb607e3fced9e513b3">&#9670;&#160;</a></span>write_pages</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::write_pages) (fs_volume *volume, fs_vnode *vnode, void *cookie, off_t pos, const iovec *vecs, size_t count, size_t *_numBytes)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deprecated. </p>

</div>
</div>
<a id="a8094be85bc8ad80b707ea2661be0ad75" name="a8094be85bc8ad80b707ea2661be0ad75"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/write_stat" class="dashAnchor">&nbsp;</a><a href="#a8094be85bc8ad80b707ea2661be0ad75">&#9670;&#160;</a></span>write_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_vnode_ops::write_stat) (fs_volume *volume, fs_vnode *vnode, const struct stat *stat, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> statMask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the stats for a vnode. </p>
<p>You should make sure that the new values are valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
    <tr><td class="paramname">stat</td><td>The structure with the updated values. </td></tr>
    <tr><td class="paramname">statMask</td><td>A bitwise combination of one or more of the following, specifying which stat field shall be set:<ul>
<li>B_STAT_MODE: Set the node permissions.</li>
<li>B_STAT_UID: Set the owning user.</li>
<li>B_STAT_GID: Set the owner group.</li>
<li>B_STAT_SIZE: Set the size of the file. If enlarged, the file is padded. Normally with zero bytes, but with unspecified data, if B_STAT_SIZE_INSECURE is specified, too.</li>
<li>B_STAT_SIZE_INSECURE: Modifier for B_STAT_SIZE: When enlarging the file padding can be done with arbitrary data.</li>
<li>B_STAT_ACCESS_TIME: Set the access time.</li>
<li>B_STAT_MODIFICATION_TIME: Set the modification time.</li>
<li>B_STAT_CREATION_TIME: Set the creation time.</li>
<li>B_STAT_CHANGE_TIME: Set the change time. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The update succeeded. </td></tr>
    <tr><td class="paramname">B_NOT_ALLOWED</td><td>The user does not have the proper permissions. </td></tr>
    <tr><td class="paramname">other errors</td><td>Another error condition occured. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - fs_vnode_ops Struct Reference<br />
    Generated on Sat May 24 2025 23:12:20 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
