<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: fs_interface.h File Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7f57b1e41c5acd0e859ae5f3a2b075a9.html">headers</a></li><li class="navelem"><a class="el" href="dir_4b32c6481442aa9b3580ee2f870fac49.html">os</a></li><li class="navelem"><a class="el" href="dir_fed1e4a943141a8b219d7f5b50af92fe.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a>  </div>
  <div class="headertitle"><div class="title">fs_interface.h File Reference<div class="ingroups"><a class="el" href="group__drivers.html">Device Drivers</a> &#124; <a class="el" href="group__libbe.html">(libbe.so)</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Provides an interface for file system modules.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfile__io__vec.html">file_io_vec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that describes the io vector of a file.  <a href="structfile__io__vec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfile__system__module__info.html">file_system_module_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kernel module interface for file systems.  <a href="structfile__system__module__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__vnode__ops.html">fs_vnode_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations vector for a node.  <a href="structfs__vnode__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfs__volume__ops.html">fs_volume_ops</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations vector for a volume.  <a href="structfs__volume__ops.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4f115056276b788779b132a0d1c49552" id="r_a4f115056276b788779b132a0d1c49552"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f115056276b788779b132a0d1c49552">B_CURRENT_FS_API_VERSION</a>&#160;&#160;&#160;&quot;/v1&quot;</td></tr>
<tr class="memdesc:a4f115056276b788779b132a0d1c49552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant that defines the version of the file system API that your filesystem conforms to.  <br /></td></tr>
<tr class="separator:a4f115056276b788779b132a0d1c49552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800173ac56b996daa8342275580ede4e" id="r_a800173ac56b996daa8342275580ede4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a800173ac56b996daa8342275580ede4e">B_STAT_SIZE_INSECURE</a>&#160;&#160;&#160;0x2000</td></tr>
<tr class="memdesc:a800173ac56b996daa8342275580ede4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for the <a class="el" href="structfs__vnode__ops.html#a8094be85bc8ad80b707ea2661be0ad75" title="Update the stats for a vnode.">fs_vnode_ops::write_stat</a> hook indicating that the FS is allowed not to clear the additional space when enlarging a file.  <br /></td></tr>
<tr class="separator:a800173ac56b996daa8342275580ede4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e0ef67185a13e5b331b6617e4b62ee" id="r_ad5e0ef67185a13e5b331b6617e4b62ee"><td class="memItemLeft" align="right" valign="top"><a id="ad5e0ef67185a13e5b331b6617e4b62ee" name="ad5e0ef67185a13e5b331b6617e4b62ee"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE</b>&#160;&#160;&#160;0x02</td></tr>
<tr class="memdesc:ad5e0ef67185a13e5b331b6617e4b62ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a> and <a class="el" href="structfs__volume__ops.html#ae19ba0ea8ab896e6981ae95016fead91" title="Creates the private data handle to be associated with the node referred to by id.">fs_volume_ops::get_vnode()</a> indicating that no subnodes shall be created for the node to publish the node shall be published. <br /></td></tr>
<tr class="separator:ad5e0ef67185a13e5b331b6617e4b62ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018714b14875381dd91b22043b77956" id="r_ac018714b14875381dd91b22043b77956"><td class="memItemLeft" align="right" valign="top"><a id="ac018714b14875381dd91b22043b77956" name="ac018714b14875381dd91b22043b77956"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>B_VNODE_PUBLISH_REMOVED</b>&#160;&#160;&#160;0x01</td></tr>
<tr class="memdesc:ac018714b14875381dd91b22043b77956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a> and <a class="el" href="structfs__vnode__ops.html#a1b6d9a5caef702b80469873c37088a3a" title="TODO: Document!">fs_vnode_ops::create_special_node()</a> indicating that the node shall be published in removed state (i.e. no entry refers to it). <br /></td></tr>
<tr class="separator:ac018714b14875381dd91b22043b77956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9012b3a1bb132315edd234e68b97df2c" id="r_a9012b3a1bb132315edd234e68b97df2c"><td class="memItemLeft" align="right" valign="top"><a id="a9012b3a1bb132315edd234e68b97df2c" name="a9012b3a1bb132315edd234e68b97df2c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>FS_WRITE_FSINFO_NAME</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:a9012b3a1bb132315edd234e68b97df2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to <a class="el" href="structfs__volume__ops.html#adb4c9bcd3811563b84e187fc47b9518e" title="Update filesystem information on the volume.">fs_volume_ops::write_fs_info()</a> to indicate that the name of the volume shall be changed. <br /></td></tr>
<tr class="separator:a9012b3a1bb132315edd234e68b97df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Vnode functions</div></td></tr>
<tr class="memitem:ac7652dbe421f4e6a26003bd826035457" id="r_ac7652dbe421f4e6a26003bd826035457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7652dbe421f4e6a26003bd826035457">acquire_vnode</a> (fs_volume *volume, ino_t vnodeID)</td></tr>
<tr class="memdesc:ac7652dbe421f4e6a26003bd826035457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires another reference to a vnode.  <br /></td></tr>
<tr class="separator:ac7652dbe421f4e6a26003bd826035457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfcf01bba17eee0ad3f84115051b281" id="r_a2cfcf01bba17eee0ad3f84115051b281"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cfcf01bba17eee0ad3f84115051b281">get_vnode</a> (fs_volume *volume, ino_t vnodeID, void **_privateNode)</td></tr>
<tr class="memdesc:a2cfcf01bba17eee0ad3f84115051b281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the private data handle for the node with the given ID.  <br /></td></tr>
<tr class="separator:a2cfcf01bba17eee0ad3f84115051b281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71887f0959b9189c84e341a68abc6691" id="r_a71887f0959b9189c84e341a68abc6691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71887f0959b9189c84e341a68abc6691">get_vnode_removed</a> (fs_volume *volume, ino_t vnodeID, bool *_removed)</td></tr>
<tr class="memdesc:a71887f0959b9189c84e341a68abc6691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the specified vnode is marked removed.  <br /></td></tr>
<tr class="separator:a71887f0959b9189c84e341a68abc6691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4321ef6888f1fb8606882b5719a562" id="r_a3d4321ef6888f1fb8606882b5719a562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d4321ef6888f1fb8606882b5719a562">new_vnode</a> (fs_volume *volume, ino_t vnodeID, void *privateNode, <a class="el" href="structfs__vnode__ops.html">fs_vnode_ops</a> *ops)</td></tr>
<tr class="memdesc:a3d4321ef6888f1fb8606882b5719a562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the vnode with ID <em>vnodeID</em> and associates it with the private data handle <em>privateNode</em>, but leaves is in an unpublished state.  <br /></td></tr>
<tr class="separator:a3d4321ef6888f1fb8606882b5719a562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ca7437ee63b0b91ade75d2d0a24413" id="r_a72ca7437ee63b0b91ade75d2d0a24413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413">publish_vnode</a> (fs_volume *volume, ino_t vnodeID, void *privateNode, <a class="el" href="structfs__vnode__ops.html">fs_vnode_ops</a> *ops, int type, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:a72ca7437ee63b0b91ade75d2d0a24413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vnode with ID <em>vnodeID</em> and associates it with the private data handle <em>privateNode</em> or just marks it published.  <br /></td></tr>
<tr class="separator:a72ca7437ee63b0b91ade75d2d0a24413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3e130d24090e360ed261d7e189df37" id="r_aca3e130d24090e360ed261d7e189df37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca3e130d24090e360ed261d7e189df37">put_vnode</a> (fs_volume *volume, ino_t vnodeID)</td></tr>
<tr class="memdesc:aca3e130d24090e360ed261d7e189df37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Surrenders a reference to the specified vnode.  <br /></td></tr>
<tr class="separator:aca3e130d24090e360ed261d7e189df37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852e2bafd586717ac447c116774373e1" id="r_a852e2bafd586717ac447c116774373e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a852e2bafd586717ac447c116774373e1">remove_vnode</a> (fs_volume *volume, ino_t vnodeID)</td></tr>
<tr class="memdesc:a852e2bafd586717ac447c116774373e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks the specified vnode removed.  <br /></td></tr>
<tr class="separator:a852e2bafd586717ac447c116774373e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec07c2d99d38d82396919cbee1ec866c" id="r_aec07c2d99d38d82396919cbee1ec866c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec07c2d99d38d82396919cbee1ec866c">unremove_vnode</a> (fs_volume *volume, ino_t vnodeID)</td></tr>
<tr class="memdesc:aec07c2d99d38d82396919cbee1ec866c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the "removed" mark of the specified vnode.  <br /></td></tr>
<tr class="separator:aec07c2d99d38d82396919cbee1ec866c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4300c35159a64e7199f1998a37fbbc03" id="r_a4300c35159a64e7199f1998a37fbbc03"><td class="memItemLeft" align="right" valign="top">fs_volume *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4300c35159a64e7199f1998a37fbbc03">volume_for_vnode</a> (fs_vnode *vnode)</td></tr>
<tr class="memdesc:a4300c35159a64e7199f1998a37fbbc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the volume object for a given vnode.  <br /></td></tr>
<tr class="separator:a4300c35159a64e7199f1998a37fbbc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Notification Functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The following functions are used to implement the node monitor functionality in your file system. Whenever one of the below mentioned events occur, you have to call them.</p>
<p>The node monitor will then notify all registered listeners for the nodes that changed. </p>
</div></td></tr>
<tr class="memitem:ab3b03ad1ba412bb75cdae495f282425c" id="r_ab3b03ad1ba412bb75cdae495f282425c"><td class="memItemLeft" align="right" valign="top"><a id="ab3b03ad1ba412bb75cdae495f282425c" name="ab3b03ad1ba412bb75cdae495f282425c"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_attribute_changed</b> (dev_t device, ino_t directory, ino_t node, const char *attribute, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> cause)</td></tr>
<tr class="memdesc:ab3b03ad1ba412bb75cdae495f282425c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that an attribute of a node has been changed. <br /></td></tr>
<tr class="separator:ab3b03ad1ba412bb75cdae495f282425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cd489f984ce5fc12a8ecbc7f6751e8" id="r_a55cd489f984ce5fc12a8ecbc7f6751e8"><td class="memItemLeft" align="right" valign="top"><a id="a55cd489f984ce5fc12a8ecbc7f6751e8" name="a55cd489f984ce5fc12a8ecbc7f6751e8"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_entry_created</b> (dev_t device, ino_t directory, const char *name, ino_t node)</td></tr>
<tr class="memdesc:a55cd489f984ce5fc12a8ecbc7f6751e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that a file system entry has been created. <br /></td></tr>
<tr class="separator:a55cd489f984ce5fc12a8ecbc7f6751e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470097f27af472b8d39f30c58b8fab0f" id="r_a470097f27af472b8d39f30c58b8fab0f"><td class="memItemLeft" align="right" valign="top"><a id="a470097f27af472b8d39f30c58b8fab0f" name="a470097f27af472b8d39f30c58b8fab0f"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_entry_moved</b> (dev_t device, ino_t fromDirectory, const char *fromName, ino_t toDirectory, const char *toName, ino_t node)</td></tr>
<tr class="memdesc:a470097f27af472b8d39f30c58b8fab0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that a file system entry has been renamed and/or moved to another directory. <br /></td></tr>
<tr class="separator:a470097f27af472b8d39f30c58b8fab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3baac1c403f1ecff4ad83db13a72eefa" id="r_a3baac1c403f1ecff4ad83db13a72eefa"><td class="memItemLeft" align="right" valign="top"><a id="a3baac1c403f1ecff4ad83db13a72eefa" name="a3baac1c403f1ecff4ad83db13a72eefa"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_entry_removed</b> (dev_t device, ino_t directory, const char *name, ino_t node)</td></tr>
<tr class="memdesc:a3baac1c403f1ecff4ad83db13a72eefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that a file system entry has been removed. <br /></td></tr>
<tr class="separator:a3baac1c403f1ecff4ad83db13a72eefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9de58136e078f3b99430a07b5e096e" id="r_a4a9de58136e078f3b99430a07b5e096e"><td class="memItemLeft" align="right" valign="top"><a id="a4a9de58136e078f3b99430a07b5e096e" name="a4a9de58136e078f3b99430a07b5e096e"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_query_entry_created</b> (port_id port, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> token, dev_t device, ino_t directory, const char *name, ino_t node)</td></tr>
<tr class="memdesc:a4a9de58136e078f3b99430a07b5e096e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that an entry has entered the result set of a live query. <br /></td></tr>
<tr class="separator:a4a9de58136e078f3b99430a07b5e096e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65efb61891fd7f412b7a06401f0e8e1a" id="r_a65efb61891fd7f412b7a06401f0e8e1a"><td class="memItemLeft" align="right" valign="top"><a id="a65efb61891fd7f412b7a06401f0e8e1a" name="a65efb61891fd7f412b7a06401f0e8e1a"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_query_entry_removed</b> (port_id port, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> token, dev_t device, ino_t directory, const char *name, ino_t node)</td></tr>
<tr class="memdesc:a65efb61891fd7f412b7a06401f0e8e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that an entry has left the result set of a live query. <br /></td></tr>
<tr class="separator:a65efb61891fd7f412b7a06401f0e8e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46396596f5c06ecd4247a909edee103" id="r_ac46396596f5c06ecd4247a909edee103"><td class="memItemLeft" align="right" valign="top"><a id="ac46396596f5c06ecd4247a909edee103" name="ac46396596f5c06ecd4247a909edee103"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notify_stat_changed</b> (dev_t device, ino_t directory, ino_t node, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> statFields)</td></tr>
<tr class="memdesc:ac46396596f5c06ecd4247a909edee103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies listeners that certain <em>statFields</em> of a node were updated. <br /></td></tr>
<tr class="separator:ac46396596f5c06ecd4247a909edee103"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides an interface for file system modules. </p>
<p>See the <a class="el" href="fs_modules.html">introduction to file system modules</a> for a guide on how to get started with writing file system modules. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a4f115056276b788779b132a0d1c49552" name="a4f115056276b788779b132a0d1c49552"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Macro/B_CURRENT_FS_API_VERSION" class="dashAnchor">&nbsp;</a><a href="#a4f115056276b788779b132a0d1c49552">&#9670;&#160;</a></span>B_CURRENT_FS_API_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define B_CURRENT_FS_API_VERSION&#160;&#160;&#160;&quot;/v1&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constant that defines the version of the file system API that your filesystem conforms to. </p>
<p>The module name that exports the interface to your file system has to end with this constant as in: </p><div class="fragment"><div class="line"><span class="stringliteral">&quot;file_systems/myfs&quot;</span> <a class="code hl_define" href="#a4f115056276b788779b132a0d1c49552">B_CURRENT_FS_API_VERSION</a> </div>
<div class="ttc" id="afs__interface_8h_html_a4f115056276b788779b132a0d1c49552"><div class="ttname"><a name="//apple_ref/cpp/Macro/B_CURRENT_FS_API_VERSION" class="dashAnchor">&nbsp;</a><a href="#a4f115056276b788779b132a0d1c49552">B_CURRENT_FS_API_VERSION</a></div><div class="ttdeci">#define B_CURRENT_FS_API_VERSION</div><div class="ttdoc">Constant that defines the version of the file system API that your filesystem conforms to.</div><div class="ttdef"><b>Definition</b> fs_interface.h:42</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a800173ac56b996daa8342275580ede4e" name="a800173ac56b996daa8342275580ede4e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Macro/B_STAT_SIZE_INSECURE" class="dashAnchor">&nbsp;</a><a href="#a800173ac56b996daa8342275580ede4e">&#9670;&#160;</a></span>B_STAT_SIZE_INSECURE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define B_STAT_SIZE_INSECURE&#160;&#160;&#160;0x2000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag for the <a class="el" href="structfs__vnode__ops.html#a8094be85bc8ad80b707ea2661be0ad75" title="Update the stats for a vnode.">fs_vnode_ops::write_stat</a> hook indicating that the FS is allowed not to clear the additional space when enlarging a file. </p>
<p>This flag was added because BFS doesn't support sparse files. It will be phased out, when it does. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac7652dbe421f4e6a26003bd826035457" name="ac7652dbe421f4e6a26003bd826035457"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/acquire_vnode" class="dashAnchor">&nbsp;</a><a href="#ac7652dbe421f4e6a26003bd826035457">&#9670;&#160;</a></span>acquire_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> acquire_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquires another reference to a vnode. </p>
<p>Similar to <a class="el" href="#a2cfcf01bba17eee0ad3f84115051b281" title="Retrieves the private data handle for the node with the given ID.">get_vnode()</a> in that the function acquires a vnode reference. Unlike <a class="el" href="#a2cfcf01bba17eee0ad3f84115051b281" title="Retrieves the private data handle for the node with the given ID.">get_vnode()</a> this function can also be invoked between <a class="el" href="#a3d4321ef6888f1fb8606882b5719a562" title="Create the vnode with ID vnodeID and associates it with the private data handle privateNode,...">new_vnode()</a> and <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a2cfcf01bba17eee0ad3f84115051b281" name="a2cfcf01bba17eee0ad3f84115051b281"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/get_vnode" class="dashAnchor">&nbsp;</a><a href="#a2cfcf01bba17eee0ad3f84115051b281">&#9670;&#160;</a></span>get_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> get_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>_privateNode</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the private data handle for the node with the given ID. </p>
<p>If the function is successful, the caller owns a reference to the vnode. The reference can be surrendered by calling <a class="el" href="#aca3e130d24090e360ed261d7e189df37" title="Surrenders a reference to the specified vnode.">put_vnode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
    <tr><td class="paramname">_privateNode</td><td>Pointer to a pre-allocated variable the private data handle shall be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a71887f0959b9189c84e341a68abc6691" name="a71887f0959b9189c84e341a68abc6691"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/get_vnode_removed" class="dashAnchor">&nbsp;</a><a href="#a71887f0959b9189c84e341a68abc6691">&#9670;&#160;</a></span>get_vnode_removed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> get_vnode_removed </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>_removed</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether the specified vnode is marked removed. </p>
<p>The caller must own a reference to the vnode or at least ensure that a reference to the vnode exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
    <tr><td class="paramname">_removed</td><td>Pointer to a pre-allocated variable set to <code>true</code>, if the node is marked removed, to <code>false</code> otherwise. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a3d4321ef6888f1fb8606882b5719a562" name="a3d4321ef6888f1fb8606882b5719a562"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/new_vnode" class="dashAnchor">&nbsp;</a><a href="#a3d4321ef6888f1fb8606882b5719a562">&#9670;&#160;</a></span>new_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> new_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>privateNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfs__vnode__ops.html">fs_vnode_ops</a> *</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the vnode with ID <em>vnodeID</em> and associates it with the private data handle <em>privateNode</em>, but leaves is in an unpublished state. </p>
<p>The effect of the function is similar to <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a>, but the vnode remains in an unpublished state, with the effect that a subsequent <a class="el" href="#a852e2bafd586717ac447c116774373e1" title="Marks the specified vnode removed.">remove_vnode()</a> will just delete the vnode and not invoke the file system's <a class="el" href="structfs__vnode__ops.html#a8b85433ea7269cfdfe13a6d2fcd17733">remove_vnode() </a> when the final reference is put down.</p>
<p>If the vnode shall be kept, <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a> has to be invoked afterwards to mark the vnode published. The combined effect is the same as only invoking <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a>.</p>
<p>You'll usually use this function to secure a vnode ID from being reused while you are in the process of creating the entry. Note that this function will panic in case you call it for an existing vnode ID.</p>
<p>The function fails, if the vnode does already exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
    <tr><td class="paramname">privateNode</td><td>The private data handle to be associated with the node. </td></tr>
    <tr><td class="paramname">ops</td><td>The operation vector for this vnode. Is not copied and must be valid through the whole life time of the vnode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a72ca7437ee63b0b91ade75d2d0a24413" name="a72ca7437ee63b0b91ade75d2d0a24413"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/publish_vnode" class="dashAnchor">&nbsp;</a><a href="#a72ca7437ee63b0b91ade75d2d0a24413">&#9670;&#160;</a></span>publish_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> publish_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>privateNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfs__vnode__ops.html">fs_vnode_ops</a> *</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vnode with ID <em>vnodeID</em> and associates it with the private data handle <em>privateNode</em> or just marks it published. </p>
<p>If the vnode does already exist and has been published, the function fails. If it has not been published yet (i.e. after a successful <a class="el" href="#a3d4321ef6888f1fb8606882b5719a562" title="Create the vnode with ID vnodeID and associates it with the private data handle privateNode,...">new_vnode()</a>), the function just marks the vnode published. If the vnode did not exist at all before, it is created and published.</p>
<p>If the function is successful, the caller owns a reference to the vnode. A sequence of <a class="el" href="#a3d4321ef6888f1fb8606882b5719a562" title="Create the vnode with ID vnodeID and associates it with the private data handle privateNode,...">new_vnode()</a> and <a class="el" href="#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a> results in just one reference as well. The reference can be surrendered by calling <a class="el" href="#aca3e130d24090e360ed261d7e189df37" title="Surrenders a reference to the specified vnode.">put_vnode()</a>.</p>
<p>If called after a <a class="el" href="#a3d4321ef6888f1fb8606882b5719a562" title="Create the vnode with ID vnodeID and associates it with the private data handle privateNode,...">new_vnode()</a> the <em>privateNode</em> and <em>ops</em> parameters must be the same as previously passed to <a class="el" href="#a3d4321ef6888f1fb8606882b5719a562" title="Create the vnode with ID vnodeID and associates it with the private data handle privateNode,...">new_vnode()</a>.</p>
<p>This call is equivalent to the former BeOS R5 <a class="el" href="#a3d4321ef6888f1fb8606882b5719a562" title="Create the vnode with ID vnodeID and associates it with the private data handle privateNode,...">new_vnode()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
    <tr><td class="paramname">privateNode</td><td>The private data handle to be associated with the node. </td></tr>
    <tr><td class="paramname">ops</td><td>The operation vector for this vnode. Is not copied and must be valid through the whole life time of the vnode. </td></tr>
    <tr><td class="paramname">type</td><td>The type of the node as it would appear in a stat::st_mode (with all non type-related bits set to 0). </td></tr>
    <tr><td class="paramname">flags</td><td>A bitwise combination of none or more of the following:<ul>
<li>B_VNODE_PUBLISH_REMOVED: The node is published in "removed" state, i.e. it has no entry referring to it and releasing the last reference to the vnode will remove it.</li>
<li>B_VNODE_DONT_CREATE_SPECIAL_SUB_NODE: Normally for FIFO or socket type nodes the VFS creates sub node providing the associated functionality. This flag prevents that from happing. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="aca3e130d24090e360ed261d7e189df37" name="aca3e130d24090e360ed261d7e189df37"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/put_vnode" class="dashAnchor">&nbsp;</a><a href="#aca3e130d24090e360ed261d7e189df37">&#9670;&#160;</a></span>put_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> put_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Surrenders a reference to the specified vnode. </p>
<p>When the last reference to the vnode has been put the VFS will call <a class="el" href="structfs__vnode__ops.html#ad230d461e05b460a42fb89aeab816d39" title="Deletes the private data handle associated with the specified node.">fs_vnode_ops::put_vnode()</a> (eventually), respectively, if the node has been marked removed <a class="el" href="structfs__vnode__ops.html#a8b85433ea7269cfdfe13a6d2fcd17733" title="Deletes the private data handle associated with the specified node.">fs_vnode_ops::remove_vnode()</a> (immediately).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a852e2bafd586717ac447c116774373e1" name="a852e2bafd586717ac447c116774373e1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/remove_vnode" class="dashAnchor">&nbsp;</a><a href="#a852e2bafd586717ac447c116774373e1">&#9670;&#160;</a></span>remove_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> remove_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marks the specified vnode removed. </p>
<p>The caller must own a reference to the vnode or at least ensure that a reference to the vnode exists. The function does not surrender a reference, though.</p>
<p>As soon as the last reference to the vnode has been surrendered, the VFS invokes the node's <a class="el" href="structfs__vnode__ops.html#a8b85433ea7269cfdfe13a6d2fcd17733">remove_vnode() </a> hook.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="aec07c2d99d38d82396919cbee1ec866c" name="aec07c2d99d38d82396919cbee1ec866c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/unremove_vnode" class="dashAnchor">&nbsp;</a><a href="#aec07c2d99d38d82396919cbee1ec866c">&#9670;&#160;</a></span>unremove_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> unremove_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_volume *</td>          <td class="paramname"><span class="paramname"><em>volume</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ino_t</td>          <td class="paramname"><span class="paramname"><em>vnodeID</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the "removed" mark of the specified vnode. </p>
<p>The caller must own a reference to the vnode or at least ensure that a reference to the vnode exists.</p>
<p>The function is usually called when the caller, who has invoked <a class="el" href="#a852e2bafd586717ac447c116774373e1" title="Marks the specified vnode removed.">remove_vnode()</a> before realizes that it is not possible to remove the node (e.g. due to an error). Afterwards the vnode will continue to exist as if <a class="el" href="#a852e2bafd586717ac447c116774373e1" title="Marks the specified vnode removed.">remove_vnode()</a> had never been invoked.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">vnodeID</td><td>The ID of the node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a4300c35159a64e7199f1998a37fbbc03" name="a4300c35159a64e7199f1998a37fbbc03"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/volume_for_vnode" class="dashAnchor">&nbsp;</a><a href="#a4300c35159a64e7199f1998a37fbbc03">&#9670;&#160;</a></span>volume_for_vnode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fs_volume * volume_for_vnode </td>
          <td>(</td>
          <td class="paramtype">fs_vnode *</td>          <td class="paramname"><span class="paramname"><em>vnode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the volume object for a given vnode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vnode</td><td>The node object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The volume object for the given vnode. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - fs_interface.h File Reference<br />
    Generated on Sat May 24 2025 23:12:16 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
