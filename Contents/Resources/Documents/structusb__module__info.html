<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: usb_module_info Struct Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structusb__module__info-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">usb_module_info Struct Reference<div class="ingroups"><a class="el" href="group__drivers.html">Device Drivers</a> &#124; <a class="el" href="group__libbe.html">(libbe.so)</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Interface for drivers to interact with Haiku's USB stack.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9a6e20e72f384b80cdbc59fa898e7bf6" id="r_a9a6e20e72f384b80cdbc59fa898e7bf6"><td class="memItemLeft" align="right" valign="top"><a id="a9a6e20e72f384b80cdbc59fa898e7bf6" name="a9a6e20e72f384b80cdbc59fa898e7bf6"></a>
bus_manager_info&#160;</td><td class="memItemRight" valign="bottom"><b>binfo</b></td></tr>
<tr class="memdesc:a9a6e20e72f384b80cdbc59fa898e7bf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of the bus_manager_info object. <br /></td></tr>
<tr class="separator:a9a6e20e72f384b80cdbc59fa898e7bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe38fcd6924611608d8958c6814f93e" id="r_a3fe38fcd6924611608d8958c6814f93e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fe38fcd6924611608d8958c6814f93e">cancel_queued_transfers</a> )(<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe)</td></tr>
<tr class="memdesc:a3fe38fcd6924611608d8958c6814f93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel pending transfers on a pipe. All the pending transfers will be cancelled. The stack will perform the callback on all of them that are cancelled.  <br /></td></tr>
<tr class="separator:a3fe38fcd6924611608d8958c6814f93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae498a5af2db4b12c4a767622dff6447a" id="r_ae498a5af2db4b12c4a767622dff6447a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae498a5af2db4b12c4a767622dff6447a">clear_feature</a> )(<a class="el" href="USB3_8h.html#a4e263eb58c2c2f566e9bbe756b8a87a7">usb_id</a> handle, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> selector)</td></tr>
<tr class="memdesc:ae498a5af2db4b12c4a767622dff6447a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for standard control pipe clear feature requests.  <br /></td></tr>
<tr class="separator:ae498a5af2db4b12c4a767622dff6447a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ab7fa09cd4df2193bc00660823acdc" id="r_ab1ab7fa09cd4df2193bc00660823acdc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structusb__configuration__info.html">usb_configuration_info</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1ab7fa09cd4df2193bc00660823acdc">get_configuration</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device)</td></tr>
<tr class="memdesc:ab1ab7fa09cd4df2193bc00660823acdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current configuration.  <br /></td></tr>
<tr class="separator:ab1ab7fa09cd4df2193bc00660823acdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e01c2d5f14903e3ffbada712058adc5" id="r_a3e01c2d5f14903e3ffbada712058adc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e01c2d5f14903e3ffbada712058adc5">get_descriptor</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> descriptorType, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> index, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> languageID, void *data, size_t dataLength, size_t *actualLength)</td></tr>
<tr class="memdesc:a3e01c2d5f14903e3ffbada712058adc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to get a descriptor from a device.  <br /></td></tr>
<tr class="separator:a3e01c2d5f14903e3ffbada712058adc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e309e0f458ffa63dd728ad4672f22c" id="r_a87e309e0f458ffa63dd728ad4672f22c"><td class="memItemLeft" align="right" valign="top">const usb_device_descriptor *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87e309e0f458ffa63dd728ad4672f22c">get_device_descriptor</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device)</td></tr>
<tr class="memdesc:a87e309e0f458ffa63dd728ad4672f22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device descriptor.  <br /></td></tr>
<tr class="separator:a87e309e0f458ffa63dd728ad4672f22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61359a9b1bbd9ef858fdc2a1b40db120" id="r_a61359a9b1bbd9ef858fdc2a1b40db120"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structusb__configuration__info.html">usb_configuration_info</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61359a9b1bbd9ef858fdc2a1b40db120">get_nth_configuration</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> index)</td></tr>
<tr class="memdesc:a61359a9b1bbd9ef858fdc2a1b40db120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a configuration descriptor by index.  <br /></td></tr>
<tr class="separator:a61359a9b1bbd9ef858fdc2a1b40db120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318e853caf08181ebce8a289b835bd8c" id="r_a318e853caf08181ebce8a289b835bd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a318e853caf08181ebce8a289b835bd8c">get_status</a> )(<a class="el" href="USB3_8h.html#a4e263eb58c2c2f566e9bbe756b8a87a7">usb_id</a> handle, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> *status)</td></tr>
<tr class="memdesc:a318e853caf08181ebce8a289b835bd8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for standard usb status requests.  <br /></td></tr>
<tr class="separator:a318e853caf08181ebce8a289b835bd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9e83256575eba0371a6330c5550214" id="r_afa9e83256575eba0371a6330c5550214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa9e83256575eba0371a6330c5550214">install_notify</a> )(const char *driverName, const <a class="el" href="structusb__notify__hooks.html">usb_notify_hooks</a> *hooks)</td></tr>
<tr class="memdesc:afa9e83256575eba0371a6330c5550214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install notify hooks for your driver.  <br /></td></tr>
<tr class="separator:afa9e83256575eba0371a6330c5550214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251ba68003d8164d76b98ac3e0e5c5c3" id="r_a251ba68003d8164d76b98ac3e0e5c5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a251ba68003d8164d76b98ac3e0e5c5c3">queue_bulk</a> )(<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, void *data, size_t dataLength, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td></tr>
<tr class="memdesc:a251ba68003d8164d76b98ac3e0e5c5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously queue a bulk transfer.  <br /></td></tr>
<tr class="separator:a251ba68003d8164d76b98ac3e0e5c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75e9761602b1cfeb844060e62d84b93" id="r_aa75e9761602b1cfeb844060e62d84b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa75e9761602b1cfeb844060e62d84b93">queue_bulk_v</a> )(<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, iovec *vector, size_t vectorCount, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td></tr>
<tr class="memdesc:aa75e9761602b1cfeb844060e62d84b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously queue a bulk vector.  <br /></td></tr>
<tr class="separator:aa75e9761602b1cfeb844060e62d84b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6997b487acef95cfad01738b39cd0e5b" id="r_a6997b487acef95cfad01738b39cd0e5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6997b487acef95cfad01738b39cd0e5b">queue_interrupt</a> )(<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, void *data, size_t dataLength, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td></tr>
<tr class="memdesc:a6997b487acef95cfad01738b39cd0e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously queue an interrupt transfer.  <br /></td></tr>
<tr class="separator:a6997b487acef95cfad01738b39cd0e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2008d3f56314190b51441039349f2d1" id="r_aa2008d3f56314190b51441039349f2d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa2008d3f56314190b51441039349f2d1">queue_isochronous</a> )(<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, void *data, size_t dataLength, <a class="el" href="structusb__iso__packet__descriptor.html">usb_iso_packet_descriptor</a> *packetDesc, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> packetCount, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *startingFrameNumber, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td></tr>
<tr class="memdesc:aa2008d3f56314190b51441039349f2d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously queue a isochronous transfer. Not implemented.  <br /></td></tr>
<tr class="separator:aa2008d3f56314190b51441039349f2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e30a8407353bd17a3084a9bc139d71" id="r_ac8e30a8407353bd17a3084a9bc139d71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8e30a8407353bd17a3084a9bc139d71">queue_request</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> requestType, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> request, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> value, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> index, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> length, void *data, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td></tr>
<tr class="memdesc:ac8e30a8407353bd17a3084a9bc139d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously queue a control pipe request.  <br /></td></tr>
<tr class="separator:ac8e30a8407353bd17a3084a9bc139d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c925bdcf6c4fb1340aae74bf03a38" id="r_a2b2c925bdcf6c4fb1340aae74bf03a38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b2c925bdcf6c4fb1340aae74bf03a38">register_driver</a> )(const char *driverName, const <a class="el" href="structusb__support__descriptor.html">usb_support_descriptor</a> *supportDescriptors, size_t supportDescriptorCount, const char *optionalRepublishDriverName)</td></tr>
<tr class="memdesc:a2b2c925bdcf6c4fb1340aae74bf03a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register your driver.  <br /></td></tr>
<tr class="separator:a2b2c925bdcf6c4fb1340aae74bf03a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e4ee4f5ce70aec8407f62701e67882" id="r_a68e4ee4f5ce70aec8407f62701e67882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68e4ee4f5ce70aec8407f62701e67882">send_request</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> requestType, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> request, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> value, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> index, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> length, void *data, size_t *actualLength)</td></tr>
<tr class="memdesc:a68e4ee4f5ce70aec8407f62701e67882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a generic, synchronous request over the default control pipe.  <br /></td></tr>
<tr class="separator:a68e4ee4f5ce70aec8407f62701e67882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa163487da04b51a86d6db0c309aaa706" id="r_aa163487da04b51a86d6db0c309aaa706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa163487da04b51a86d6db0c309aaa706">set_alt_interface</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, const <a class="el" href="structusb__interface__info.html">usb_interface_info</a> *interface)</td></tr>
<tr class="memdesc:aa163487da04b51a86d6db0c309aaa706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an alternative interface. Not implemented.  <br /></td></tr>
<tr class="separator:aa163487da04b51a86d6db0c309aaa706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100e008976fb16b2dba108488ddbc9a3" id="r_a100e008976fb16b2dba108488ddbc9a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a100e008976fb16b2dba108488ddbc9a3">set_configuration</a> )(<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, const <a class="el" href="structusb__configuration__info.html">usb_configuration_info</a> *configuration)</td></tr>
<tr class="memdesc:a100e008976fb16b2dba108488ddbc9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the current configuration.  <br /></td></tr>
<tr class="separator:a100e008976fb16b2dba108488ddbc9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdaca35371964120d74adbbb7f51c95" id="r_afcdaca35371964120d74adbbb7f51c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcdaca35371964120d74adbbb7f51c95">set_feature</a> )(<a class="el" href="USB3_8h.html#a4e263eb58c2c2f566e9bbe756b8a87a7">usb_id</a> handle, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> selector)</td></tr>
<tr class="memdesc:afcdaca35371964120d74adbbb7f51c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for standard control pipe set feature requests. Both the <a class="el" href="#afcdaca35371964120d74adbbb7f51c95" title="Convenience function for standard control pipe set feature requests. Both the set_feature() and clear...">set_feature()</a> and <a class="el" href="#ae498a5af2db4b12c4a767622dff6447a" title="Convenience function for standard control pipe clear feature requests.">clear_feature()</a> requests work on all the Stack's objects: devices, interfaces and pipes.  <br /></td></tr>
<tr class="separator:afcdaca35371964120d74adbbb7f51c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdade807bed0bb42198484d31699836e" id="r_afdade807bed0bb42198484d31699836e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdade807bed0bb42198484d31699836e">set_pipe_policy</a> )(<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> maxNumQueuedPackets, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> maxBufferDurationMS, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> sampleSize)</td></tr>
<tr class="memdesc:afdade807bed0bb42198484d31699836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set some pipe features.  <br /></td></tr>
<tr class="separator:afdade807bed0bb42198484d31699836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bcf60f29ceb298d9e6318e6e6e416a" id="r_a83bcf60f29ceb298d9e6318e6e6e416a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83bcf60f29ceb298d9e6318e6e6e416a">uninstall_notify</a> )(const char *driverName)</td></tr>
<tr class="memdesc:a83bcf60f29ceb298d9e6318e6e6e416a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall notify hooks for your driver.  <br /></td></tr>
<tr class="separator:a83bcf60f29ceb298d9e6318e6e6e416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be9974c7b635654632f345684409a8e" id="r_a8be9974c7b635654632f345684409a8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be9974c7b635654632f345684409a8e">usb_ioctl</a> )(<a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> opcode, void *buffer, size_t bufferSize)</td></tr>
<tr class="memdesc:a8be9974c7b635654632f345684409a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level commands to the USB stack.  <br /></td></tr>
<tr class="separator:a8be9974c7b635654632f345684409a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for drivers to interact with Haiku's USB stack. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a3fe38fcd6924611608d8958c6814f93e" name="a3fe38fcd6924611608d8958c6814f93e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/cancel_queued_transfers" class="dashAnchor">&nbsp;</a><a href="#a3fe38fcd6924611608d8958c6814f93e">&#9670;&#160;</a></span>cancel_queued_transfers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::cancel_queued_transfers) (<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancel pending transfers on a pipe. All the pending transfers will be cancelled. The stack will perform the callback on all of them that are cancelled. </p>
<dl class="section attention"><dt>Attention</dt><dd>There might be transfers that are being executed the moment you call this method. These will be executed, and their callbacks will be performed. Make sure you don't delete any buffers that could still be used by these transfers.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The id of the pipe to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>All the pending transfers on this pipe are deleted. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>The supplied usb_id is not a valid pipe. </td></tr>
    <tr><td class="paramname">other errors</td><td>There was an error clearing the pipe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae498a5af2db4b12c4a767622dff6447a" name="ae498a5af2db4b12c4a767622dff6447a"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/clear_feature" class="dashAnchor">&nbsp;</a><a href="#ae498a5af2db4b12c4a767622dff6447a">&#9670;&#160;</a></span>clear_feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::clear_feature) (<a class="el" href="USB3_8h.html#a4e263eb58c2c2f566e9bbe756b8a87a7">usb_id</a> handle, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> selector)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for standard control pipe clear feature requests. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#afcdaca35371964120d74adbbb7f51c95" title="Convenience function for standard control pipe set feature requests. Both the set_feature() and clear...">set_feature()</a> to see how this method works. </dd></dl>

</div>
</div>
<a id="ab1ab7fa09cd4df2193bc00660823acdc" name="ab1ab7fa09cd4df2193bc00660823acdc"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_configuration" class="dashAnchor">&nbsp;</a><a href="#ab1ab7fa09cd4df2193bc00660823acdc">&#9670;&#160;</a></span>get_configuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structusb__configuration__info.html">usb_configuration_info</a> *(* usb_module_info::get_configuration) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id of the device you want to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">This</td><td>will return <a class="el" href="structusb__configuration__info.html" title="Container for a specific configuration descriptor of a device.">usb_configuration_info</a> with the standard usb configuration descriptor, or it will return<code>NULL</code> if the <em>id</em> is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e01c2d5f14903e3ffbada712058adc5" name="a3e01c2d5f14903e3ffbada712058adc5"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_descriptor" class="dashAnchor">&nbsp;</a><a href="#a3e01c2d5f14903e3ffbada712058adc5">&#9670;&#160;</a></span>get_descriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::get_descriptor) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> descriptorType, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> index, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> languageID, void *data, size_t dataLength, size_t *actualLength)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to get a descriptor from a device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The device you want to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptorType</td><td>The type of descriptor you are requesting. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>In case there are multiple descriptors of this type, you select which one you want. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">languageID</td><td>The language you want the descriptor in (if applicable, as with string_descriptors). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The buffer in which the descriptor can be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataLength</td><td>The size of the buffer (in bytes). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">actualLength</td><td>A pointer to a variable in which the actual number of bytes written can be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The request succeeded, and the descriptor is written. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>Invalid <em>device</em> parameter. </td></tr>
    <tr><td class="paramname">other errors</td><td>Request failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87e309e0f458ffa63dd728ad4672f22c" name="a87e309e0f458ffa63dd728ad4672f22c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_device_descriptor" class="dashAnchor">&nbsp;</a><a href="#a87e309e0f458ffa63dd728ad4672f22c">&#9670;&#160;</a></span>get_device_descriptor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const usb_device_descriptor *(* usb_module_info::get_device_descriptor) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The id of the device you want to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The standard usb_device_descriptor, or <code>NULL</code> in case of an error. </dd></dl>

</div>
</div>
<a id="a61359a9b1bbd9ef858fdc2a1b40db120" name="a61359a9b1bbd9ef858fdc2a1b40db120"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_nth_configuration" class="dashAnchor">&nbsp;</a><a href="#a61359a9b1bbd9ef858fdc2a1b40db120">&#9670;&#160;</a></span>get_nth_configuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structusb__configuration__info.html">usb_configuration_info</a> *(* usb_module_info::get_nth_configuration) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> index)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a configuration descriptor by index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The id of the device you want to query. </td></tr>
    <tr><td class="paramname">index</td><td>The (zero based) offset of the list of configurations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will normally return the <a class="el" href="structusb__configuration__info.html" title="Container for a specific configuration descriptor of a device.">usb_configuration_info</a> with the standard usb configuration descriptor. <code>NULL</code> will be returned if the <em>id</em> is invalid or the <em>index</em> is out of bounds. </dd></dl>

</div>
</div>
<a id="a318e853caf08181ebce8a289b835bd8c" name="a318e853caf08181ebce8a289b835bd8c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_status" class="dashAnchor">&nbsp;</a><a href="#a318e853caf08181ebce8a289b835bd8c">&#9670;&#160;</a></span>get_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::get_status) (<a class="el" href="USB3_8h.html#a4e263eb58c2c2f566e9bbe756b8a87a7">usb_id</a> handle, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for standard usb status requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The object you want to query. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">status</td><td>A variable in which the device can store its status. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> is returned in case the request succeeded and the device responded positively, or an error code is returned in case it failed. </dd></dl>

</div>
</div>
<a id="afa9e83256575eba0371a6330c5550214" name="afa9e83256575eba0371a6330c5550214"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/install_notify" class="dashAnchor">&nbsp;</a><a href="#afa9e83256575eba0371a6330c5550214">&#9670;&#160;</a></span>install_notify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::install_notify) (const char *driverName, const <a class="el" href="structusb__notify__hooks.html">usb_notify_hooks</a> *hooks)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install notify hooks for your driver. </p>
<p>After your driver is registered, you need to pass hooks to your driver that are called whenever a device that matches your <a class="el" href="structusb__support__descriptor.html">support descriptor </a> .</p>
<p>As soon as the hooks are installed, you'll receive callbacks for devices that are already attached; so make sure your driver is initialized properly when calling this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driverName</td><td>The name you passed in <a class="el" href="#a2b2c925bdcf6c4fb1340aae74bf03a38" title="Register your driver.">register_driver()</a>. </td></tr>
    <tr><td class="paramname">hooks</td><td>The hooks the stack should call in case the status of devices that match your support descriptor changes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Hooks are installed succesfully. </td></tr>
    <tr><td class="paramname">B_NAME_NOT_FOUND</td><td>Invalid <em>driverName</em>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structusb__notify__hooks.html" title="Hooks that the USB stack can callback in case of events.">usb_notify_hooks</a> for information on how your hooks should behave. </dd>
<dd>
<a class="el" href="#a83bcf60f29ceb298d9e6318e6e6e416a" title="Uninstall notify hooks for your driver.">uninstall_notify()</a> </dd></dl>

</div>
</div>
<a id="a251ba68003d8164d76b98ac3e0e5c5c3" name="a251ba68003d8164d76b98ac3e0e5c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/queue_bulk" class="dashAnchor">&nbsp;</a><a href="#a251ba68003d8164d76b98ac3e0e5c5c3">&#9670;&#160;</a></span>queue_bulk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::queue_bulk) (<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, void *data, size_t dataLength, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously queue a bulk transfer. </p>
<p>This method behaves like the <a class="el" href="#a6997b487acef95cfad01738b39cd0e5b" title="Asynchronously queue an interrupt transfer.">queue_interrupt()</a> method, except that it queues a bulk transfer. </p>

</div>
</div>
<a id="aa75e9761602b1cfeb844060e62d84b93" name="aa75e9761602b1cfeb844060e62d84b93"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/queue_bulk_v" class="dashAnchor">&nbsp;</a><a href="#aa75e9761602b1cfeb844060e62d84b93">&#9670;&#160;</a></span>queue_bulk_v</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::queue_bulk_v) (<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, iovec *vector, size_t vectorCount, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously queue a bulk vector. </p>
<p>This method behaves like the <a class="el" href="#a6997b487acef95cfad01738b39cd0e5b" title="Asynchronously queue an interrupt transfer.">queue_interrupt()</a> method, except that it queues bulk transfers and that it is based on an (array of) io vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>One or more io vectors. IO vectors are standard POSIX entities. </td></tr>
    <tr><td class="paramname">vectorCount</td><td>The number of elements in the <em>vector</em> array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6997b487acef95cfad01738b39cd0e5b" name="a6997b487acef95cfad01738b39cd0e5b"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/queue_interrupt" class="dashAnchor">&nbsp;</a><a href="#a6997b487acef95cfad01738b39cd0e5b">&#9670;&#160;</a></span>queue_interrupt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::queue_interrupt) (<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, void *data, size_t dataLength, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously queue an interrupt transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The id of the pipe you want to query. </td></tr>
    <tr><td class="paramname">data</td><td>The data buffer you want to pass. </td></tr>
    <tr><td class="paramname">dataLength</td><td>The size of the data buffer. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function the stack should call after finishing. </td></tr>
    <tr><td class="paramname">callbackCookie</td><td>A cookie that will be supplied to your callback function when the transfer is finished.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This will return a value indicating whether or not the queueing of the transfer went well. The return value won't tell you if the transfer actually succeeded. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The interrupt transfer is queued. </td></tr>
    <tr><td class="paramname">B_NO_MEMORY</td><td>Error allocating objects. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>The <em>pipe</em> is not a valid interrupt pipe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2008d3f56314190b51441039349f2d1" name="aa2008d3f56314190b51441039349f2d1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/queue_isochronous" class="dashAnchor">&nbsp;</a><a href="#aa2008d3f56314190b51441039349f2d1">&#9670;&#160;</a></span>queue_isochronous</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::queue_isochronous) (<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, void *data, size_t dataLength, <a class="el" href="structusb__iso__packet__descriptor.html">usb_iso_packet_descriptor</a> *packetDesc, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> packetCount, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *startingFrameNumber, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously queue a isochronous transfer. Not implemented. </p>
<p>This is not implemented in the current Haiku USB Stack. </p>

</div>
</div>
<a id="ac8e30a8407353bd17a3084a9bc139d71" name="ac8e30a8407353bd17a3084a9bc139d71"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/queue_request" class="dashAnchor">&nbsp;</a><a href="#ac8e30a8407353bd17a3084a9bc139d71">&#9670;&#160;</a></span>queue_request</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::queue_request) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> requestType, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> request, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> value, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> index, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> length, void *data, <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">usb_callback_func</a> callback, void *callbackCookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously queue a control pipe request. </p>
<p>This method does roughly the same as <a class="el" href="#a68e4ee4f5ce70aec8407f62701e67882" title="Send a generic, synchronous request over the default control pipe.">send_request()</a>, however, it works asynchronously. This means that the method will return as soon as the transfer is queued.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function for when the transfer is done. </td></tr>
    <tr><td class="paramname">callbackCookie</td><td>The cookie that the stack should pass to your callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not the queueing of the transfer went well. The return value won't tell you if the transfer actually succeeded. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The control transfer is queued. </td></tr>
    <tr><td class="paramname">B_NO_MEMORY</td><td>Error allocating objects. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>The <em>device</em> argument is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b2c925bdcf6c4fb1340aae74bf03a38" name="a2b2c925bdcf6c4fb1340aae74bf03a38"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/register_driver" class="dashAnchor">&nbsp;</a><a href="#a2b2c925bdcf6c4fb1340aae74bf03a38">&#9670;&#160;</a></span>register_driver</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::register_driver) (const char *driverName, const <a class="el" href="structusb__support__descriptor.html">usb_support_descriptor</a> *supportDescriptors, size_t supportDescriptorCount, const char *optionalRepublishDriverName)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register your driver. </p>
<p>To let the USB stack know that a driver is available to support devices, a driver needs to register itself first. To let the stack know about devices it needs to notify the driver of, have a look at <a class="el" href="structusb__support__descriptor.html" title="Description of device descriptor that the driver can handle.">usb_support_descriptor</a>.</p>
<p>It is possible to supply a list of support constructors. You should allocate an array of support constructors and give the amount of constructors in the array using the <em>supportDescriptorCount</em> parameter.</p>
<p>In case your driver supports all devices or, more likely, you want to monitor all devices plugged in and removed, it is safe to pass <code>NULL</code> to the <em>supportDescriptors</em> paramater and zero (0) to <em>supportDescriptorCount</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driverName</td><td>A unique name that identifies your driver. Avoid names like <code>webcam</code> or <code>mouse</code>, instead use vendor names and device types to avoid nameclashes. The <a class="el" href="#afa9e83256575eba0371a6330c5550214" title="Install notify hooks for your driver.">install_notify()</a> and <a class="el" href="#a83bcf60f29ceb298d9e6318e6e6e416a" title="Uninstall notify hooks for your driver.">uninstall_notify()</a> functions use the driver name as an identifier.</td></tr>
    <tr><td class="paramname">supportDescriptors</td><td>An array of the type <a class="el" href="structusb__support__descriptor.html" title="Description of device descriptor that the driver can handle.">usb_support_descriptor</a>. Pass the amount of objects in the next parameter. </td></tr>
    <tr><td class="paramname">supportDescriptorCount</td><td>The number of objects in the array supplied in the previous parameter. </td></tr>
    <tr><td class="paramname">optionalRepublishDriverName</td><td>Unused parameter. You should pass <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The driver is registered. You can now call <a class="el" href="#afa9e83256575eba0371a6330c5550214" title="Install notify hooks for your driver.">install_notify()</a> </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>You passed <code>NULL</code> as <em>driverName</em>. </td></tr>
    <tr><td class="paramname">B_ERROR</td><td>General internal error in the USB stack. You may retry the request in this case. </td></tr>
    <tr><td class="paramname">B_NO_MEMORY</td><td>Error allocating some internal objects. The system is out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68e4ee4f5ce70aec8407f62701e67882" name="a68e4ee4f5ce70aec8407f62701e67882"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/send_request" class="dashAnchor">&nbsp;</a><a href="#a68e4ee4f5ce70aec8407f62701e67882">&#9670;&#160;</a></span>send_request</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::send_request) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> requestType, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> request, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> value, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> index, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> length, void *data, size_t *actualLength)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a generic, synchronous request over the default control pipe. </p>
<p>See <a class="el" href="#ac8e30a8407353bd17a3084a9bc139d71" title="Asynchronously queue a control pipe request.">queue_request()</a> for an asynchronous version of this method.</p>
<p>Most of the standard values of a request are defined in <a class="el" href="USB__spec_8h.html" title="General definitions as defined by the USB standard.">USB_spec.h</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device</td><td>The device you want to query. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requestType</td><td>The request type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The request you want to perform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value of the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index for the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>The size of the buffer pointed by <em>data</em> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>The buffer where to put the result in. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">actualLength</td><td>The actual numbers of bytes written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The request succeeded. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>Invalid <em>device</em> parameter. </td></tr>
    <tr><td class="paramname">other errors</td><td>Request failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa163487da04b51a86d6db0c309aaa706" name="aa163487da04b51a86d6db0c309aaa706"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/set_alt_interface" class="dashAnchor">&nbsp;</a><a href="#aa163487da04b51a86d6db0c309aaa706">&#9670;&#160;</a></span>set_alt_interface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::set_alt_interface) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, const <a class="el" href="structusb__interface__info.html">usb_interface_info</a> *interface)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an alternative interface. Not implemented. </p>
<p>This method currently always returns <code>B_ERROR</code>. </p>

</div>
</div>
<a id="a100e008976fb16b2dba108488ddbc9a3" name="a100e008976fb16b2dba108488ddbc9a3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/set_configuration" class="dashAnchor">&nbsp;</a><a href="#a100e008976fb16b2dba108488ddbc9a3">&#9670;&#160;</a></span>set_configuration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::set_configuration) (<a class="el" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> device, const <a class="el" href="structusb__configuration__info.html">usb_configuration_info</a> *configuration)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the current configuration. </p>
<p>Changing the configuration will destroy all the current endpoints. If the <em>configuration</em> points to the current configuration, the request will be ignored and <code>B_OK</code> will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The id of the device you want to query. </td></tr>
    <tr><td class="paramname">configuration</td><td>The pointer to the new configuration you want to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The new configuration is set succesfully. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>The <em>device</em> parameter is invalid. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>The configuration does not exist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method also allows you to completely unconfigure the device, which means that all the current endpoints, pipes and transfers will be freed. Pass <code>NULL</code> to the parameter <em>configuration</em> if you want to do that. </dd></dl>

</div>
</div>
<a id="afcdaca35371964120d74adbbb7f51c95" name="afcdaca35371964120d74adbbb7f51c95"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/set_feature" class="dashAnchor">&nbsp;</a><a href="#afcdaca35371964120d74adbbb7f51c95">&#9670;&#160;</a></span>set_feature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::set_feature) (<a class="el" href="USB3_8h.html#a4e263eb58c2c2f566e9bbe756b8a87a7">usb_id</a> handle, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> selector)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function for standard control pipe set feature requests. Both the <a class="el" href="#afcdaca35371964120d74adbbb7f51c95" title="Convenience function for standard control pipe set feature requests. Both the set_feature() and clear...">set_feature()</a> and <a class="el" href="#ae498a5af2db4b12c4a767622dff6447a" title="Convenience function for standard control pipe clear feature requests.">clear_feature()</a> requests work on all the Stack's objects: devices, interfaces and pipes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>The object you want to query. </td></tr>
    <tr><td class="paramname">selector</td><td>The value you want to pass in the feature request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> in case the request succeeded and the device responded positively, or an error code in case it failed. </dd></dl>

</div>
</div>
<a id="afdade807bed0bb42198484d31699836e" name="afdade807bed0bb42198484d31699836e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/set_pipe_policy" class="dashAnchor">&nbsp;</a><a href="#afdade807bed0bb42198484d31699836e">&#9670;&#160;</a></span>set_pipe_policy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::set_pipe_policy) (<a class="el" href="USB3_8h.html#a1de2e092cf27f70efefef3ad3e6facd4">usb_pipe</a> pipe, <a class="el" href="SupportDefs_8h.html#ac56eeb3040e225fafe52dc1872233eeb">uint8</a> maxNumQueuedPackets, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> maxBufferDurationMS, <a class="el" href="SupportDefs_8h.html#ac267cdaa9a4909f02aa2fc83cc7da477">uint16</a> sampleSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set some pipe features. </p>
<p>The USB standard specifies some properties that should be able to be set on isochronous pipes. If your driver requires the properties to be changed, you should use this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pipe</td><td>The id of the isochronous pipe you want to alter. </td></tr>
    <tr><td class="paramname">maxNumQueuedPackets</td><td>The maximum number of queued packets allowed on this pipe. </td></tr>
    <tr><td class="paramname">maxBufferDurationMS</td><td>The maximum time in ms that the buffers are valid. </td></tr>
    <tr><td class="paramname">sampleSize</td><td>The size of the samples through this pipe. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Pipe policy changed. </td></tr>
    <tr><td class="paramname">B_DEV_INVALID_PIPE</td><td>The <em>pipe</em> argument is invalid or not an isochronous pipe. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83bcf60f29ceb298d9e6318e6e6e416a" name="a83bcf60f29ceb298d9e6318e6e6e416a"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/uninstall_notify" class="dashAnchor">&nbsp;</a><a href="#a83bcf60f29ceb298d9e6318e6e6e416a">&#9670;&#160;</a></span>uninstall_notify</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::uninstall_notify) (const char *driverName)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall notify hooks for your driver. </p>
<p>If your driver needs to stop, you can uninstall the notifier hooks. This will clear the stored hooks in the driver, and you will not receive any notifications when new devices are attached. This method will also call <a class="el" href="structusb__notify__hooks.html#a8593a3f8e6f0ab4caed5bd0317e56909" title="Called by the stack in case a device you are using is removed.">usb_notify_hooks::device_removed()</a> for all the devices that you are using and all the stack's resources that are allocated to your driver are cleared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driverName</td><td>The name you passed in <a class="el" href="#a2b2c925bdcf6c4fb1340aae74bf03a38" title="Register your driver.">register_driver()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Hooks are uninstalled. </td></tr>
    <tr><td class="paramname">B_NAME_NOT_FOUND</td><td>Invalid <em>driverName</em>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8be9974c7b635654632f345684409a8e" name="a8be9974c7b635654632f345684409a8e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/usb_ioctl" class="dashAnchor">&nbsp;</a><a href="#a8be9974c7b635654632f345684409a8e">&#9670;&#160;</a></span>usb_ioctl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* usb_module_info::usb_ioctl) (<a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> opcode, void *buffer, size_t bufferSize)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Low level commands to the USB stack. </p>
<p>This method is used to give lowlevel commands to the Stack. There are currently no uses documented. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - usb_module_info Struct Reference<br />
    Generated on Sat May 24 2025 23:12:20 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
