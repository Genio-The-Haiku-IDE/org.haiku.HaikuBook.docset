<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: BLooper Class Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classBLooper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BLooper Class Reference<div class="ingroups"><a class="el" href="group__app.html">Application Kit</a> &#124; <a class="el" href="group__libbe.html">(libbe.so)</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Receive and process messages in a separate thread.  
 <a href="#details">More...</a></p>

<p>Inherits <a class="el" href="classBHandler.html">BHandler</a>.</p>

<p>Inherited by <a class="el" href="classBApplication.html">BApplication</a>, and .</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a33fa84a6ed383e5a897d11380d72ce38" id="r_a33fa84a6ed383e5a897d11380d72ce38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33fa84a6ed383e5a897d11380d72ce38">BLooper</a> (const char *name=<a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> priority=B_NORMAL_PRIORITY, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> portCapacity=<a class="el" href="Looper_8h.html#a7e8948687d8c2652df30af6c9eba4ab4">B_LOOPER_PORT_DEFAULT_CAPACITY</a>)</td></tr>
<tr class="memdesc:a33fa84a6ed383e5a897d11380d72ce38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> with a <em>priority</em> and an <em>capacity</em>.  <br /></td></tr>
<tr class="separator:a33fa84a6ed383e5a897d11380d72ce38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717b08ea49bcc73037b6d8675e94c9be" id="r_a717b08ea49bcc73037b6d8675e94c9be"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a717b08ea49bcc73037b6d8675e94c9be">~BLooper</a> ()</td></tr>
<tr class="memdesc:a717b08ea49bcc73037b6d8675e94c9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the looper.  <br /></td></tr>
<tr class="separator:a717b08ea49bcc73037b6d8675e94c9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abbd10d6ac490fcb379cb3311e7f928" id="r_a1abbd10d6ac490fcb379cb3311e7f928"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1abbd10d6ac490fcb379cb3311e7f928">Perform</a> (<a class="el" href="SupportDefs_8h.html#ad2237b0064c91c237159edc020989bab">perform_code</a> d, void *arg)</td></tr>
<tr class="memdesc:a1abbd10d6ac490fcb379cb3311e7f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method.  <br /></td></tr>
<tr class="separator:a1abbd10d6ac490fcb379cb3311e7f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Message Mechanics</div></td></tr>
<tr class="memitem:a0de6737bfbf8a8b4913adc8c74bb544e" id="r_a0de6737bfbf8a8b4913adc8c74bb544e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e">PostMessage</a> (<a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> command)</td></tr>
<tr class="memdesc:a0de6737bfbf8a8b4913adc8c74bb544e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a message with the <em>command</em> as <code>what</code> identifier to this looper.  <br /></td></tr>
<tr class="separator:a0de6737bfbf8a8b4913adc8c74bb544e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79a7818ce950d8edcd238f7948df020" id="r_ae79a7818ce950d8edcd238f7948df020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae79a7818ce950d8edcd238f7948df020">PostMessage</a> (<a class="el" href="classBMessage.html">BMessage</a> *message)</td></tr>
<tr class="memdesc:ae79a7818ce950d8edcd238f7948df020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post a <em>message</em> to this looper.  <br /></td></tr>
<tr class="separator:ae79a7818ce950d8edcd238f7948df020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc16ecf211eb7e32eaa4b08863e856d" id="r_a2dc16ecf211eb7e32eaa4b08863e856d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dc16ecf211eb7e32eaa4b08863e856d">PostMessage</a> (<a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> command, <a class="el" href="classBHandler.html">BHandler</a> *handler, <a class="el" href="classBHandler.html">BHandler</a> *replyTo=<a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="memdesc:a2dc16ecf211eb7e32eaa4b08863e856d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message with <em>command</em> <code>what</code> identifier to the <em>handler</em> associated with this looper. A response may be sent to the <em>replyTo</em> handler asynchronously.  <br /></td></tr>
<tr class="separator:a2dc16ecf211eb7e32eaa4b08863e856d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75eed80e72b236650f19b4015de6e99" id="r_ac75eed80e72b236650f19b4015de6e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac75eed80e72b236650f19b4015de6e99">PostMessage</a> (<a class="el" href="classBMessage.html">BMessage</a> *message, <a class="el" href="classBHandler.html">BHandler</a> *handler, <a class="el" href="classBHandler.html">BHandler</a> *replyTo=<a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="memdesc:ac75eed80e72b236650f19b4015de6e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a <em>message</em> to the <em>handler</em> associated with this looper. A response may be sent to the <em>replyTo</em> handler asynchronously.  <br /></td></tr>
<tr class="separator:ac75eed80e72b236650f19b4015de6e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Message Processing</div></td></tr>
<tr class="memitem:abb9ffb64420b2fafc0764e74c5be7a6c" id="r_abb9ffb64420b2fafc0764e74c5be7a6c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb9ffb64420b2fafc0764e74c5be7a6c">DispatchMessage</a> (<a class="el" href="classBMessage.html">BMessage</a> *message, <a class="el" href="classBHandler.html">BHandler</a> *handler)</td></tr>
<tr class="memdesc:abb9ffb64420b2fafc0764e74c5be7a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch a message to a handler. Override if there are messages that you want to catch before they are sent to the handlers.  <br /></td></tr>
<tr class="separator:abb9ffb64420b2fafc0764e74c5be7a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef10bd4264968869ead521b7ab699ff" id="r_a1ef10bd4264968869ead521b7ab699ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ef10bd4264968869ead521b7ab699ff">MessageReceived</a> (<a class="el" href="classBMessage.html">BMessage</a> *message)</td></tr>
<tr class="memdesc:a1ef10bd4264968869ead521b7ab699ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a message received by the internal handler of this looper.  <br /></td></tr>
<tr class="separator:a1ef10bd4264968869ead521b7ab699ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d244af065c4a12ea795bbbc7bb20e07" id="r_a6d244af065c4a12ea795bbbc7bb20e07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBMessage.html">BMessage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d244af065c4a12ea795bbbc7bb20e07">CurrentMessage</a> () const</td></tr>
<tr class="memdesc:a6d244af065c4a12ea795bbbc7bb20e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current message.  <br /></td></tr>
<tr class="separator:a6d244af065c4a12ea795bbbc7bb20e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8f05bcc354bc1d53026417417120e3" id="r_a7c8f05bcc354bc1d53026417417120e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBMessage.html">BMessage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c8f05bcc354bc1d53026417417120e3">DetachCurrentMessage</a> ()</td></tr>
<tr class="memdesc:a7c8f05bcc354bc1d53026417417120e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ownership of the message currently being processed.  <br /></td></tr>
<tr class="separator:a7c8f05bcc354bc1d53026417417120e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2d3773466de19a6c117f3a04861b11" id="r_a3a2d3773466de19a6c117f3a04861b11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a2d3773466de19a6c117f3a04861b11">DispatchExternalMessage</a> (<a class="el" href="classBMessage.html">BMessage</a> *message, <a class="el" href="classBHandler.html">BHandler</a> *handler, bool &amp;_detached)</td></tr>
<tr class="memdesc:a3a2d3773466de19a6c117f3a04861b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method to support single-threaded GUI toolkits.  <br /></td></tr>
<tr class="separator:a3a2d3773466de19a6c117f3a04861b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0643973ceda5cca540c4684a9f670ac" id="r_ad0643973ceda5cca540c4684a9f670ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBMessageQueue.html">BMessageQueue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0643973ceda5cca540c4684a9f670ac">MessageQueue</a> () const</td></tr>
<tr class="memdesc:ad0643973ceda5cca540c4684a9f670ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the internal message queue of this looper.  <br /></td></tr>
<tr class="separator:ad0643973ceda5cca540c4684a9f670ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fd22b9eeaeadbeff1e973ed5242a64" id="r_a27fd22b9eeaeadbeff1e973ed5242a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27fd22b9eeaeadbeff1e973ed5242a64">IsMessageWaiting</a> () const</td></tr>
<tr class="memdesc:a27fd22b9eeaeadbeff1e973ed5242a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there is a message waiting.  <br /></td></tr>
<tr class="separator:a27fd22b9eeaeadbeff1e973ed5242a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Handler Management</div></td></tr>
<tr class="memitem:a484be74814014e3c48c1a16f44e34074" id="r_a484be74814014e3c48c1a16f44e34074"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a484be74814014e3c48c1a16f44e34074">AddHandler</a> (<a class="el" href="classBHandler.html">BHandler</a> *handler)</td></tr>
<tr class="memdesc:a484be74814014e3c48c1a16f44e34074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Associate a <em>handler</em> to this looper.  <br /></td></tr>
<tr class="separator:a484be74814014e3c48c1a16f44e34074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af57140bf018388a2e64343f46ac330" id="r_a5af57140bf018388a2e64343f46ac330"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5af57140bf018388a2e64343f46ac330">RemoveHandler</a> (<a class="el" href="classBHandler.html">BHandler</a> *handler)</td></tr>
<tr class="memdesc:a5af57140bf018388a2e64343f46ac330"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disassociate a <em>handler</em> from this looper.  <br /></td></tr>
<tr class="separator:a5af57140bf018388a2e64343f46ac330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6179629238d0be92d7a89503be24d4e3" id="r_a6179629238d0be92d7a89503be24d4e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6179629238d0be92d7a89503be24d4e3">CountHandlers</a> () const</td></tr>
<tr class="memdesc:a6179629238d0be92d7a89503be24d4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of handlers associated with this looper.  <br /></td></tr>
<tr class="separator:a6179629238d0be92d7a89503be24d4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6976132123edacf4b3a2831eadf5f4bf" id="r_a6976132123edacf4b3a2831eadf5f4bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBHandler.html">BHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6976132123edacf4b3a2831eadf5f4bf">HandlerAt</a> (<a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> index) const</td></tr>
<tr class="memdesc:a6976132123edacf4b3a2831eadf5f4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the handler at an <em>index</em> of the list of associated handlers.  <br /></td></tr>
<tr class="separator:a6976132123edacf4b3a2831eadf5f4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3061534f6d2f3186efca4cddd19f378f" id="r_a3061534f6d2f3186efca4cddd19f378f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3061534f6d2f3186efca4cddd19f378f">IndexOf</a> (<a class="el" href="classBHandler.html">BHandler</a> *handler) const</td></tr>
<tr class="memdesc:a3061534f6d2f3186efca4cddd19f378f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the <em>handler</em> that is in the associated handler list.  <br /></td></tr>
<tr class="separator:a3061534f6d2f3186efca4cddd19f378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a4af6872abc40a887bfcabd55aff98" id="r_af1a4af6872abc40a887bfcabd55aff98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBHandler.html">BHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1a4af6872abc40a887bfcabd55aff98">PreferredHandler</a> () const</td></tr>
<tr class="memdesc:af1a4af6872abc40a887bfcabd55aff98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the preferred handler.  <br /></td></tr>
<tr class="separator:af1a4af6872abc40a887bfcabd55aff98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c6e5c65354b48465fde2b0b44e22c6" id="r_a07c6e5c65354b48465fde2b0b44e22c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c6e5c65354b48465fde2b0b44e22c6">SetPreferredHandler</a> (<a class="el" href="classBHandler.html">BHandler</a> *handler)</td></tr>
<tr class="memdesc:a07c6e5c65354b48465fde2b0b44e22c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a preferred handler.  <br /></td></tr>
<tr class="separator:a07c6e5c65354b48465fde2b0b44e22c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Loop Debugging</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods may aid you in debugging problems when they occur, but do not use these in actual production code. These methods are unreliable because they are not thread-safe, and as such are only useful in specific debugging situations. Handle with care. </p>
</div></td></tr>
<tr class="memitem:a1d5d9dbc9d890ed1329b69fbfe9254b3" id="r_a1d5d9dbc9d890ed1329b69fbfe9254b3"><td class="memItemLeft" align="right" valign="top">thread_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d5d9dbc9d890ed1329b69fbfe9254b3">LockingThread</a> () const</td></tr>
<tr class="memdesc:a1d5d9dbc9d890ed1329b69fbfe9254b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread id of the thread that currently holds the lock.  <br /></td></tr>
<tr class="separator:a1d5d9dbc9d890ed1329b69fbfe9254b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eec703acd9bd7fe9a455af0f81e08f9" id="r_a4eec703acd9bd7fe9a455af0f81e08f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4eec703acd9bd7fe9a455af0f81e08f9">CountLocks</a> () const</td></tr>
<tr class="memdesc:a4eec703acd9bd7fe9a455af0f81e08f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of recursive locks that are currently being held on this looper.  <br /></td></tr>
<tr class="separator:a4eec703acd9bd7fe9a455af0f81e08f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e7b89294df1f7b614d1267f870ecd9" id="r_a64e7b89294df1f7b614d1267f870ecd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64e7b89294df1f7b614d1267f870ecd9">CountLockRequests</a> () const</td></tr>
<tr class="memdesc:a64e7b89294df1f7b614d1267f870ecd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of pending locks.  <br /></td></tr>
<tr class="separator:a64e7b89294df1f7b614d1267f870ecd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96df67561b0ce1428ae45148c21e01f" id="r_aa96df67561b0ce1428ae45148c21e01f"><td class="memItemLeft" align="right" valign="top">sem_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa96df67561b0ce1428ae45148c21e01f">Sem</a> () const</td></tr>
<tr class="memdesc:aa96df67561b0ce1428ae45148c21e01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the id of the semaphore that is used to lock this looper.  <br /></td></tr>
<tr class="separator:aa96df67561b0ce1428ae45148c21e01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Scripting</div></td></tr>
<tr class="memitem:abc72704386dd39a47efbfd70be4b0a92" id="r_abc72704386dd39a47efbfd70be4b0a92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBHandler.html">BHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc72704386dd39a47efbfd70be4b0a92">ResolveSpecifier</a> (<a class="el" href="classBMessage.html">BMessage</a> *message, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> index, <a class="el" href="classBMessage.html">BMessage</a> *specifier, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> what, const char *property)</td></tr>
<tr class="memdesc:abc72704386dd39a47efbfd70be4b0a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the proper handler for a scripting message.  <br /></td></tr>
<tr class="separator:abc72704386dd39a47efbfd70be4b0a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b759aee92031b41e08669645a3abe3" id="r_a87b759aee92031b41e08669645a3abe3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b759aee92031b41e08669645a3abe3">GetSupportedSuites</a> (<a class="el" href="classBMessage.html">BMessage</a> *data)</td></tr>
<tr class="memdesc:a87b759aee92031b41e08669645a3abe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the suites of messages and specifiers that derived classes understand.  <br /></td></tr>
<tr class="separator:a87b759aee92031b41e08669645a3abe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Looper Message Filters</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Note that filters added with these methods will be applied to all associated handlers. Have a look at the filtering methods of the <a class="el" href="classBHandler.html" title="Handles messages that are passed on by a BLooper.">BHandler</a> class to see how filters can be applied to the inherited handler of this looper specifically. </p>
</div></td></tr>
<tr class="memitem:a422da6a77838f4ed6efd1b8a2e3df5fc" id="r_a422da6a77838f4ed6efd1b8a2e3df5fc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a422da6a77838f4ed6efd1b8a2e3df5fc">AddCommonFilter</a> (<a class="el" href="classBMessageFilter.html">BMessageFilter</a> *filter)</td></tr>
<tr class="memdesc:a422da6a77838f4ed6efd1b8a2e3df5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a common filter to the list of filters that are applied to all incoming messages.  <br /></td></tr>
<tr class="separator:a422da6a77838f4ed6efd1b8a2e3df5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9a19d7b52ea4838ab757b8ba7f4ebe" id="r_add9a19d7b52ea4838ab757b8ba7f4ebe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add9a19d7b52ea4838ab757b8ba7f4ebe">RemoveCommonFilter</a> (<a class="el" href="classBMessageFilter.html">BMessageFilter</a> *filter)</td></tr>
<tr class="memdesc:add9a19d7b52ea4838ab757b8ba7f4ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a <em>filter</em> from the common message filter list.  <br /></td></tr>
<tr class="separator:add9a19d7b52ea4838ab757b8ba7f4ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae539e5548714a9acdd071e7126fe953c" id="r_ae539e5548714a9acdd071e7126fe953c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae539e5548714a9acdd071e7126fe953c">SetCommonFilterList</a> (<a class="el" href="classBList.html">BList</a> *filters)</td></tr>
<tr class="memdesc:ae539e5548714a9acdd071e7126fe953c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new list of <em>filters</em> that need to be applied to all incoming messages.  <br /></td></tr>
<tr class="separator:ae539e5548714a9acdd071e7126fe953c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64f1a98c1cce8087e7d492860461a62" id="r_ad64f1a98c1cce8087e7d492860461a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBList.html">BList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad64f1a98c1cce8087e7d492860461a62">CommonFilterList</a> () const</td></tr>
<tr class="memdesc:ad64f1a98c1cce8087e7d492860461a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of filters applied to all incoming messages.  <br /></td></tr>
<tr class="separator:ad64f1a98c1cce8087e7d492860461a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBHandler"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classBHandler')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBHandler.html">BHandler</a></td></tr>
<tr class="memitem:a2142e21fe781b24f914ec2086e5f05b7 inherit pub_methods_classBHandler" id="r_a2142e21fe781b24f914ec2086e5f05b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a2142e21fe781b24f914ec2086e5f05b7">BHandler</a> (const char *name=<a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="memdesc:a2142e21fe781b24f914ec2086e5f05b7 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new handler with a <em>name</em>.  <br /></td></tr>
<tr class="separator:a2142e21fe781b24f914ec2086e5f05b7 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f2831ec5a41e6c1b8cd5cf23e4cc88 inherit pub_methods_classBHandler" id="r_a38f2831ec5a41e6c1b8cd5cf23e4cc88"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a38f2831ec5a41e6c1b8cd5cf23e4cc88">~BHandler</a> ()</td></tr>
<tr class="memdesc:a38f2831ec5a41e6c1b8cd5cf23e4cc88 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the filters of this handler, as well as the list of observers.  <br /></td></tr>
<tr class="separator:a38f2831ec5a41e6c1b8cd5cf23e4cc88 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8fa081a7bb8633581e78777b215d0b inherit pub_methods_classBHandler" id="r_add8fa081a7bb8633581e78777b215d0b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#add8fa081a7bb8633581e78777b215d0b">BHandler</a> (<a class="el" href="classBMessage.html">BMessage</a> *data)</td></tr>
<tr class="memdesc:add8fa081a7bb8633581e78777b215d0b inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a handler from an archived message.  <br /></td></tr>
<tr class="separator:add8fa081a7bb8633581e78777b215d0b inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e949959b12e602e3b0c4f023c60e6c inherit pub_methods_classBHandler" id="r_ac8e949959b12e602e3b0c4f023c60e6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBLooper.html">BLooper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#ac8e949959b12e602e3b0c4f023c60e6c">Looper</a> () const</td></tr>
<tr class="memdesc:ac8e949959b12e602e3b0c4f023c60e6c inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the looper that this handler is associated with.  <br /></td></tr>
<tr class="separator:ac8e949959b12e602e3b0c4f023c60e6c inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf861126df4b6e71b9261a99da4ad0eb inherit pub_methods_classBHandler" id="r_abf861126df4b6e71b9261a99da4ad0eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#abf861126df4b6e71b9261a99da4ad0eb">SetName</a> (const char *name)</td></tr>
<tr class="memdesc:abf861126df4b6e71b9261a99da4ad0eb inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or change the name of this handler.  <br /></td></tr>
<tr class="separator:abf861126df4b6e71b9261a99da4ad0eb inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b246ac272e09b2f641d1290be21200 inherit pub_methods_classBHandler" id="r_a40b246ac272e09b2f641d1290be21200"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a40b246ac272e09b2f641d1290be21200">Name</a> () const</td></tr>
<tr class="memdesc:a40b246ac272e09b2f641d1290be21200 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of this handler.  <br /></td></tr>
<tr class="separator:a40b246ac272e09b2f641d1290be21200 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b6316dcbb371347bbb44fd5889bdf inherit pub_methods_classBHandler" id="r_a664b6316dcbb371347bbb44fd5889bdf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a664b6316dcbb371347bbb44fd5889bdf">SetNextHandler</a> (<a class="el" href="classBHandler.html">BHandler</a> *handler)</td></tr>
<tr class="memdesc:a664b6316dcbb371347bbb44fd5889bdf inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the next handler in the chain that the message is passed on to if this <em>handler</em> cannot process it.  <br /></td></tr>
<tr class="separator:a664b6316dcbb371347bbb44fd5889bdf inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92855d8f88f6072e7225bde292feaa38 inherit pub_methods_classBHandler" id="r_a92855d8f88f6072e7225bde292feaa38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBHandler.html">BHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a92855d8f88f6072e7225bde292feaa38">NextHandler</a> () const</td></tr>
<tr class="memdesc:a92855d8f88f6072e7225bde292feaa38 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next hander in the chain to which the message is passed on.  <br /></td></tr>
<tr class="separator:a92855d8f88f6072e7225bde292feaa38 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460dc01e76ca23d2b7f2594d921fb42e inherit pub_methods_classBHandler" id="r_a460dc01e76ca23d2b7f2594d921fb42e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a460dc01e76ca23d2b7f2594d921fb42e">AddFilter</a> (<a class="el" href="classBMessageFilter.html">BMessageFilter</a> *filter)</td></tr>
<tr class="memdesc:a460dc01e76ca23d2b7f2594d921fb42e inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>filter</em> as a prerequisite to this handler.  <br /></td></tr>
<tr class="separator:a460dc01e76ca23d2b7f2594d921fb42e inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95a6dbd09026a988eb3a63ac3046f59 inherit pub_methods_classBHandler" id="r_aa95a6dbd09026a988eb3a63ac3046f59"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#aa95a6dbd09026a988eb3a63ac3046f59">RemoveFilter</a> (<a class="el" href="classBMessageFilter.html">BMessageFilter</a> *filter)</td></tr>
<tr class="memdesc:aa95a6dbd09026a988eb3a63ac3046f59 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <em>filter</em> from the filter list.  <br /></td></tr>
<tr class="separator:aa95a6dbd09026a988eb3a63ac3046f59 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c4577b69ab1af8960477df31573757 inherit pub_methods_classBHandler" id="r_a52c4577b69ab1af8960477df31573757"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a52c4577b69ab1af8960477df31573757">SetFilterList</a> (<a class="el" href="classBList.html">BList</a> *filters)</td></tr>
<tr class="memdesc:a52c4577b69ab1af8960477df31573757 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal list of filters to <em>filters</em>.  <br /></td></tr>
<tr class="separator:a52c4577b69ab1af8960477df31573757 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909662a049856f6863a934cf18161554 inherit pub_methods_classBHandler" id="r_a909662a049856f6863a934cf18161554"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBList.html">BList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a909662a049856f6863a934cf18161554">FilterList</a> ()</td></tr>
<tr class="memdesc:a909662a049856f6863a934cf18161554 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the list of filters.  <br /></td></tr>
<tr class="separator:a909662a049856f6863a934cf18161554 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d64bf66b4914918e24390d117e83477 inherit pub_methods_classBHandler" id="r_a9d64bf66b4914918e24390d117e83477"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a9d64bf66b4914918e24390d117e83477">LockLooper</a> ()</td></tr>
<tr class="memdesc:a9d64bf66b4914918e24390d117e83477 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the looper associated with this handler.  <br /></td></tr>
<tr class="separator:a9d64bf66b4914918e24390d117e83477 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0099ff6defcb6d64e3ee1c2fb47afe inherit pub_methods_classBHandler" id="r_afa0099ff6defcb6d64e3ee1c2fb47afe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#afa0099ff6defcb6d64e3ee1c2fb47afe">LockLooperWithTimeout</a> (<a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a> timeout)</td></tr>
<tr class="memdesc:afa0099ff6defcb6d64e3ee1c2fb47afe inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the looper associated with this handler, with a time out value.  <br /></td></tr>
<tr class="separator:afa0099ff6defcb6d64e3ee1c2fb47afe inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab131af7eb7aa2b9eea3a11ac1bfd4c03 inherit pub_methods_classBHandler" id="r_ab131af7eb7aa2b9eea3a11ac1bfd4c03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#ab131af7eb7aa2b9eea3a11ac1bfd4c03">UnlockLooper</a> ()</td></tr>
<tr class="memdesc:ab131af7eb7aa2b9eea3a11ac1bfd4c03 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the looper.  <br /></td></tr>
<tr class="separator:ab131af7eb7aa2b9eea3a11ac1bfd4c03 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d600e33a0586af7444d9abc8500504 inherit pub_methods_classBHandler" id="r_af7d600e33a0586af7444d9abc8500504"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#af7d600e33a0586af7444d9abc8500504">StartWatching</a> (<a class="el" href="classBMessenger.html">BMessenger</a> target, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> what)</td></tr>
<tr class="memdesc:af7d600e33a0586af7444d9abc8500504 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe this handler to watch a specific state change of a <em>target</em>.  <br /></td></tr>
<tr class="separator:af7d600e33a0586af7444d9abc8500504 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d7c8d30e47fbb7590f10dea1f21166 inherit pub_methods_classBHandler" id="r_a58d7c8d30e47fbb7590f10dea1f21166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a58d7c8d30e47fbb7590f10dea1f21166">StartWatchingAll</a> (<a class="el" href="classBMessenger.html">BMessenger</a> target)</td></tr>
<tr class="memdesc:a58d7c8d30e47fbb7590f10dea1f21166 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe this handler to watch a <em>target</em> for all events.  <br /></td></tr>
<tr class="separator:a58d7c8d30e47fbb7590f10dea1f21166 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1f0d55b3dc7337058aba769b4e4f93 inherit pub_methods_classBHandler" id="r_a9d1f0d55b3dc7337058aba769b4e4f93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a9d1f0d55b3dc7337058aba769b4e4f93">StopWatching</a> (<a class="el" href="classBMessenger.html">BMessenger</a> target, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> what)</td></tr>
<tr class="memdesc:a9d1f0d55b3dc7337058aba769b4e4f93 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe this handler from watching a specific state.  <br /></td></tr>
<tr class="separator:a9d1f0d55b3dc7337058aba769b4e4f93 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199c167e0dcee95aa65d09435804b3d9 inherit pub_methods_classBHandler" id="r_a199c167e0dcee95aa65d09435804b3d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a199c167e0dcee95aa65d09435804b3d9">StopWatchingAll</a> (<a class="el" href="classBMessenger.html">BMessenger</a> target)</td></tr>
<tr class="memdesc:a199c167e0dcee95aa65d09435804b3d9 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe this handler from watching all states.  <br /></td></tr>
<tr class="separator:a199c167e0dcee95aa65d09435804b3d9 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20713ff6ee9df49a014f391374eaf689 inherit pub_methods_classBHandler" id="r_a20713ff6ee9df49a014f391374eaf689"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a20713ff6ee9df49a014f391374eaf689">StartWatching</a> (<a class="el" href="classBHandler.html">BHandler</a> *observer, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> what)</td></tr>
<tr class="memdesc:a20713ff6ee9df49a014f391374eaf689 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe an <em>observer</em> for a specific state change of this handler.  <br /></td></tr>
<tr class="separator:a20713ff6ee9df49a014f391374eaf689 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31927c51d89e0e3b3bf609a786ee6c3b inherit pub_methods_classBHandler" id="r_a31927c51d89e0e3b3bf609a786ee6c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a31927c51d89e0e3b3bf609a786ee6c3b">StartWatchingAll</a> (<a class="el" href="classBHandler.html">BHandler</a> *observer)</td></tr>
<tr class="memdesc:a31927c51d89e0e3b3bf609a786ee6c3b inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscribe an <em>observer</em> for a all state changes.  <br /></td></tr>
<tr class="separator:a31927c51d89e0e3b3bf609a786ee6c3b inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3544be491270f856a0af8d36ce02d78 inherit pub_methods_classBHandler" id="r_ad3544be491270f856a0af8d36ce02d78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#ad3544be491270f856a0af8d36ce02d78">StopWatching</a> (<a class="el" href="classBHandler.html">BHandler</a> *observer, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> what)</td></tr>
<tr class="memdesc:ad3544be491270f856a0af8d36ce02d78 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe an observer from watching a specific state.  <br /></td></tr>
<tr class="separator:ad3544be491270f856a0af8d36ce02d78 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9a424ce63f5932666094b6eadf10cf inherit pub_methods_classBHandler" id="r_a8b9a424ce63f5932666094b6eadf10cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a8b9a424ce63f5932666094b6eadf10cf">StopWatchingAll</a> (<a class="el" href="classBHandler.html">BHandler</a> *observer)</td></tr>
<tr class="memdesc:a8b9a424ce63f5932666094b6eadf10cf inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsubscribe an observer from watching all states.  <br /></td></tr>
<tr class="separator:a8b9a424ce63f5932666094b6eadf10cf inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fdc829a6e11c3fdc1d014216146f67 inherit pub_methods_classBHandler" id="r_a04fdc829a6e11c3fdc1d014216146f67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a04fdc829a6e11c3fdc1d014216146f67">SendNotices</a> (<a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> what, const <a class="el" href="classBMessage.html">BMessage</a> *notice=<a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>)</td></tr>
<tr class="memdesc:a04fdc829a6e11c3fdc1d014216146f67 inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a state change to the observers.  <br /></td></tr>
<tr class="separator:a04fdc829a6e11c3fdc1d014216146f67 inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581b84f0f067afa88768ce6a0c07f59f inherit pub_methods_classBHandler" id="r_a581b84f0f067afa88768ce6a0c07f59f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a581b84f0f067afa88768ce6a0c07f59f">IsWatched</a> () const</td></tr>
<tr class="memdesc:a581b84f0f067afa88768ce6a0c07f59f inherit pub_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any observers watching this handler.  <br /></td></tr>
<tr class="separator:a581b84f0f067afa88768ce6a0c07f59f inherit pub_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classBArchivable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classBArchivable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classBArchivable.html">BArchivable</a></td></tr>
<tr class="memitem:a66e6b947f092d32f287913a8c253290f inherit pub_methods_classBArchivable" id="r_a66e6b947f092d32f287913a8c253290f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBArchivable.html#a66e6b947f092d32f287913a8c253290f">BArchivable</a> ()</td></tr>
<tr class="memdesc:a66e6b947f092d32f287913a8c253290f inherit pub_methods_classBArchivable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Does nothing.  <br /></td></tr>
<tr class="separator:a66e6b947f092d32f287913a8c253290f inherit pub_methods_classBArchivable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4f0566f9659b03912a859077c27c89 inherit pub_methods_classBArchivable" id="r_aed4f0566f9659b03912a859077c27c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBArchivable.html#aed4f0566f9659b03912a859077c27c89">BArchivable</a> (<a class="el" href="classBMessage.html">BMessage</a> *from)</td></tr>
<tr class="memdesc:aed4f0566f9659b03912a859077c27c89 inherit pub_methods_classBArchivable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. Does important behind-the-scenes work in the unarchiving process.  <br /></td></tr>
<tr class="separator:aed4f0566f9659b03912a859077c27c89 inherit pub_methods_classBArchivable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1eb91b8fbaaee03b869b596f214fbe inherit pub_methods_classBArchivable" id="r_afc1eb91b8fbaaee03b869b596f214fbe"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBArchivable.html#afc1eb91b8fbaaee03b869b596f214fbe">~BArchivable</a> ()</td></tr>
<tr class="memdesc:afc1eb91b8fbaaee03b869b596f214fbe inherit pub_methods_classBArchivable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Does nothing.  <br /></td></tr>
<tr class="separator:afc1eb91b8fbaaee03b869b596f214fbe inherit pub_methods_classBArchivable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50bc278c3520b20c122161af96e8759 inherit pub_methods_classBArchivable" id="r_ac50bc278c3520b20c122161af96e8759"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBArchivable.html#ac50bc278c3520b20c122161af96e8759">AllArchived</a> (<a class="el" href="classBMessage.html">BMessage</a> *archive) const</td></tr>
<tr class="memdesc:ac50bc278c3520b20c122161af96e8759 inherit pub_methods_classBArchivable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method relating to the use of <code><a class="el" href="classBArchiver.html" title="A class that simplifies the archiving of complicated BArchivable hierarchies.">BArchiver</a></code>.  <br /></td></tr>
<tr class="separator:ac50bc278c3520b20c122161af96e8759 inherit pub_methods_classBArchivable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e3fe140b7f4a7b3718aada59fe05a3 inherit pub_methods_classBArchivable" id="r_a62e3fe140b7f4a7b3718aada59fe05a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBArchivable.html#a62e3fe140b7f4a7b3718aada59fe05a3">AllUnarchived</a> (const <a class="el" href="classBMessage.html">BMessage</a> *archive)</td></tr>
<tr class="memdesc:a62e3fe140b7f4a7b3718aada59fe05a3 inherit pub_methods_classBArchivable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method relating to the use of <code><a class="el" href="classBUnarchiver.html" title="A class that simplifies the unarchiving of complicated BArchivable hierarchies.">BUnarchiver</a></code>.  <br /></td></tr>
<tr class="separator:a62e3fe140b7f4a7b3718aada59fe05a3 inherit pub_methods_classBArchivable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1be73aad8e8fed41659b98633525e5b3" id="r_a1be73aad8e8fed41659b98633525e5b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBMessage.html">BMessage</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1be73aad8e8fed41659b98633525e5b3">MessageFromPort</a> (<a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a>=B_INFINITE_TIMEOUT)</td></tr>
<tr class="memdesc:a1be73aad8e8fed41659b98633525e5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook method to retrieve a message from the looper's port.  <br /></td></tr>
<tr class="separator:a1be73aad8e8fed41659b98633525e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Archiving</h2></td></tr>
<tr class="memitem:aad314758fd652fb48d61bcccab8b6ae3" id="r_aad314758fd652fb48d61bcccab8b6ae3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad314758fd652fb48d61bcccab8b6ae3">BLooper</a> (<a class="el" href="classBMessage.html">BMessage</a> *data)</td></tr>
<tr class="memdesc:aad314758fd652fb48d61bcccab8b6ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a looper from an archived message.  <br /></td></tr>
<tr class="separator:aad314758fd652fb48d61bcccab8b6ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7190112fd50257a847a6e915c3c0caf1" id="r_a7190112fd50257a847a6e915c3c0caf1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7190112fd50257a847a6e915c3c0caf1">Archive</a> (<a class="el" href="classBMessage.html">BMessage</a> *data, bool deep=true) const</td></tr>
<tr class="memdesc:a7190112fd50257a847a6e915c3c0caf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive a looper to a message.  <br /></td></tr>
<tr class="separator:a7190112fd50257a847a6e915c3c0caf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1afb903bea2608557f5b68b2f1dbc44" id="r_ad1afb903bea2608557f5b68b2f1dbc44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBArchivable.html">BArchivable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1afb903bea2608557f5b68b2f1dbc44">Instantiate</a> (<a class="el" href="classBMessage.html">BMessage</a> *data)</td></tr>
<tr class="memdesc:ad1afb903bea2608557f5b68b2f1dbc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to instantiate a looper from an archived message.  <br /></td></tr>
<tr class="separator:ad1afb903bea2608557f5b68b2f1dbc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Loop Control</h2></td></tr>
<tr class="memitem:aa3cd8c0157e62be6c3e3a757efac0a4c" id="r_aa3cd8c0157e62be6c3e3a757efac0a4c"><td class="memItemLeft" align="right" valign="top">virtual thread_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3cd8c0157e62be6c3e3a757efac0a4c">Run</a> ()</td></tr>
<tr class="memdesc:aa3cd8c0157e62be6c3e3a757efac0a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the event loop.  <br /></td></tr>
<tr class="separator:aa3cd8c0157e62be6c3e3a757efac0a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a70c8e4d65a5b144ca6bfc20bcc35d" id="r_a81a70c8e4d65a5b144ca6bfc20bcc35d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81a70c8e4d65a5b144ca6bfc20bcc35d">Loop</a> ()</td></tr>
<tr class="memdesc:a81a70c8e4d65a5b144ca6bfc20bcc35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the event loop in the current thread.  <br /></td></tr>
<tr class="separator:a81a70c8e4d65a5b144ca6bfc20bcc35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01e29f7083d0f7b678b429348024167" id="r_af01e29f7083d0f7b678b429348024167"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af01e29f7083d0f7b678b429348024167">Quit</a> ()</td></tr>
<tr class="memdesc:af01e29f7083d0f7b678b429348024167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook method that is called after a <code>B_QUIT_REQUESTED</code> message.  <br /></td></tr>
<tr class="separator:af01e29f7083d0f7b678b429348024167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ddcbce40cde09e03fa2f96770b3669" id="r_ad3ddcbce40cde09e03fa2f96770b3669"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3ddcbce40cde09e03fa2f96770b3669">QuitRequested</a> ()</td></tr>
<tr class="memdesc:ad3ddcbce40cde09e03fa2f96770b3669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hook method that is called during a <code>B_QUIT_REQUESTED</code> message.  <br /></td></tr>
<tr class="separator:ad3ddcbce40cde09e03fa2f96770b3669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757a3e406ea3b7bb9a1ad16d04689b1d" id="r_a757a3e406ea3b7bb9a1ad16d04689b1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d">Lock</a> ()</td></tr>
<tr class="memdesc:a757a3e406ea3b7bb9a1ad16d04689b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the looper.  <br /></td></tr>
<tr class="separator:a757a3e406ea3b7bb9a1ad16d04689b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84ea15405640082b9fda58f6672467c" id="r_ac84ea15405640082b9fda58f6672467c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac84ea15405640082b9fda58f6672467c">Unlock</a> ()</td></tr>
<tr class="memdesc:ac84ea15405640082b9fda58f6672467c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock a locked looper.  <br /></td></tr>
<tr class="separator:ac84ea15405640082b9fda58f6672467c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525d6677c2fc76a84c2d48853dad142a" id="r_a525d6677c2fc76a84c2d48853dad142a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a525d6677c2fc76a84c2d48853dad142a">IsLocked</a> () const</td></tr>
<tr class="memdesc:a525d6677c2fc76a84c2d48853dad142a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a looper is locked.  <br /></td></tr>
<tr class="separator:a525d6677c2fc76a84c2d48853dad142a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734cdb06bfe92efdea24528c9b43bfc1" id="r_a734cdb06bfe92efdea24528c9b43bfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a734cdb06bfe92efdea24528c9b43bfc1">LockWithTimeout</a> (<a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a> timeout)</td></tr>
<tr class="memdesc:a734cdb06bfe92efdea24528c9b43bfc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock a looper with a <em>timeout</em>.  <br /></td></tr>
<tr class="separator:a734cdb06bfe92efdea24528c9b43bfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257d396d04d128edf7a0c9669ead36c0" id="r_a257d396d04d128edf7a0c9669ead36c0"><td class="memItemLeft" align="right" valign="top">thread_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a257d396d04d128edf7a0c9669ead36c0">Thread</a> () const</td></tr>
<tr class="memdesc:a257d396d04d128edf7a0c9669ead36c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread id of the internal message looper thread.  <br /></td></tr>
<tr class="separator:a257d396d04d128edf7a0c9669ead36c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb7a4900f26e7746d6c8bdb5cf684f3" id="r_afeb7a4900f26e7746d6c8bdb5cf684f3"><td class="memItemLeft" align="right" valign="top">team_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeb7a4900f26e7746d6c8bdb5cf684f3">Team</a> () const</td></tr>
<tr class="memdesc:afeb7a4900f26e7746d6c8bdb5cf684f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the team id in which this looper exists.  <br /></td></tr>
<tr class="separator:afeb7a4900f26e7746d6c8bdb5cf684f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbde1d8a442d87601a7a1b92520b4082" id="r_abbde1d8a442d87601a7a1b92520b4082"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBLooper.html">BLooper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbde1d8a442d87601a7a1b92520b4082">LooperForThread</a> (thread_id thread)</td></tr>
<tr class="memdesc:abbde1d8a442d87601a7a1b92520b4082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to retrieve a <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> for a specified <em>thread</em>.  <br /></td></tr>
<tr class="separator:abbde1d8a442d87601a7a1b92520b4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classBHandler"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classBHandler')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classBHandler.html">BHandler</a></td></tr>
<tr class="memitem:a862d9cba443baf8503de52c5e660c1b4 inherit pub_static_methods_classBHandler" id="r_a862d9cba443baf8503de52c5e660c1b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBArchivable.html">BArchivable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBHandler.html#a862d9cba443baf8503de52c5e660c1b4">Instantiate</a> (<a class="el" href="classBMessage.html">BMessage</a> *data)</td></tr>
<tr class="memdesc:a862d9cba443baf8503de52c5e660c1b4 inherit pub_static_methods_classBHandler"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to instantiate a handler from an archived message.  <br /></td></tr>
<tr class="separator:a862d9cba443baf8503de52c5e660c1b4 inherit pub_static_methods_classBHandler"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classBArchivable"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classBArchivable')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classBArchivable.html">BArchivable</a></td></tr>
<tr class="memitem:a04efcb17fa2a64a776923cc12303efcd inherit pub_static_methods_classBArchivable" id="r_a04efcb17fa2a64a776923cc12303efcd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classBArchivable.html">BArchivable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBArchivable.html#a04efcb17fa2a64a776923cc12303efcd">Instantiate</a> (<a class="el" href="classBMessage.html">BMessage</a> *archive)</td></tr>
<tr class="memdesc:a04efcb17fa2a64a776923cc12303efcd inherit pub_static_methods_classBArchivable"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static member to restore objects from messages.  <br /></td></tr>
<tr class="separator:a04efcb17fa2a64a776923cc12303efcd inherit pub_static_methods_classBArchivable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Receive and process messages in a separate thread. </p>
<p>When an object of this class is created, the message loop can be started with <a class="el" href="#aa3cd8c0157e62be6c3e3a757efac0a4c" title="Start the event loop.">Run()</a>. This spawns the thread that receives messages and processes messages. Messages are actually passed on to <a class="el" href="classBHandler.html">handlers </a> that are associated with this looper. By default there is always one handler available: the looper itself. To 'quit' a looper, you should pass a <code>B_QUIT_REQUESTED</code> message using one of the message post functions. When a looper receives such a request, it will <b>delete</b> itself. As such, looper should <em>always be created on the heap</em> (with <code>new</code>), and never on the stack.</p>
<p>Posting messages can be done using the various <a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e" title="Post a message with the command as what identifier to this looper.">PostMessage()</a> methods. Whenever a message is posted, it will be added through to the message queue. It is possible to apply filters (see <a class="el" href="#a422da6a77838f4ed6efd1b8a2e3df5fc" title="Add a common filter to the list of filters that are applied to all incoming messages.">AddCommonFilter()</a>) to filter out any messages that correspond with certain criteria. The method will copy the contents of the message and this copy is processed, so make sure you delete the original messages in case you create them on the heap. The handler for the message is chosen using the following criteria:</p>
<ol type="1">
<li>If <a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e" title="Post a message with the command as what identifier to this looper.">PostMessage()</a> or the <a class="el" href="classBMessenger.html" title="A class to send messages to a target BLooper or BHandler.">BMessenger</a> is set to a specific handler, and this handler is associated with this looper, than the message is processed by that handler.</li>
<li>Else, the preferred handler is used. You can set this using <a class="el" href="#a07c6e5c65354b48465fde2b0b44e22c6" title="Set a preferred handler.">SetPreferredHandler()</a>.</li>
<li>If there is no preferred handler, then the looper itself will process the message.</li>
</ol>
<p>Because a looper usually is used in multiple threads, you should make sure you <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> and <a class="el" href="#ac84ea15405640082b9fda58f6672467c" title="Unlock a locked looper.">Unlock()</a> it during most operations. Locking calls can be recursive (so multiple locks can come from a single thread), but make sure you pair every <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> with an <a class="el" href="#ac84ea15405640082b9fda58f6672467c" title="Unlock a locked looper.">Unlock()</a> call. Failing to do so will inevitably cause a deadlock.</p>
<p>Because a looper provides a separate thread, and the inherited handler is usually a default handler, you will most often use this class by subclassing it. For example, you are likely to subclass <a class="el" href="classBWindow.html" title="Window base class.">BWindow</a> (which is derived from <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a>) to customize your window and handle the messages sent to that window. You can override <a class="el" href="#aa3cd8c0157e62be6c3e3a757efac0a4c" title="Start the event loop.">Run()</a> in case you want to perform additional tasks before (or right after) starting the message loop. You can override <a class="el" href="#ad3ddcbce40cde09e03fa2f96770b3669" title="Hook method that is called during a B_QUIT_REQUESTED message.">QuitRequested()</a> if you want to decline quitting in certain circumstances. You can override <a class="el" href="#af01e29f7083d0f7b678b429348024167" title="Hook method that is called after a B_QUIT_REQUESTED message.">Quit()</a> in case you want to perform additional procedures during closing time. You can also override <a class="el" href="#abb9ffb64420b2fafc0764e74c5be7a6c" title="Dispatch a message to a handler. Override if there are messages that you want to catch before they ar...">DispatchMessage()</a> if you want to do something with all incoming messages before they are dispatched to a handler.</p>
<p><a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> is one of the major base classes of the Haiku application programmers interface. Closely related classes are <a class="el" href="classBMessage.html" title="A container that can be send and received using the Haiku messaging subsystem.">BMessage</a>, <a class="el" href="classBHandler.html" title="Handles messages that are passed on by a BLooper.">BHandler</a> and <a class="el" href="classBMessenger.html" title="A class to send messages to a target BLooper or BHandler.">BMessenger</a>. It is used in the interface kit, for example by the <a class="el" href="classBWindow.html" title="Window base class.">BWindow</a> class, which makes sure every window runs it its own thread.</p>
<p><a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> is a part of the chain in the eloquent messaging structure. For a proper understanding of all its facets, have a look at the <a class="el" href="app_messaging.html">messaging overview</a>.</p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a33fa84a6ed383e5a897d11380d72ce38" name="a33fa84a6ed383e5a897d11380d72ce38"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/BLooper" class="dashAnchor">&nbsp;</a><a href="#a33fa84a6ed383e5a897d11380d72ce38">&#9670;&#160;</a></span>BLooper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BLooper::BLooper </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span><span class="paramdefsep"> = </span><span class="paramdefval">B_NORMAL_PRIORITY</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>portCapacity</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Looper_8h.html#a7e8948687d8c2652df30af6c9eba4ab4">B_LOOPER_PORT_DEFAULT_CAPACITY</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> with a <em>priority</em> and an <em>capacity</em>. </p>
<p>The new looper is, by default, not running yet. If you have set up everything properly, you may call <a class="el" href="#aa3cd8c0157e62be6c3e3a757efac0a4c" title="Start the event loop.">Run()</a>.</p>
<dl class="section attention"><dt>Attention</dt><dd>Remember that loopers should be created on the heap, because they will <code>delete</code> themselves in the <a class="el" href="#af01e29f7083d0f7b678b429348024167" title="Hook method that is called after a B_QUIT_REQUESTED message.">Quit()</a> method.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the looper. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the message thread of this looper. The default priority should be good enough for most tasks. Also, some derived versions of <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> will use a specialized priority. So it is advised to leave this setting at the default, unless you know why you would like another setting. </td></tr>
    <tr><td class="paramname">portCapacity</td><td>Loopers use ports to send and receive messages (see the kernel kit). Ports have a maximum capacity; if there are so many messages queued that the port is full, all other incoming messages are dropped. There are situations where the size of the port should be different from the default. This might be when your looper receives a lot of messages, or if the message handling thread runs at a lower priority than normal, which would decrease the processing speed. Finding a suitable value for these custom scenarios would be done by testing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa3cd8c0157e62be6c3e3a757efac0a4c" title="Start the event loop.">Run()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a717b08ea49bcc73037b6d8675e94c9be" name="a717b08ea49bcc73037b6d8675e94c9be"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/~BLooper" class="dashAnchor">&nbsp;</a><a href="#a717b08ea49bcc73037b6d8675e94c9be">&#9670;&#160;</a></span>~BLooper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual BLooper::~BLooper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the looper. </p>
<p>You will never delete a looper yourself. You should pass a <code>B_QUIT_REQUESTED</code> message, or if you are destroying the looper from inside its own message handling thread, you should call <a class="el" href="#af01e29f7083d0f7b678b429348024167" title="Hook method that is called after a B_QUIT_REQUESTED message.">Quit()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af01e29f7083d0f7b678b429348024167" title="Hook method that is called after a B_QUIT_REQUESTED message.">Quit()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="aad314758fd652fb48d61bcccab8b6ae3" name="aad314758fd652fb48d61bcccab8b6ae3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/BLooper" class="dashAnchor">&nbsp;</a><a href="#aad314758fd652fb48d61bcccab8b6ae3">&#9670;&#160;</a></span>BLooper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BLooper::BLooper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a looper from an archived message. </p>
<p>The <em>data</em> message has to be constructed by a <a class="el" href="#a7190112fd50257a847a6e915c3c0caf1" title="Archive a looper to a message.">BLooper::Archive()</a> call. Note that the data that is restored, is merely the port capacity and the name of the looper/handler. Other data, such as filters, is not archived by the default archiver.</p>
<dl class="section warning"><dt>Warning</dt><dd>This constructor does no type check whatsoever. Since you can pass any <a class="el" href="classBMessage.html" title="A container that can be send and received using the Haiku messaging subsystem.">BMessage</a>, you should - if you are not sure about the exact type - use the <a class="el" href="#ad1afb903bea2608557f5b68b2f1dbc44" title="Static method to instantiate a looper from an archived message.">Instantiate()</a> method, which does check the type.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad1afb903bea2608557f5b68b2f1dbc44" title="Static method to instantiate a looper from an archived message.">Instantiate()</a> </dd>
<dd>
<a class="el" href="#a7190112fd50257a847a6e915c3c0caf1" title="Archive a looper to a message.">Archive()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a422da6a77838f4ed6efd1b8a2e3df5fc" name="a422da6a77838f4ed6efd1b8a2e3df5fc"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/AddCommonFilter" class="dashAnchor">&nbsp;</a><a href="#a422da6a77838f4ed6efd1b8a2e3df5fc">&#9670;&#160;</a></span>AddCommonFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BLooper::AddCommonFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessageFilter.html">BMessageFilter</a> *</td>          <td class="paramname"><span class="paramname"><em>filter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a common filter to the list of filters that are applied to all incoming messages. </p>
<p>Filters can only be applied once, so they cannot be shared between loopers, a handler and a looper or between two handlers.</p>
<p>The <em>filter</em> is not copied; rather a pointer is stored. Keep the <em>filter</em> alive as long as it is used by a looper.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#add9a19d7b52ea4838ab757b8ba7f4ebe" title="Remove a filter from the common message filter list.">RemoveCommonFilter()</a> </dd>
<dd>
<a class="el" href="#ae539e5548714a9acdd071e7126fe953c" title="Set a new list of filters that need to be applied to all incoming messages.">SetCommonFilterList()</a> </dd>
<dd>
<a class="el" href="#ad64f1a98c1cce8087e7d492860461a62" title="Return a list of filters applied to all incoming messages.">CommonFilterList()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a484be74814014e3c48c1a16f44e34074" name="a484be74814014e3c48c1a16f44e34074"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/AddHandler" class="dashAnchor">&nbsp;</a><a href="#a484be74814014e3c48c1a16f44e34074">&#9670;&#160;</a></span>AddHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BLooper::AddHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Associate a <em>handler</em> to this looper. </p>
<p>The <em>handler</em> will be associated to this looper. By default, the handler in this looper will be chained to the supplied <em>handler</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to associate with this looper. If the handler is already associated to another looper, the operation will fail silently. Check beforehand if you cannot be sure that the <em>handler</em> is unassociated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a5af57140bf018388a2e64343f46ac330" title="Disassociate a handler from this looper.">RemoveHandler()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a7190112fd50257a847a6e915c3c0caf1" name="a7190112fd50257a847a6e915c3c0caf1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Archive" class="dashAnchor">&nbsp;</a><a href="#a7190112fd50257a847a6e915c3c0caf1">&#9670;&#160;</a></span>Archive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::Archive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>deep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Archive a looper to a message. </p>
<p>Currently, only the name and the port capacity are archived. Any other data, such as the filters, is not stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The message to archive the object in. </td></tr>
    <tr><td class="paramname">deep</td><td>This parameter is ignored, as <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> does not have children.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>Archiving succeeded. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>The <em>data</em> parameter is not a valid message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ad1afb903bea2608557f5b68b2f1dbc44" title="Static method to instantiate a looper from an archived message.">BLooper::Instantiate(BMessage* data)</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

<p>Reimplemented from <a class="el" href="classBHandler.html#ad6079ebf818a62842cbfbf2622b5f149">BHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classBAlert.html#af8e93c8af44acfbfe7c792c326de8535">BAlert</a>, <a class="el" href="classBApplication.html#a81f1872b248bc1412ddb493284123c14">BApplication</a>, <a class="el" href="classBDirectWindow.html#a290c835cba0a9d039118104a5351dd0f">BDirectWindow</a>, and <a class="el" href="classBWindow.html#ac36ad95173ef6ec1c98667c730cf6de3">BWindow</a>.</p>

</div>
</div>
<a id="ad64f1a98c1cce8087e7d492860461a62" name="ad64f1a98c1cce8087e7d492860461a62"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/CommonFilterList" class="dashAnchor">&nbsp;</a><a href="#ad64f1a98c1cce8087e7d492860461a62">&#9670;&#160;</a></span>CommonFilterList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBList.html">BList</a> * BLooper::CommonFilterList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of filters applied to all incoming messages. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal filter list, or <code>NULL</code> if such a list has not yet been created. Please note that you should use the internal list management functions to manipulate the internal filter list, in order to maintain internal consistency.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a422da6a77838f4ed6efd1b8a2e3df5fc" title="Add a common filter to the list of filters that are applied to all incoming messages.">AddCommonFilter()</a> </dd>
<dd>
<a class="el" href="#add9a19d7b52ea4838ab757b8ba7f4ebe" title="Remove a filter from the common message filter list.">RemoveCommonFilter()</a> </dd>
<dd>
<a class="el" href="#ae539e5548714a9acdd071e7126fe953c" title="Set a new list of filters that need to be applied to all incoming messages.">SetCommonFilterList()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a6179629238d0be92d7a89503be24d4e3" name="a6179629238d0be92d7a89503be24d4e3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/CountHandlers" class="dashAnchor">&nbsp;</a><a href="#a6179629238d0be92d7a89503be24d4e3">&#9670;&#160;</a></span>CountHandlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> BLooper::CountHandlers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of handlers associated with this looper. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6976132123edacf4b3a2831eadf5f4bf" title="Get the handler at an index of the list of associated handlers.">HandlerAt()</a> </dd>
<dd>
<a class="el" href="#a3061534f6d2f3186efca4cddd19f378f" title="Get the index of the handler that is in the associated handler list.">IndexOf()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a64e7b89294df1f7b614d1267f870ecd9" name="a64e7b89294df1f7b614d1267f870ecd9"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/CountLockRequests" class="dashAnchor">&nbsp;</a><a href="#a64e7b89294df1f7b614d1267f870ecd9">&#9670;&#160;</a></span>CountLockRequests()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> BLooper::CountLockRequests </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of pending locks. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a4eec703acd9bd7fe9a455af0f81e08f9" name="a4eec703acd9bd7fe9a455af0f81e08f9"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/CountLocks" class="dashAnchor">&nbsp;</a><a href="#a4eec703acd9bd7fe9a455af0f81e08f9">&#9670;&#160;</a></span>CountLocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> BLooper::CountLocks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of recursive locks that are currently being held on this looper. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a6d244af065c4a12ea795bbbc7bb20e07" name="a6d244af065c4a12ea795bbbc7bb20e07"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/CurrentMessage" class="dashAnchor">&nbsp;</a><a href="#a6d244af065c4a12ea795bbbc7bb20e07">&#9670;&#160;</a></span>CurrentMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBMessage.html">BMessage</a> * BLooper::CurrentMessage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current message. </p>
<dl class="section attention"><dt>Attention</dt><dd>Only call this method from within the thread that processes the messages. It contains a pointer to the message that is currently being handled. Due to the multithreaded nature of the operating system, this method will not safely let you read the message that is being processed by this handler from outside the context of the processing. If you do want to use a message outside of the processing thread, have a look at <a class="el" href="#a7c8f05bcc354bc1d53026417417120e3" title="Get ownership of the message currently being processed.">DetachCurrentMessage()</a> to safely retrieve a message.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the message that is currently being processed. Note that calling it from outside the thread that processes the message, could give you a <code>NULL</code> pointer or an invalid pointer.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a7c8f05bcc354bc1d53026417417120e3" name="a7c8f05bcc354bc1d53026417417120e3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/DetachCurrentMessage" class="dashAnchor">&nbsp;</a><a href="#a7c8f05bcc354bc1d53026417417120e3">&#9670;&#160;</a></span>DetachCurrentMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBMessage.html">BMessage</a> * BLooper::DetachCurrentMessage </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ownership of the message currently being processed. </p>
<p>Retrieve the current message and gain ownership of it. This means that the message will not be deleted as soon as the looper is done processing it. You can then use it for different purposes.</p>
<dl class="section attention"><dt>Attention</dt><dd>Only call this method from within the thread that processes the messages. Due to the multithreaded nature of the operating system, calling it from another thread is very likely to give you an invalid or a <code>NULL</code> pointer.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a3a2d3773466de19a6c117f3a04861b11" name="a3a2d3773466de19a6c117f3a04861b11"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/DispatchExternalMessage" class="dashAnchor">&nbsp;</a><a href="#a3a2d3773466de19a6c117f3a04861b11">&#9670;&#160;</a></span>DispatchExternalMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BLooper::DispatchExternalMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>_detached</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method to support single-threaded GUI toolkits. </p>
<dl class="section since"><dt>Since</dt><dd>Haiku R1 </dd></dl>

</div>
</div>
<a id="abb9ffb64420b2fafc0764e74c5be7a6c" name="abb9ffb64420b2fafc0764e74c5be7a6c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/DispatchMessage" class="dashAnchor">&nbsp;</a><a href="#abb9ffb64420b2fafc0764e74c5be7a6c">&#9670;&#160;</a></span>DispatchMessage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BLooper::DispatchMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch a message to a handler. Override if there are messages that you want to catch before they are sent to the handlers. </p>
<p>This method is called by the message looping thread to dispatch a message to <em>handler</em>. If you implement the <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> class and your looper receives messages that absolutely have to be processed by the looper instead of any of the handlers, override this method. For example, the default implementation catches B_QUIT_REQUESTED messages before they are sent to the handlers, so that the looper will quit at those messages.</p>
<p>You are discouraged from using this method to filter out any messages you do not want to process. For this, there is a more generic method using the <a class="el" href="classBMessageFilter.html" title="Describes a message filter for BLooper and BHandler.">BMessageFilter</a> class. If you want to skip messages with certain patterns, have a look at the <a class="el" href="#a422da6a77838f4ed6efd1b8a2e3df5fc" title="Add a common filter to the list of filters that are applied to all incoming messages.">AddCommonFilter()</a> and <a class="el" href="#ae539e5548714a9acdd071e7126fe953c" title="Set a new list of filters that need to be applied to all incoming messages.">SetCommonFilterList()</a> methods.</p>
<p>If you do override this method, please remember to call the <a class="el" href="#abb9ffb64420b2fafc0764e74c5be7a6c" title="Dispatch a message to a handler. Override if there are messages that you want to catch before they ar...">DispatchMessage()</a> method of the parent class.</p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

<p>Reimplemented in <a class="el" href="classBAlert.html#a7039b495b69f4f85ec3618818f1016f2">BAlert</a>, <a class="el" href="classBApplication.html#aa1a49b90be8b3714a7816bd30342548f">BApplication</a>, <a class="el" href="classBDirectWindow.html#a62952e05d331dde0b091998db878a9f6">BDirectWindow</a>, and <a class="el" href="classBWindow.html#a82b47a1b40ac8a049c1465f889e2d69a">BWindow</a>.</p>

</div>
</div>
<a id="a87b759aee92031b41e08669645a3abe3" name="a87b759aee92031b41e08669645a3abe3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/GetSupportedSuites" class="dashAnchor">&nbsp;</a><a href="#a87b759aee92031b41e08669645a3abe3">&#9670;&#160;</a></span>GetSupportedSuites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::GetSupportedSuites </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports the suites of messages and specifiers that derived classes understand. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3    </dd></dl>

<p>Reimplemented from <a class="el" href="classBHandler.html#af227402e48922a459011d0fee3a55c3a">BHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classBAlert.html#a7e0b44aca50b75ca9815eb7d4bcc1fae">BAlert</a>, <a class="el" href="classBApplication.html#a2c49c7394cdfeaf70be9ef2241daf1b6">BApplication</a>, <a class="el" href="classBDirectWindow.html#a55e920fcba8972f5173bd3714f416c13">BDirectWindow</a>, and <a class="el" href="classBWindow.html#a8b130c75c6221f06231acb7553811786">BWindow</a>.</p>

</div>
</div>
<a id="a6976132123edacf4b3a2831eadf5f4bf" name="a6976132123edacf4b3a2831eadf5f4bf"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/HandlerAt" class="dashAnchor">&nbsp;</a><a href="#a6976132123edacf4b3a2831eadf5f4bf">&#9670;&#160;</a></span>HandlerAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBHandler.html">BHandler</a> * BLooper::HandlerAt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the handler at an <em>index</em> of the list of associated handlers. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the handler at that <em>index</em>, or <code>NULL</code> if the <em>index</em> is out of range.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a6179629238d0be92d7a89503be24d4e3" title="Get the number of handlers associated with this looper.">CountHandlers()</a> </dd>
<dd>
<a class="el" href="#a3061534f6d2f3186efca4cddd19f378f" title="Get the index of the handler that is in the associated handler list.">IndexOf()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a3061534f6d2f3186efca4cddd19f378f" name="a3061534f6d2f3186efca4cddd19f378f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/IndexOf" class="dashAnchor">&nbsp;</a><a href="#a3061534f6d2f3186efca4cddd19f378f">&#9670;&#160;</a></span>IndexOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> BLooper::IndexOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the <em>handler</em> that is in the associated handler list. </p>
<dl class="section return"><dt>Returns</dt><dd>The index of the handler in the list if the <em>handler</em> is in the list, else this method will return -1.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="ad1afb903bea2608557f5b68b2f1dbc44" name="ad1afb903bea2608557f5b68b2f1dbc44"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Instantiate" class="dashAnchor">&nbsp;</a><a href="#ad1afb903bea2608557f5b68b2f1dbc44">&#9670;&#160;</a></span>Instantiate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBArchivable.html">BArchivable</a> * BLooper::Instantiate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method to instantiate a looper from an archived message. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the instantiated looper, or <code>NULL</code> if the <em>data</em> is not a valid archived <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aad314758fd652fb48d61bcccab8b6ae3" title="Construct a looper from an archived message.">BLooper(BMessage* data)</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a525d6677c2fc76a84c2d48853dad142a" name="a525d6677c2fc76a84c2d48853dad142a"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/IsLocked" class="dashAnchor">&nbsp;</a><a href="#a525d6677c2fc76a84c2d48853dad142a">&#9670;&#160;</a></span>IsLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BLooper::IsLocked </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a looper is locked. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the looper is locked, <code>false</code> if the looper is not locked, or the looper has been deleted.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> </dd>
<dd>
<a class="el" href="#ac84ea15405640082b9fda58f6672467c" title="Unlock a locked looper.">Unlock()</a> </dd>
<dd>
<a class="el" href="#a734cdb06bfe92efdea24528c9b43bfc1" title="Lock a looper with a timeout.">LockWithTimeout()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a27fd22b9eeaeadbeff1e973ed5242a64" name="a27fd22b9eeaeadbeff1e973ed5242a64"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/IsMessageWaiting" class="dashAnchor">&nbsp;</a><a href="#a27fd22b9eeaeadbeff1e973ed5242a64">&#9670;&#160;</a></span>IsMessageWaiting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BLooper::IsMessageWaiting </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there is a message waiting. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there are still messages to be processed, <code>false</code> if there is no message waiting. </dd></dl>

</div>
</div>
<a id="a757a3e406ea3b7bb9a1ad16d04689b1d" name="a757a3e406ea3b7bb9a1ad16d04689b1d"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Lock" class="dashAnchor">&nbsp;</a><a href="#a757a3e406ea3b7bb9a1ad16d04689b1d">&#9670;&#160;</a></span>Lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BLooper::Lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock the looper. </p>
<p>For most operations involving the internal data of the looper, you need to hold the lock. Each looper implements a global lock, which you can use to perform operations on internal data in a thread-safe manner.</p>
<p>Do not forget to pair each <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> request with an <a class="el" href="#ac84ea15405640082b9fda58f6672467c" title="Unlock a locked looper.">Unlock()</a> request. <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> requests can be stacked, which means that recursively locking a looper from a thread that actually holds the lock, will not cause a deadlock. See <a class="el" href="classBLocker.html" title="Semaphore-type class for thread safety.">BLocker</a> for more information on locking internals.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the locking request succeeded, <code>false</code> if the locking request could not be completed. There are a variety of reasons for this to happen, for example when the looper is destroyed.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ac84ea15405640082b9fda58f6672467c" title="Unlock a locked looper.">Unlock()</a> </dd>
<dd>
<a class="el" href="#a734cdb06bfe92efdea24528c9b43bfc1" title="Lock a looper with a timeout.">LockWithTimeout()</a> </dd>
<dd>
<a class="el" href="#a525d6677c2fc76a84c2d48853dad142a" title="Check if a looper is locked.">IsLocked()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

<p class="reference">Referenced by <a class="el" href="classBAutolock.html#a5808a41f3c76294ed35deef3864c9a7c">BAutolock::Lock()</a>.</p>

</div>
</div>
<a id="a1d5d9dbc9d890ed1329b69fbfe9254b3" name="a1d5d9dbc9d890ed1329b69fbfe9254b3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/LockingThread" class="dashAnchor">&nbsp;</a><a href="#a1d5d9dbc9d890ed1329b69fbfe9254b3">&#9670;&#160;</a></span>LockingThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_id BLooper::LockingThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread id of the thread that currently holds the lock. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a734cdb06bfe92efdea24528c9b43bfc1" name="a734cdb06bfe92efdea24528c9b43bfc1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/LockWithTimeout" class="dashAnchor">&nbsp;</a><a href="#a734cdb06bfe92efdea24528c9b43bfc1">&#9670;&#160;</a></span>LockWithTimeout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::LockWithTimeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a></td>          <td class="paramname"><span class="paramname"><em>timeout</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lock a looper with a <em>timeout</em>. </p>
<p>This method locks the looper like <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a>, but if the locking request does not succeed within the provided <em>timeout</em>, the method will return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>The maximum time to wait for the lock request to succeed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The lock is acquired. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>The looper has been destroyed. </td></tr>
    <tr><td class="paramname">other errors</td><td>There was an error acquiring the lock.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> </dd>
<dd>
<a class="el" href="#ac84ea15405640082b9fda58f6672467c" title="Unlock a locked looper.">Unlock()</a> </dd>
<dd>
<a class="el" href="#a525d6677c2fc76a84c2d48853dad142a" title="Check if a looper is locked.">IsLocked()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a81a70c8e4d65a5b144ca6bfc20bcc35d" name="a81a70c8e4d65a5b144ca6bfc20bcc35d"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Loop" class="dashAnchor">&nbsp;</a><a href="#a81a70c8e4d65a5b144ca6bfc20bcc35d">&#9670;&#160;</a></span>Loop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BLooper::Loop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the event loop in the current thread. </p>
<p>This method runs the event loop in an already existing thread. It blocks until the looper stops looping. This can be used to turn an existing thread into a <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a>.</p>
<p>Make sure the looper is not yet running before you call this method.</p>
<dl class="section since"><dt>Since</dt><dd>Haiku R1 </dd></dl>

</div>
</div>
<a id="abbde1d8a442d87601a7a1b92520b4082" name="abbde1d8a442d87601a7a1b92520b4082"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/LooperForThread" class="dashAnchor">&nbsp;</a><a href="#abbde1d8a442d87601a7a1b92520b4082">&#9670;&#160;</a></span>LooperForThread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classBLooper.html">BLooper</a> * BLooper::LooperForThread </td>
          <td>(</td>
          <td class="paramtype">thread_id</td>          <td class="paramname"><span class="paramname"><em>thread</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static method to retrieve a <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a> for a specified <em>thread</em>. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a1be73aad8e8fed41659b98633525e5b3" name="a1be73aad8e8fed41659b98633525e5b3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/MessageFromPort" class="dashAnchor">&nbsp;</a><a href="#a1be73aad8e8fed41659b98633525e5b3">&#9670;&#160;</a></span>MessageFromPort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBMessage.html">BMessage</a> * BLooper::MessageFromPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a></td>          <td class="paramname"><span class="paramname"><em>timeout</em></span><span class="paramdefsep"> = </span><span class="paramdefval">B_INFINITE_TIMEOUT</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook method to retrieve a message from the looper's port. </p>
<p>The default implementation is called by the internal message looping thread and retrieves the next message from the port that belongs to this looper.</p>
<p>If you use a looper in a context where it might receive messages from other sources, you can override this method in order to insert these methods into the message processing. Note that any messages that are returned by this method will be deleted by this looper, so make sure you have ownership of the message. If you override this method, remember to call the base implementation every now and then, in order to retrieve the messages arriving at the default port.</p>
<dl class="section since"><dt>Since</dt><dd>Haiku R1 </dd></dl>

</div>
</div>
<a id="ad0643973ceda5cca540c4684a9f670ac" name="ad0643973ceda5cca540c4684a9f670ac"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/MessageQueue" class="dashAnchor">&nbsp;</a><a href="#ad0643973ceda5cca540c4684a9f670ac">&#9670;&#160;</a></span>MessageQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBMessageQueue.html">BMessageQueue</a> * BLooper::MessageQueue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the internal message queue of this looper. </p>
<p>You can use this pointer to manipulate the message queue. Note that the message that is being processed is already detached from this queue.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the internal message queue.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a1ef10bd4264968869ead521b7ab699ff" name="a1ef10bd4264968869ead521b7ab699ff"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/MessageReceived" class="dashAnchor">&nbsp;</a><a href="#a1ef10bd4264968869ead521b7ab699ff">&#9670;&#160;</a></span>MessageReceived()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BLooper::MessageReceived </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process a message received by the internal handler of this looper. </p>
<p>Reimplemented from <a class="el" href="classBHandler.html#ad1a01c261caed651252055be49c410b9" title="Handle message that has been received by the associated looper.">BHandler::MessageReceived()</a>;</p>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

<p>Reimplemented from <a class="el" href="classBHandler.html#ad1a01c261caed651252055be49c410b9">BHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classBAlert.html#a75812107eab8761def2148ce4df168e8">BAlert</a>, <a class="el" href="classBApplication.html#af978710633d1bb201b2a5c60adbb0b61">BApplication</a>, <a class="el" href="classBDirectWindow.html#a1eb5e6dfeee341e9baf3d688ff66194a">BDirectWindow</a>, and <a class="el" href="classBWindow.html#ac19a2ece579b5ddd75e09274a1ec1b32">BWindow</a>.</p>

</div>
</div>
<a id="a1abbd10d6ac490fcb379cb3311e7f928" name="a1abbd10d6ac490fcb379cb3311e7f928"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Perform" class="dashAnchor">&nbsp;</a><a href="#a1abbd10d6ac490fcb379cb3311e7f928">&#9670;&#160;</a></span>Perform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::Perform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#ad2237b0064c91c237159edc020989bab">perform_code</a></td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method. </p>
<dl class="section since"><dt>Since</dt><dd>Haiku R1 </dd></dl>

<p>Reimplemented from <a class="el" href="classBHandler.html#a4e6ebc7ebcb72855a1f0fee7bde99766">BHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classBAlert.html#a3837c222cb22d157198a00926518cd9e">BAlert</a>, <a class="el" href="classBApplication.html#ab8fea9f4a96bdee62ce77a089d472973">BApplication</a>, <a class="el" href="classBDirectWindow.html#a113afd3534fca8b81bcc86f8e55738be">BDirectWindow</a>, and <a class="el" href="classBWindow.html#afde7d74e5526f740dedb82a1d10faa7a">BWindow</a>.</p>

</div>
</div>
<a id="ae79a7818ce950d8edcd238f7948df020" name="ae79a7818ce950d8edcd238f7948df020"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/PostMessage" class="dashAnchor">&nbsp;</a><a href="#ae79a7818ce950d8edcd238f7948df020">&#9670;&#160;</a></span>PostMessage() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::PostMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>message</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a <em>message</em> to this looper. </p>
<p>Posting a message puts it in the message queue. The message passes through the default handler chain.</p>
<p>The <em>message</em> is copied, and as such, you should make sure you will not leak it. The best way to send messages is like this: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classBMessage.html">BMessage</a> message;</div>
<div class="line">message.<a class="code hl_variable" href="classBMessage.html#a00ca71d41659fd2551fbda085ae966d3">what</a> = B_DO_SOMETHING;</div>
<div class="line">message.<a class="code hl_function" href="classBMessage.html#a342311ccdf68206c4b879bcd0f2d6e83">AddString</a>(<span class="stringliteral">&quot;some_data&quot;</span>, <span class="stringliteral">&quot;This is data&quot;</span>)</div>
<div class="line"> </div>
<div class="line">aLooper-&gt;PostMessage(&amp;message);</div>
<div class="ttc" id="aclassBMessage_html"><div class="ttname"><a href="classBMessage.html">BMessage</a></div><div class="ttdoc">A container that can be send and received using the Haiku messaging subsystem.</div><div class="ttdef"><b>Definition</b> Message.h:56</div></div>
<div class="ttc" id="aclassBMessage_html_a00ca71d41659fd2551fbda085ae966d3"><div class="ttname"><a href="classBMessage.html#a00ca71d41659fd2551fbda085ae966d3">BMessage::what</a></div><div class="ttdeci">uint32 what</div><div class="ttdoc">A 4-byte constant that determines the type of message.</div><div class="ttdef"><b>Definition</b> Message.h:58</div></div>
<div class="ttc" id="aclassBMessage_html_a342311ccdf68206c4b879bcd0f2d6e83"><div class="ttname"><a href="classBMessage.html#a342311ccdf68206c4b879bcd0f2d6e83">BMessage::AddString</a></div><div class="ttdeci">status_t AddString(const char *name, const char *string)</div><div class="ttdoc">Convenience method to add a C-string to the label name.</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message you would like to pass to this method.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The operation succeeded, and the message is sent to the port. </td></tr>
    <tr><td class="paramname">B_ERROR</td><td>There was a general operation error. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>This looper is not yet running and therefore cannot receive messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e" title="Post a message with the command as what identifier to this looper.">PostMessage(uint32)</a> if you want to send a message without data members. </dd>
<dd>
<a class="el" href="#a2dc16ecf211eb7e32eaa4b08863e856d" title="Sends a message with command what identifier to the handler associated with this looper....">PostMessage(uint32, BHandler *, BHandler *)</a> if you want to send a message to a specific handler, and request a reply. </dd>
<dd>
<a class="el" href="#ac75eed80e72b236650f19b4015de6e99" title="Send a message to the handler associated with this looper. A response may be sent to the replyTo hand...">PostMessage(BMessage *, BHandler *, BHandler *)</a> for the same thing, but with a complete message.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="ac75eed80e72b236650f19b4015de6e99" name="ac75eed80e72b236650f19b4015de6e99"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/PostMessage" class="dashAnchor">&nbsp;</a><a href="#ac75eed80e72b236650f19b4015de6e99">&#9670;&#160;</a></span>PostMessage() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::PostMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>replyTo</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a <em>message</em> to the <em>handler</em> associated with this looper. A response may be sent to the <em>replyTo</em> handler asynchronously. </p>
<p>The target <em>handler</em> should be associated with this looper. This method bypasses the default message queue.</p>
<p>The <em>message</em> is copied, and as such, you should make sure you will not leak it. The best way to send messages is like this: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classBMessage.html">BMessage</a> message;</div>
<div class="line">message.<a class="code hl_variable" href="classBMessage.html#a00ca71d41659fd2551fbda085ae966d3">what</a> = B_DO_SOMETHING;</div>
<div class="line">message.<a class="code hl_function" href="classBMessage.html#a342311ccdf68206c4b879bcd0f2d6e83">AddString</a>(<span class="stringliteral">&quot;some_data&quot;</span>, <span class="stringliteral">&quot;This is data&quot;</span>)</div>
<div class="line"> </div>
<div class="line">aLooper-&gt;PostMessage(&amp;message, aHandler);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The message you want to pass. </td></tr>
    <tr><td class="paramname">handler</td><td>The handler you would like to pass this message to. </td></tr>
    <tr><td class="paramname">replyTo</td><td>If you would like to request a reply, pass the handler to which this reply should be directed to. If you pass <code>NULL</code>, you will not receive a reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The operation succeeded, and the message is sent to the port. </td></tr>
    <tr><td class="paramname">B_ERROR</td><td>There was a general operation error. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>This looper is not yet running and therefore cannot receive messages. </td></tr>
    <tr><td class="paramname">B_MISMATCHED_VALUES</td><td>The <em>handler</em> is not associated with this looper.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e" title="Post a message with the command as what identifier to this looper.">PostMessage(uint32)</a> if you want to send a message without data members. </dd>
<dd>
<a class="el" href="#ae79a7818ce950d8edcd238f7948df020" title="Post a message to this looper.">PostMessage(BMessage *)</a> if you want to send a message with data members. </dd>
<dd>
<a class="el" href="#a2dc16ecf211eb7e32eaa4b08863e856d" title="Sends a message with command what identifier to the handler associated with this looper....">PostMessage(uint32, BHandler *, BHandler *)</a> if you want to send a message without data to a specific handler, and request a reply.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a0de6737bfbf8a8b4913adc8c74bb544e" name="a0de6737bfbf8a8b4913adc8c74bb544e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/PostMessage" class="dashAnchor">&nbsp;</a><a href="#a0de6737bfbf8a8b4913adc8c74bb544e">&#9670;&#160;</a></span>PostMessage() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::PostMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>command</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post a message with the <em>command</em> as <code>what</code> identifier to this looper. </p>
<p>Posting a message puts it in the message queue. The message passes through the default handler chain.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The <code>what</code> identifier of the message to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The operation succeeded, and the message is sent to the port. </td></tr>
    <tr><td class="paramname">B_ERROR</td><td>There was a general operation error. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>This looper is not yet running and therefore cannot receive messages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae79a7818ce950d8edcd238f7948df020" title="Post a message to this looper.">PostMessage(BMessage *)</a> if you want to send a message with data members. </dd>
<dd>
<a class="el" href="#a2dc16ecf211eb7e32eaa4b08863e856d" title="Sends a message with command what identifier to the handler associated with this looper....">PostMessage(uint32, BHandler *, BHandler *)</a> if you want to send a message to a specific handler, and request a reply. </dd>
<dd>
<a class="el" href="#ac75eed80e72b236650f19b4015de6e99" title="Send a message to the handler associated with this looper. A response may be sent to the replyTo hand...">PostMessage(BMessage *, BHandler *, BHandler *)</a> for the same thing, but with a complete message.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="a2dc16ecf211eb7e32eaa4b08863e856d" name="a2dc16ecf211eb7e32eaa4b08863e856d"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/PostMessage" class="dashAnchor">&nbsp;</a><a href="#a2dc16ecf211eb7e32eaa4b08863e856d">&#9670;&#160;</a></span>PostMessage() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> BLooper::PostMessage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>command</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>replyTo</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message with <em>command</em> <code>what</code> identifier to the <em>handler</em> associated with this looper. A response may be sent to the <em>replyTo</em> handler asynchronously. </p>
<p>The target <em>handler</em> should be associated with this looper. This method bypasses the default message queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">command</td><td>The value you want as the message's <code>what</code> identifier. </td></tr>
    <tr><td class="paramname">handler</td><td>The handler you would like to pass this message to. </td></tr>
    <tr><td class="paramname">replyTo</td><td>If you would like to request a reply, pass the handler to which this reply should be directed to. If you pass <code>NULL</code>, you will not receive a reply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A status code. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">B_OK</td><td>The operation succeeded, and the message is sent to the port. </td></tr>
    <tr><td class="paramname">B_ERROR</td><td>There was a general operation error. </td></tr>
    <tr><td class="paramname">B_BAD_VALUE</td><td>This looper is not yet running and therefore cannot receive messages. </td></tr>
    <tr><td class="paramname">B_MISMATCHED_VALUES</td><td>The <em>handler</em> is not associated with this looper.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e" title="Post a message with the command as what identifier to this looper.">PostMessage(uint32)</a> if you want to send a message without data members. </dd>
<dd>
<a class="el" href="#ae79a7818ce950d8edcd238f7948df020" title="Post a message to this looper.">PostMessage(BMessage *)</a> if you want to send a message with data members. </dd>
<dd>
<a class="el" href="#ac75eed80e72b236650f19b4015de6e99" title="Send a message to the handler associated with this looper. A response may be sent to the replyTo hand...">PostMessage(BMessage *, BHandler *, BHandler *)</a> if you want to send a message to a specific handler, and request a reply.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

</div>
</div>
<a id="af1a4af6872abc40a887bfcabd55aff98" name="af1a4af6872abc40a887bfcabd55aff98"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/PreferredHandler" class="dashAnchor">&nbsp;</a><a href="#af1a4af6872abc40a887bfcabd55aff98">&#9670;&#160;</a></span>PreferredHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBHandler.html">BHandler</a> * BLooper::PreferredHandler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the preferred handler. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the preferred handler, or <code>NULL</code> if none is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a07c6e5c65354b48465fde2b0b44e22c6" title="Set a preferred handler.">SetPreferredHandler()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="af01e29f7083d0f7b678b429348024167" name="af01e29f7083d0f7b678b429348024167"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Quit" class="dashAnchor">&nbsp;</a><a href="#af01e29f7083d0f7b678b429348024167">&#9670;&#160;</a></span>Quit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BLooper::Quit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook method that is called after a <code>B_QUIT_REQUESTED</code> message. </p>
<p>If you want to quit and delete the looper, you should post a <code>B_QUIT_REQUESTED</code> message. This will first call the hook method <a class="el" href="#ad3ddcbce40cde09e03fa2f96770b3669" title="Hook method that is called during a B_QUIT_REQUESTED message.">QuitRequested()</a>, which can be overridden in child classes in case there are conditions that would prevent the looper to be quit. If you really know what you are doing, and you definitely want to quit this looper, you may call this method, but only after performing a <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> operation.</p>
<p>Override this method if your subclass needs to perform specific clean-up tasks. Remember to call the base class implementation when you're done.</p>
<dl class="section attention"><dt>Attention</dt><dd>You will not have to delete the looper object, if a looper quits it will delete itself.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

<p>Reimplemented in <a class="el" href="classBAlert.html#aa85e4a4d42e11fd08584e9d8ea27f360">BAlert</a>, <a class="el" href="classBApplication.html#af49c0b23f9208af6a5e6f38cc47c82bd">BApplication</a>, <a class="el" href="classBDirectWindow.html#a0e078c054a66514021099c529cfdde2f">BDirectWindow</a>, and <a class="el" href="classBWindow.html#ae6c0c8210e3ef306a715a3cd29ca4ffc">BWindow</a>.</p>

</div>
</div>
<a id="ad3ddcbce40cde09e03fa2f96770b3669" name="ad3ddcbce40cde09e03fa2f96770b3669"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/QuitRequested" class="dashAnchor">&nbsp;</a><a href="#ad3ddcbce40cde09e03fa2f96770b3669">&#9670;&#160;</a></span>QuitRequested()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BLooper::QuitRequested </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hook method that is called during a <code>B_QUIT_REQUESTED</code> message. </p>
<p>This hook function is called by the looper thread when a <code>B_QUIT_REQUESTED</code> is received. The default implementation always accepts the message, but if your subclass needs a special condition to be met before actually accepting a quit message, you can test for that condition in this hook method. A good example is a window (which is a derivative of <a class="el" href="classBLooper.html" title="Receive and process messages in a separate thread.">BLooper</a>), which contains a modified document. The condition may be that a modal dialog requesting a path of action is closed.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the looper can be quit and destroyed, <code>false</code> if this method does not accept the quit message and continue processing messages.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

<p>Reimplemented in <a class="el" href="classBAlert.html#a00870cb2011ef90c5b81aeaa8eb2b904">BAlert</a>, <a class="el" href="classBApplication.html#ad8f3f57a4934a65456d4323a2d2a60b3">BApplication</a>, and <a class="el" href="classBWindow.html#a417b6b0779ff4a6ff7ebf4a6cd12f19b">BWindow</a>.</p>

</div>
</div>
<a id="add9a19d7b52ea4838ab757b8ba7f4ebe" name="add9a19d7b52ea4838ab757b8ba7f4ebe"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/RemoveCommonFilter" class="dashAnchor">&nbsp;</a><a href="#add9a19d7b52ea4838ab757b8ba7f4ebe">&#9670;&#160;</a></span>RemoveCommonFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool BLooper::RemoveCommonFilter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessageFilter.html">BMessageFilter</a> *</td>          <td class="paramname"><span class="paramname"><em>filter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a <em>filter</em> from the common message filter list. </p>
<p>Note that this will not free the memory used by the <em>filter</em>, so you should dispose of it yourself.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a422da6a77838f4ed6efd1b8a2e3df5fc" title="Add a common filter to the list of filters that are applied to all incoming messages.">AddCommonFilter()</a> </dd>
<dd>
<a class="el" href="#ae539e5548714a9acdd071e7126fe953c" title="Set a new list of filters that need to be applied to all incoming messages.">SetCommonFilterList()</a> </dd>
<dd>
<a class="el" href="#ad64f1a98c1cce8087e7d492860461a62" title="Return a list of filters applied to all incoming messages.">CommonFilterList()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a5af57140bf018388a2e64343f46ac330" name="a5af57140bf018388a2e64343f46ac330"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/RemoveHandler" class="dashAnchor">&nbsp;</a><a href="#a5af57140bf018388a2e64343f46ac330">&#9670;&#160;</a></span>RemoveHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BLooper::RemoveHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disassociate a <em>handler</em> from this looper. </p>
<p>If the handler is disassociated, it can be reassociated to another looper.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>handler</em> has been removed from this looper, <code>false</code> The <em>handler</em> was invalid or the handler was not associated to this looper.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a484be74814014e3c48c1a16f44e34074" title="Associate a handler to this looper.">AddHandler()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="abc72704386dd39a47efbfd70be4b0a92" name="abc72704386dd39a47efbfd70be4b0a92"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/ResolveSpecifier" class="dashAnchor">&nbsp;</a><a href="#abc72704386dd39a47efbfd70be4b0a92">&#9670;&#160;</a></span>ResolveSpecifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBHandler.html">BHandler</a> * BLooper::ResolveSpecifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBMessage.html">BMessage</a> *</td>          <td class="paramname"><span class="paramname"><em>specifier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>what</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>property</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the proper handler for a scripting message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">message</td><td>The scripting message to determine the handler. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the specifier. </td></tr>
    <tr><td class="paramname">specifier</td><td>The message which contains the specifier. </td></tr>
    <tr><td class="paramname">what</td><td>The 'what' field of the specifier message. </td></tr>
    <tr><td class="paramname">property</td><td>The name of the target property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the proper <a class="el" href="classBHandler.html" title="Handles messages that are passed on by a BLooper.">BHandler</a> for the given scripting message.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3    </dd></dl>

<p>Reimplemented from <a class="el" href="classBHandler.html#a47861438d36388eafd9c6522c8bb0f46">BHandler</a>.</p>

<p>Reimplemented in <a class="el" href="classBAlert.html#a980b96479113d804fbeb5aec91c2dfa2">BAlert</a>, <a class="el" href="classBApplication.html#ab8da84625b8e9d5294ed3168dedbe177">BApplication</a>, <a class="el" href="classBDirectWindow.html#aee5db7142cabc984cb16e61eaa7baa36">BDirectWindow</a>, and <a class="el" href="classBWindow.html#aef268f4560e4e9ffe6e67df36fb4fcae">BWindow</a>.</p>

</div>
</div>
<a id="aa3cd8c0157e62be6c3e3a757efac0a4c" name="aa3cd8c0157e62be6c3e3a757efac0a4c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Run" class="dashAnchor">&nbsp;</a><a href="#aa3cd8c0157e62be6c3e3a757efac0a4c">&#9670;&#160;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual thread_id BLooper::Run </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the event loop. </p>
<p>After the looper has been constructed, it needs to be started using this method. A thread will be spawned, which will receive messages.</p>
<p>Make sure the looper is not yet running before you call this method.</p>
<dl class="section return"><dt>Returns</dt><dd>A (positive) thread id if spawning the thread succeeded, or an error code.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

<p>Reimplemented in <a class="el" href="classBApplication.html#a517a4a994db14adf5420db1a94d226e9">BApplication</a>, and <a class="el" href="classBWindow.html#a92cbd76bd881ec7d1ed5b103197fc57f">BWindow</a>.</p>

</div>
</div>
<a id="aa96df67561b0ce1428ae45148c21e01f" name="aa96df67561b0ce1428ae45148c21e01f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Sem" class="dashAnchor">&nbsp;</a><a href="#aa96df67561b0ce1428ae45148c21e01f">&#9670;&#160;</a></span>Sem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sem_id BLooper::Sem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the id of the semaphore that is used to lock this looper. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="ae539e5548714a9acdd071e7126fe953c" name="ae539e5548714a9acdd071e7126fe953c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/SetCommonFilterList" class="dashAnchor">&nbsp;</a><a href="#ae539e5548714a9acdd071e7126fe953c">&#9670;&#160;</a></span>SetCommonFilterList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void BLooper::SetCommonFilterList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBList.html">BList</a> *</td>          <td class="paramname"><span class="paramname"><em>filters</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new list of <em>filters</em> that need to be applied to all incoming messages. </p>
<p>You are responsible for validating that all the items in the list of <em>filters</em> are actual filters. The old list is discarded; all the filters are <b>destroyed</b>.</p>
<p>Note that filters can only be applied to one looper or handler. If any of the filters is already associated with another one, this call will fail.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a422da6a77838f4ed6efd1b8a2e3df5fc" title="Add a common filter to the list of filters that are applied to all incoming messages.">AddCommonFilter()</a> </dd>
<dd>
<a class="el" href="#add9a19d7b52ea4838ab757b8ba7f4ebe" title="Remove a filter from the common message filter list.">RemoveCommonFilter()</a> </dd>
<dd>
<a class="el" href="#ad64f1a98c1cce8087e7d492860461a62" title="Return a list of filters applied to all incoming messages.">CommonFilterList()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a07c6e5c65354b48465fde2b0b44e22c6" name="a07c6e5c65354b48465fde2b0b44e22c6"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/SetPreferredHandler" class="dashAnchor">&nbsp;</a><a href="#a07c6e5c65354b48465fde2b0b44e22c6">&#9670;&#160;</a></span>SetPreferredHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BLooper::SetPreferredHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBHandler.html">BHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a preferred handler. </p>
<p>If messages are posted to this looper using one of the <a class="el" href="#a0de6737bfbf8a8b4913adc8c74bb544e" title="Post a message with the command as what identifier to this looper.">PostMessage()</a> methods without a specific <a class="el" href="classBHandler.html" title="Handles messages that are passed on by a BLooper.">BHandler</a> argument, the messages will be handled by the looper itself (since a looper is a subclass of <a class="el" href="classBHandler.html" title="Handles messages that are passed on by a BLooper.">BHandler</a>, this is perfectly possible). If you want to override that behavior, you should set a preferred handler. This handler will be called if incoming messages do not ask to be directly passed on to a specific handler.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The preferred handler you want undesignated messages to be handled by. If you want to unset the preferred handler, pass <code>NULL</code>. If the supplied <em>handler</em> is not associated with this looper, this call will fail silently and the current preferred handler will be unset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#af1a4af6872abc40a887bfcabd55aff98" title="Get the preferred handler.">PreferredHandler()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="afeb7a4900f26e7746d6c8bdb5cf684f3" name="afeb7a4900f26e7746d6c8bdb5cf684f3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Team" class="dashAnchor">&nbsp;</a><a href="#afeb7a4900f26e7746d6c8bdb5cf684f3">&#9670;&#160;</a></span>Team()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">team_id BLooper::Team </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the team id in which this looper exists. </p>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="a257d396d04d128edf7a0c9669ead36c0" name="a257d396d04d128edf7a0c9669ead36c0"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Thread" class="dashAnchor">&nbsp;</a><a href="#a257d396d04d128edf7a0c9669ead36c0">&#9670;&#160;</a></span>Thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_id BLooper::Thread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the thread id of the internal message looper thread. </p>
<p>If the looper is not yet running, this method will return 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aa3cd8c0157e62be6c3e3a757efac0a4c" title="Start the event loop.">Run()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R3 </dd></dl>

</div>
</div>
<a id="ac84ea15405640082b9fda58f6672467c" name="ac84ea15405640082b9fda58f6672467c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Method/Unlock" class="dashAnchor">&nbsp;</a><a href="#ac84ea15405640082b9fda58f6672467c">&#9670;&#160;</a></span>Unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BLooper::Unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock a locked looper. </p>
<p>Use this method paired with <a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> calls, to release a lock. Make sure that this method is only called on a locked looper.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a757a3e406ea3b7bb9a1ad16d04689b1d" title="Lock the looper.">Lock()</a> </dd>
<dd>
<a class="el" href="#a734cdb06bfe92efdea24528c9b43bfc1" title="Lock a looper with a timeout.">LockWithTimeout()</a> </dd>
<dd>
<a class="el" href="#a525d6677c2fc76a84c2d48853dad142a" title="Check if a looper is locked.">IsLocked()</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>BeOS R5 </dd></dl>

<p class="reference">Referenced by <a class="el" href="classBAutolock.html#a62e220b72b39ffa459b51dae1ca50332">BAutolock::Unlock()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - BLooper Class Reference<br />
    Generated on Sat May 24 2025 23:12:18 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
