<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: KernelExport.h File Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_7f57b1e41c5acd0e859ae5f3a2b075a9.html">headers</a></li><li class="navelem"><a class="el" href="dir_4b32c6481442aa9b3580ee2f870fac49.html">os</a></li><li class="navelem"><a class="el" href="dir_fed1e4a943141a8b219d7f5b50af92fe.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">KernelExport.h File Reference<div class="ingroups"><a class="el" href="group__drivers.html">Device Drivers</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Interfaces for drivers code running in kernel space.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4825cd4d3bba6655ef4a60fad05c76c4" id="r_a4825cd4d3bba6655ef4a60fad05c76c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4825cd4d3bba6655ef4a60fad05c76c4">acquire_read_seqlock</a> (seqlock *lock)</td></tr>
<tr class="memdesc:a4825cd4d3bba6655ef4a60fad05c76c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare for read access to data protected by a seqlock.  <br /></td></tr>
<tr class="separator:a4825cd4d3bba6655ef4a60fad05c76c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95779cbf64f90f4e8a8f9c90e1de5bfa" id="r_a95779cbf64f90f4e8a8f9c90e1de5bfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95779cbf64f90f4e8a8f9c90e1de5bfa">acquire_read_spinlock</a> (rw_spinlock *lock)</td></tr>
<tr class="memdesc:a95779cbf64f90f4e8a8f9c90e1de5bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy wait until a rw_spinlock can be read locked.  <br /></td></tr>
<tr class="separator:a95779cbf64f90f4e8a8f9c90e1de5bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59bae25be811dbb9de6b84ca3667c02" id="r_ac59bae25be811dbb9de6b84ca3667c02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac59bae25be811dbb9de6b84ca3667c02">acquire_spinlock</a> (spinlock *lock)</td></tr>
<tr class="memdesc:ac59bae25be811dbb9de6b84ca3667c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy wait until the lock is acquired.  <br /></td></tr>
<tr class="separator:ac59bae25be811dbb9de6b84ca3667c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7e9dcae64e2bcb813393f4b8c65ea5" id="r_a6b7e9dcae64e2bcb813393f4b8c65ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b7e9dcae64e2bcb813393f4b8c65ea5">acquire_write_seqlock</a> (seqlock *lock)</td></tr>
<tr class="memdesc:a6b7e9dcae64e2bcb813393f4b8c65ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy wait for a seqlock and acquire it for writing.  <br /></td></tr>
<tr class="separator:a6b7e9dcae64e2bcb813393f4b8c65ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6dcf1bd792057c97ee14702b96249" id="r_a14c6dcf1bd792057c97ee14702b96249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c6dcf1bd792057c97ee14702b96249">acquire_write_spinlock</a> (rw_spinlock *lock)</td></tr>
<tr class="memdesc:a14c6dcf1bd792057c97ee14702b96249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for and acquire a write lock on an rw_spinlock.  <br /></td></tr>
<tr class="separator:a14c6dcf1bd792057c97ee14702b96249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcab3a91e539d93094000ae3aa34874" id="r_aabcab3a91e539d93094000ae3aa34874"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabcab3a91e539d93094000ae3aa34874">add_debugger_command</a> (const char *name, debugger_command_hook hook, const char *help)</td></tr>
<tr class="memdesc:aabcab3a91e539d93094000ae3aa34874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a command to the krnel debugger.  <br /></td></tr>
<tr class="separator:aabcab3a91e539d93094000ae3aa34874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3a419465836dee82700b67964b8112" id="r_a5f3a419465836dee82700b67964b8112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f3a419465836dee82700b67964b8112">add_timer</a> (timer *t, timer_hook hook, <a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a> period, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> flags)</td></tr>
<tr class="memdesc:a5f3a419465836dee82700b67964b8112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule a timer to call the hook function periodically or at a specified time.  <br /></td></tr>
<tr class="separator:a5f3a419465836dee82700b67964b8112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa857244cb489362c5bbc223878a7b47b" id="r_aa857244cb489362c5bbc223878a7b47b"><td class="memItemLeft" align="right" valign="top"><a id="aa857244cb489362c5bbc223878a7b47b" name="aa857244cb489362c5bbc223878a7b47b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>call_all_cpus</b> (void(*func)(void *, int), void *cookie)</td></tr>
<tr class="memdesc:aa857244cb489362c5bbc223878a7b47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on all CPUs. <br /></td></tr>
<tr class="separator:aa857244cb489362c5bbc223878a7b47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81037d980406970624f132a91593cca9" id="r_a81037d980406970624f132a91593cca9"><td class="memItemLeft" align="right" valign="top"><a id="a81037d980406970624f132a91593cca9" name="a81037d980406970624f132a91593cca9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>call_all_cpus_sync</b> (void(*func)(void *, int), void *cookie)</td></tr>
<tr class="memdesc:a81037d980406970624f132a91593cca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on all CPUs, and wait for all of them to complete it before returning. <br /></td></tr>
<tr class="separator:a81037d980406970624f132a91593cca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad228b430547d8d81788b57aecf01e44e" id="r_ad228b430547d8d81788b57aecf01e44e"><td class="memItemLeft" align="right" valign="top"><a id="ad228b430547d8d81788b57aecf01e44e" name="ad228b430547d8d81788b57aecf01e44e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cancel_timer</b> (timer *t)</td></tr>
<tr class="memdesc:ad228b430547d8d81788b57aecf01e44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop a timer scheduled by <a class="el" href="#a5f3a419465836dee82700b67964b8112">add_timer</a>. <br /></td></tr>
<tr class="separator:ad228b430547d8d81788b57aecf01e44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fa1a0e57deaba8adf4f3deaf61de58" id="r_a72fa1a0e57deaba8adf4f3deaf61de58"><td class="memItemLeft" align="right" valign="top">cpu_status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72fa1a0e57deaba8adf4f3deaf61de58">disable_interrupts</a> (void)</td></tr>
<tr class="memdesc:a72fa1a0e57deaba8adf4f3deaf61de58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable interruptions.  <br /></td></tr>
<tr class="separator:a72fa1a0e57deaba8adf4f3deaf61de58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8a20faae08b072f06a28ec013e6ca2" id="r_abd8a20faae08b072f06a28ec013e6ca2"><td class="memItemLeft" align="right" valign="top"><a id="abd8a20faae08b072f06a28ec013e6ca2" name="abd8a20faae08b072f06a28ec013e6ca2"></a>
void void&#160;</td><td class="memItemRight" valign="bottom"><b>dump_block</b> (const char *buffer, int size, const char *prefix)</td></tr>
<tr class="memdesc:abd8a20faae08b072f06a28ec013e6ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a memory buffer as hexadecimal values to the kernel log. <br /></td></tr>
<tr class="separator:abd8a20faae08b072f06a28ec013e6ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c32ced369390304b01c67316beaa5a" id="r_a49c32ced369390304b01c67316beaa5a"><td class="memItemLeft" align="right" valign="top"><a id="a49c32ced369390304b01c67316beaa5a" name="a49c32ced369390304b01c67316beaa5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dvprintf</b> (const char *format, va_list args)</td></tr>
<tr class="memdesc:a49c32ced369390304b01c67316beaa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to the kernel log if dprintf is enabled. <br /></td></tr>
<tr class="separator:a49c32ced369390304b01c67316beaa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10740578b90148d64ac3ad94dd692476" id="r_a10740578b90148d64ac3ad94dd692476"><td class="memItemLeft" align="right" valign="top"><a id="a10740578b90148d64ac3ad94dd692476" name="a10740578b90148d64ac3ad94dd692476"></a>
<a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_memory_map</b> (const void *buffer, size_t size, physical_entry *table, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> numEntries)</td></tr>
<tr class="memdesc:a10740578b90148d64ac3ad94dd692476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory map for the current team. <br /></td></tr>
<tr class="separator:a10740578b90148d64ac3ad94dd692476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51da63193e71d5a34ffcabb8b2b90c64" id="r_a51da63193e71d5a34ffcabb8b2b90c64"><td class="memItemLeft" align="right" valign="top"><a id="a51da63193e71d5a34ffcabb8b2b90c64" name="a51da63193e71d5a34ffcabb8b2b90c64"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_memory_map_etc</b> (team_id team, const void *address, size_t numBytes, physical_entry *table, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_numEntries)</td></tr>
<tr class="memdesc:a51da63193e71d5a34ffcabb8b2b90c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the physical addresses corresponding to a virtual memory range. <br /></td></tr>
<tr class="separator:a51da63193e71d5a34ffcabb8b2b90c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b542dad14775ab6b43b8247d351d61" id="r_a47b542dad14775ab6b43b8247d351d61"><td class="memItemLeft" align="right" valign="top"><a id="a47b542dad14775ab6b43b8247d351d61" name="a47b542dad14775ab6b43b8247d351d61"></a>
void void&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_debugger</b> (const char *message)</td></tr>
<tr class="memdesc:a47b542dad14775ab6b43b8247d351d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter the kernel debugger with the passed message. <br /></td></tr>
<tr class="separator:a47b542dad14775ab6b43b8247d351d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21fd27b1ae462dc2a0a066f82c74691" id="r_af21fd27b1ae462dc2a0a066f82c74691"><td class="memItemLeft" align="right" valign="top"><a id="af21fd27b1ae462dc2a0a066f82c74691" name="af21fd27b1ae462dc2a0a066f82c74691"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>kprintf</b> (const char *fmt,...) _PRINTFLIKE(1</td></tr>
<tr class="memdesc:af21fd27b1ae462dc2a0a066f82c74691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message to the kernel log unconditionally. <br /></td></tr>
<tr class="separator:af21fd27b1ae462dc2a0a066f82c74691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d82d647d08b144894b52c616380f12" id="r_a63d82d647d08b144894b52c616380f12"><td class="memItemLeft" align="right" valign="top"><a id="a63d82d647d08b144894b52c616380f12" name="a63d82d647d08b144894b52c616380f12"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lock_memory</b> (void *buffer, size_t numBytes, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:a63d82d647d08b144894b52c616380f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock memory from the current team into RAM. <br /></td></tr>
<tr class="separator:a63d82d647d08b144894b52c616380f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73185c94b2d664086fb9a4c854f21ad" id="r_ab73185c94b2d664086fb9a4c854f21ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab73185c94b2d664086fb9a4c854f21ad">lock_memory_etc</a> (team_id team, void *buffer, size_t numBytes, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:ab73185c94b2d664086fb9a4c854f21ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock memory pages into RAM.  <br /></td></tr>
<tr class="separator:ab73185c94b2d664086fb9a4c854f21ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680345fab31cec0ef4b96eb5c847ba0a" id="r_a680345fab31cec0ef4b96eb5c847ba0a"><td class="memItemLeft" align="right" valign="top">area_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a680345fab31cec0ef4b96eb5c847ba0a">map_physical_memory</a> (const char *areaName, <a class="el" href="SupportDefs_8h.html#a7cc3278721fbe4920855844165754c06">phys_addr_t</a> physicalAddress, size_t size, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> protection, void **_mappedAddress)</td></tr>
<tr class="memdesc:a680345fab31cec0ef4b96eb5c847ba0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an area that allows access to a specific range of physical memory.  <br /></td></tr>
<tr class="separator:a680345fab31cec0ef4b96eb5c847ba0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d15cdc3b6fc015a004c85a3413473cb" id="r_a7d15cdc3b6fc015a004c85a3413473cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d15cdc3b6fc015a004c85a3413473cb">memory_read_barrier</a> (void)</td></tr>
<tr class="memdesc:a7d15cdc3b6fc015a004c85a3413473cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a memory read barrier.  <br /></td></tr>
<tr class="separator:a7d15cdc3b6fc015a004c85a3413473cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b55a8ccbd47e4f6a3a2f2535a617cfd" id="r_a1b55a8ccbd47e4f6a3a2f2535a617cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b55a8ccbd47e4f6a3a2f2535a617cfd">memory_write_barrier</a> (void)</td></tr>
<tr class="memdesc:a1b55a8ccbd47e4f6a3a2f2535a617cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a memory write barrier.  <br /></td></tr>
<tr class="separator:a1b55a8ccbd47e4f6a3a2f2535a617cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5329bf9b63507517b905cf33fa97929" id="r_ae5329bf9b63507517b905cf33fa97929"><td class="memItemLeft" align="right" valign="top"><a id="ae5329bf9b63507517b905cf33fa97929" name="ae5329bf9b63507517b905cf33fa97929"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>panic</b> (const char *format,...) _PRINTFLIKE(1</td></tr>
<tr class="memdesc:ae5329bf9b63507517b905cf33fa97929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enter the kernel debugger with the passed (formatted) message. <br /></td></tr>
<tr class="separator:ae5329bf9b63507517b905cf33fa97929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494968d912be534db226ea73050c57a1" id="r_a494968d912be534db226ea73050c57a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#a31809f9e3be3ab0398318f669d00a181">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a494968d912be534db226ea73050c57a1">parse_expression</a> (const char *string)</td></tr>
<tr class="memdesc:a494968d912be534db226ea73050c57a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an expression and return its value.  <br /></td></tr>
<tr class="separator:a494968d912be534db226ea73050c57a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bbc2240c538542c2a34ede64e0153d" id="r_a78bbc2240c538542c2a34ede64e0153d"><td class="memItemLeft" align="right" valign="top"><a id="a78bbc2240c538542c2a34ede64e0153d" name="a78bbc2240c538542c2a34ede64e0153d"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>register_kernel_daemon</b> (daemon_hook hook, void *arg, int frequency)</td></tr>
<tr class="memdesc:a78bbc2240c538542c2a34ede64e0153d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a function to be called periodically. <br /></td></tr>
<tr class="separator:a78bbc2240c538542c2a34ede64e0153d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9625c33bb5e865f4f4bfb405517af6d6" id="r_a9625c33bb5e865f4f4bfb405517af6d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9625c33bb5e865f4f4bfb405517af6d6">release_read_seqlock</a> (seqlock *lock, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> count)</td></tr>
<tr class="memdesc:a9625c33bb5e865f4f4bfb405517af6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a read lock and check if the read operation was successful.  <br /></td></tr>
<tr class="separator:a9625c33bb5e865f4f4bfb405517af6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a231497369cae0e1284f3b32c35607c" id="r_a5a231497369cae0e1284f3b32c35607c"><td class="memItemLeft" align="right" valign="top"><a id="a5a231497369cae0e1284f3b32c35607c" name="a5a231497369cae0e1284f3b32c35607c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>release_read_spinlock</b> (rw_spinlock *lock)</td></tr>
<tr class="memdesc:a5a231497369cae0e1284f3b32c35607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a read lock on a rw_spinlock. <br /></td></tr>
<tr class="separator:a5a231497369cae0e1284f3b32c35607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16138efa0e5888489a42ae03b8b0a3e8" id="r_a16138efa0e5888489a42ae03b8b0a3e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16138efa0e5888489a42ae03b8b0a3e8">release_spinlock</a> (spinlock *lock)</td></tr>
<tr class="memdesc:a16138efa0e5888489a42ae03b8b0a3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired spinlock.  <br /></td></tr>
<tr class="separator:a16138efa0e5888489a42ae03b8b0a3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb79c5c5f8993a88a73122af4d2108fc" id="r_afb79c5c5f8993a88a73122af4d2108fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb79c5c5f8993a88a73122af4d2108fc">release_write_seqlock</a> (seqlock *lock)</td></tr>
<tr class="memdesc:afb79c5c5f8993a88a73122af4d2108fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a write lock on a seqlock.  <br /></td></tr>
<tr class="separator:afb79c5c5f8993a88a73122af4d2108fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b420747fcfb32724efe21052d65d8" id="r_ad98b420747fcfb32724efe21052d65d8"><td class="memItemLeft" align="right" valign="top"><a id="ad98b420747fcfb32724efe21052d65d8" name="ad98b420747fcfb32724efe21052d65d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>release_write_spinlock</b> (rw_spinlock *lock)</td></tr>
<tr class="memdesc:ad98b420747fcfb32724efe21052d65d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release a previously acquired write lock on an rw_spinlock. <br /></td></tr>
<tr class="separator:ad98b420747fcfb32724efe21052d65d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5341974a07906e4aa9e116eaf79cc3" id="r_a4e5341974a07906e4aa9e116eaf79cc3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e5341974a07906e4aa9e116eaf79cc3">remove_debugger_command</a> (const char *name, debugger_command_hook hook)</td></tr>
<tr class="memdesc:a4e5341974a07906e4aa9e116eaf79cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a debugger command previously installed by <a class="el" href="#aabcab3a91e539d93094000ae3aa34874">add_debugger_command</a>.  <br /></td></tr>
<tr class="separator:a4e5341974a07906e4aa9e116eaf79cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2a4d137cf6d933cfa9d2ec8e847512" id="r_afb2a4d137cf6d933cfa9d2ec8e847512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb2a4d137cf6d933cfa9d2ec8e847512">restore_interrupts</a> (cpu_status status)</td></tr>
<tr class="memdesc:afb2a4d137cf6d933cfa9d2ec8e847512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore interrupts to the previous state.  <br /></td></tr>
<tr class="separator:afb2a4d137cf6d933cfa9d2ec8e847512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5122ac03c08fcb322aaa5ac02d627154" id="r_a5122ac03c08fcb322aaa5ac02d627154"><td class="memItemLeft" align="right" valign="top"><a id="a5122ac03c08fcb322aaa5ac02d627154" name="a5122ac03c08fcb322aaa5ac02d627154"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>send_signal_etc</b> (pid_t thread, uint signal, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:a5122ac03c08fcb322aaa5ac02d627154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a thread. <br /></td></tr>
<tr class="separator:a5122ac03c08fcb322aaa5ac02d627154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94aac04f983cfac3fe77f6351cbda340" id="r_a94aac04f983cfac3fe77f6351cbda340"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94aac04f983cfac3fe77f6351cbda340">set_dprintf_enabled</a> (bool new_state)</td></tr>
<tr class="memdesc:a94aac04f983cfac3fe77f6351cbda340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable dprintf log messages.  <br /></td></tr>
<tr class="separator:a94aac04f983cfac3fe77f6351cbda340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81df33f3dc190048aa9c0215790eae0" id="r_af81df33f3dc190048aa9c0215790eae0"><td class="memItemLeft" align="right" valign="top">thread_id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af81df33f3dc190048aa9c0215790eae0">spawn_kernel_thread</a> (thread_func function, const char *name, <a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a> priority, void *arg)</td></tr>
<tr class="memdesc:af81df33f3dc190048aa9c0215790eae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a kernel thread.  <br /></td></tr>
<tr class="separator:af81df33f3dc190048aa9c0215790eae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55658e014bd73145dd09278148a6efca" id="r_a55658e014bd73145dd09278148a6efca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55658e014bd73145dd09278148a6efca">spin</a> (<a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a> microseconds)</td></tr>
<tr class="memdesc:a55658e014bd73145dd09278148a6efca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Busy loop for the given time.  <br /></td></tr>
<tr class="separator:a55658e014bd73145dd09278148a6efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d43cda5bdbb3138ea9ed4cce3d4096" id="r_a27d43cda5bdbb3138ea9ed4cce3d4096"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27d43cda5bdbb3138ea9ed4cce3d4096">try_acquire_read_spinlock</a> (rw_spinlock *lock)</td></tr>
<tr class="memdesc:a27d43cda5bdbb3138ea9ed4cce3d4096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a rw_spinlock for reading, if available.  <br /></td></tr>
<tr class="separator:a27d43cda5bdbb3138ea9ed4cce3d4096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14928f8c093768ee25b38a86c59841d9" id="r_a14928f8c093768ee25b38a86c59841d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14928f8c093768ee25b38a86c59841d9">try_acquire_write_seqlock</a> (seqlock *lock)</td></tr>
<tr class="memdesc:a14928f8c093768ee25b38a86c59841d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a seqlock for writing, without waiting.  <br /></td></tr>
<tr class="separator:a14928f8c093768ee25b38a86c59841d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f25511f4aa660a5093b3afee70fd420" id="r_a2f25511f4aa660a5093b3afee70fd420"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f25511f4aa660a5093b3afee70fd420">try_acquire_write_spinlock</a> (rw_spinlock *lock)</td></tr>
<tr class="memdesc:a2f25511f4aa660a5093b3afee70fd420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquire a rw_spinlock for writing, if available.  <br /></td></tr>
<tr class="separator:a2f25511f4aa660a5093b3afee70fd420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad354897fd616b06e928ec0c18bdf2051" id="r_ad354897fd616b06e928ec0c18bdf2051"><td class="memItemLeft" align="right" valign="top"><a id="ad354897fd616b06e928ec0c18bdf2051" name="ad354897fd616b06e928ec0c18bdf2051"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_memory</b> (void *buffer, size_t numBytes, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:ad354897fd616b06e928ec0c18bdf2051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock memory previously locked by <a class="el" href="#a63d82d647d08b144894b52c616380f12">lock_memory</a>. <br /></td></tr>
<tr class="separator:ad354897fd616b06e928ec0c18bdf2051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac38b0d6b7f4534bfbb1fc444f24d93" id="r_a0ac38b0d6b7f4534bfbb1fc444f24d93"><td class="memItemLeft" align="right" valign="top"><a id="a0ac38b0d6b7f4534bfbb1fc444f24d93" name="a0ac38b0d6b7f4534bfbb1fc444f24d93"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unlock_memory_etc</b> (team_id team, void *address, size_t numBytes, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:a0ac38b0d6b7f4534bfbb1fc444f24d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock memory previously locked by <a class="el" href="#ab73185c94b2d664086fb9a4c854f21ad">lock_memory_etc</a>. <br /></td></tr>
<tr class="separator:a0ac38b0d6b7f4534bfbb1fc444f24d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01680e85a664b50f37ce41eb9a5ae121" id="r_a01680e85a664b50f37ce41eb9a5ae121"><td class="memItemLeft" align="right" valign="top"><a id="a01680e85a664b50f37ce41eb9a5ae121" name="a01680e85a664b50f37ce41eb9a5ae121"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>unregister_kernel_daemon</b> (daemon_hook hook, void *arg)</td></tr>
<tr class="memdesc:a01680e85a664b50f37ce41eb9a5ae121"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop calling a daemon function. <br /></td></tr>
<tr class="separator:a01680e85a664b50f37ce41eb9a5ae121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d833b56f3f70cf2b1933f88d691b97" id="r_a85d833b56f3f70cf2b1933f88d691b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85d833b56f3f70cf2b1933f88d691b97">user_memcpy</a> (void *to, const void *from, size_t size)</td></tr>
<tr class="memdesc:a85d833b56f3f70cf2b1933f88d691b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy memory between userspace and kernelspace.  <br /></td></tr>
<tr class="separator:a85d833b56f3f70cf2b1933f88d691b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e943a4b7f922f44129e75a5b2819ca" id="r_a32e943a4b7f922f44129e75a5b2819ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32e943a4b7f922f44129e75a5b2819ca">user_memset</a> (void *start, char c, size_t count)</td></tr>
<tr class="memdesc:a32e943a4b7f922f44129e75a5b2819ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set userspace memory.  <br /></td></tr>
<tr class="separator:a32e943a4b7f922f44129e75a5b2819ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab13c9d9c7310125e5a80fcfc69b18f" id="r_aeab13c9d9c7310125e5a80fcfc69b18f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeab13c9d9c7310125e5a80fcfc69b18f">user_strlcpy</a> (char *to, const char *from, size_t size)</td></tr>
<tr class="memdesc:aeab13c9d9c7310125e5a80fcfc69b18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a string between userspace and kernel space.  <br /></td></tr>
<tr class="separator:aeab13c9d9c7310125e5a80fcfc69b18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interfaces for drivers code running in kernel space. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4825cd4d3bba6655ef4a60fad05c76c4" name="a4825cd4d3bba6655ef4a60fad05c76c4"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/acquire_read_seqlock" class="dashAnchor">&nbsp;</a><a href="#a4825cd4d3bba6655ef4a60fad05c76c4">&#9670;&#160;</a></span>acquire_read_seqlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> acquire_read_seqlock </td>
          <td>(</td>
          <td class="paramtype">seqlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prepare for read access to data protected by a seqlock. </p>
<dl class="section return"><dt>Returns</dt><dd>The counter value of the seqlock, at the time of locking, to be passed to <a class="el" href="#a9625c33bb5e865f4f4bfb405517af6d6">release_read_seqlock</a>. </dd></dl>

</div>
</div>
<a id="a95779cbf64f90f4e8a8f9c90e1de5bfa" name="a95779cbf64f90f4e8a8f9c90e1de5bfa"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/acquire_read_spinlock" class="dashAnchor">&nbsp;</a><a href="#a95779cbf64f90f4e8a8f9c90e1de5bfa">&#9670;&#160;</a></span>acquire_read_spinlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void acquire_read_spinlock </td>
          <td>(</td>
          <td class="paramtype">rw_spinlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Busy wait until a rw_spinlock can be read locked. </p>
<p>Loop until there are no writers holding te lock, then acquire a read lock. </p>

</div>
</div>
<a id="ac59bae25be811dbb9de6b84ca3667c02" name="ac59bae25be811dbb9de6b84ca3667c02"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/acquire_spinlock" class="dashAnchor">&nbsp;</a><a href="#ac59bae25be811dbb9de6b84ca3667c02">&#9670;&#160;</a></span>acquire_spinlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void acquire_spinlock </td>
          <td>(</td>
          <td class="paramtype">spinlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Busy wait until the lock is acquired. </p>
<p>Wait until the lock is acquired. Note that this keeps the thread running on the CPU, and does not release the CPU for other threads to run.</p>
<p>If the spinlock does not become available quickly enough, calls <a class="el" href="#ae5329bf9b63507517b905cf33fa97929" title="Enter the kernel debugger with the passed (formatted) message.">panic()</a>. </p>

</div>
</div>
<a id="a6b7e9dcae64e2bcb813393f4b8c65ea5" name="a6b7e9dcae64e2bcb813393f4b8c65ea5"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/acquire_write_seqlock" class="dashAnchor">&nbsp;</a><a href="#a6b7e9dcae64e2bcb813393f4b8c65ea5">&#9670;&#160;</a></span>acquire_write_seqlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void acquire_write_seqlock </td>
          <td>(</td>
          <td class="paramtype">seqlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Busy wait for a seqlock and acquire it for writing. </p>
<p>Wait for all other writers to release the lock, then acquire it.</p>
<p>This increments the counter after acquiring the lock. </p>

</div>
</div>
<a id="a14c6dcf1bd792057c97ee14702b96249" name="a14c6dcf1bd792057c97ee14702b96249"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/acquire_write_spinlock" class="dashAnchor">&nbsp;</a><a href="#a14c6dcf1bd792057c97ee14702b96249">&#9670;&#160;</a></span>acquire_write_spinlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void acquire_write_spinlock </td>
          <td>(</td>
          <td class="paramtype">rw_spinlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for and acquire a write lock on an rw_spinlock. </p>
<p>Repeatedly try to acquire a write lock until it works. If this fails for too long, call <a class="el" href="#ae5329bf9b63507517b905cf33fa97929" title="Enter the kernel debugger with the passed (formatted) message.">panic()</a>. </p>

</div>
</div>
<a id="aabcab3a91e539d93094000ae3aa34874" name="aabcab3a91e539d93094000ae3aa34874"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/add_debugger_command" class="dashAnchor">&nbsp;</a><a href="#aabcab3a91e539d93094000ae3aa34874">&#9670;&#160;</a></span>add_debugger_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int add_debugger_command </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">debugger_command_hook</td>          <td class="paramname"><span class="paramname"><em>hook</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>help</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a command to the krnel debugger. </p>
<p>Drivers can add extra commands to the kernel debugger to ease investigation and debugging of the driver and hardware. The commands accept a typical argc/argv command line. </p>

</div>
</div>
<a id="a5f3a419465836dee82700b67964b8112" name="a5f3a419465836dee82700b67964b8112"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/add_timer" class="dashAnchor">&nbsp;</a><a href="#a5f3a419465836dee82700b67964b8112">&#9670;&#160;</a></span>add_timer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> add_timer </td>
          <td>(</td>
          <td class="paramtype">timer *</td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">timer_hook</td>          <td class="paramname"><span class="paramname"><em>hook</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a></td>          <td class="paramname"><span class="paramname"><em>period</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedule a timer to call the hook function periodically or at a specified time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>If B_ONE_SHOT_ABSOLUTE_TIMER, use the period as a date when the hook should be called. Otherwise, use it as a period to call the hook repeatedly. </td></tr>
    <tr><td class="paramname">flags</td><td>If B_TIMER_USE_TIMER_STRUCT_TIMES, use the period defined by t instead of period. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72fa1a0e57deaba8adf4f3deaf61de58" name="a72fa1a0e57deaba8adf4f3deaf61de58"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/disable_interrupts" class="dashAnchor">&nbsp;</a><a href="#a72fa1a0e57deaba8adf4f3deaf61de58">&#9670;&#160;</a></span>disable_interrupts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cpu_status disable_interrupts </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable interruptions. </p>
<p>Drivers can disable interrupts in order to set up the interrupt handler for a device without being interrupted, or as a simple way to implement critical sections.</p>
<p>Interruptions should be kept disabled for as short as possible, and re-enabled using <a class="el" href="#afb2a4d137cf6d933cfa9d2ec8e847512">restore_interrupts</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The previous state of interrupts, which should be passed to <a class="el" href="#afb2a4d137cf6d933cfa9d2ec8e847512">restore_interrupts</a> </dd></dl>

</div>
</div>
<a id="ab73185c94b2d664086fb9a4c854f21ad" name="ab73185c94b2d664086fb9a4c854f21ad"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/lock_memory_etc" class="dashAnchor">&nbsp;</a><a href="#ab73185c94b2d664086fb9a4c854f21ad">&#9670;&#160;</a></span>lock_memory_etc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> lock_memory_etc </td>
          <td>(</td>
          <td class="paramtype">team_id</td>          <td class="paramname"><span class="paramname"><em>team</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Lock memory pages into RAM. </p>
<p>Lock a memory area and prevent accesses from other parts of the system. This establishes the following:</p><ul>
<li>The memory is mapped into physical RAM (moved out of swap or committed if needed)</li>
<li>No other thread can lock an overlapping memory range</li>
</ul>
<p>This is used for example during DMA transfers, to make sure the DMA can operate on memory that will not be accessed by the CPU or other devices. </p>

</div>
</div>
<a id="a680345fab31cec0ef4b96eb5c847ba0a" name="a680345fab31cec0ef4b96eb5c847ba0a"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/map_physical_memory" class="dashAnchor">&nbsp;</a><a href="#a680345fab31cec0ef4b96eb5c847ba0a">&#9670;&#160;</a></span>map_physical_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">area_id map_physical_memory </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>areaName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a7cc3278721fbe4920855844165754c06">phys_addr_t</a></td>          <td class="paramname"><span class="paramname"><em>physicalAddress</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>flags</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>protection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>_mappedAddress</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an area that allows access to a specific range of physical memory. </p>
<p>This can be used to map memory-mapped hardware to allow accessing it. The area can then be used by a driver, or its id sent to userspace for direct hardware access from userspace. </p>

</div>
</div>
<a id="a7d15cdc3b6fc015a004c85a3413473cb" name="a7d15cdc3b6fc015a004c85a3413473cb"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/memory_read_barrier" class="dashAnchor">&nbsp;</a><a href="#a7d15cdc3b6fc015a004c85a3413473cb">&#9670;&#160;</a></span>memory_read_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memory_read_barrier </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a memory read barrier. </p>
<p>Some CPU and cache architectures do not automatically ensure consistency between the CPU cache, the instruction ordering, and the memory. A barrier makes sure every read that should be executed before the barrier will be complete before any more memory access operations can be done. </p>

</div>
</div>
<a id="a1b55a8ccbd47e4f6a3a2f2535a617cfd" name="a1b55a8ccbd47e4f6a3a2f2535a617cfd"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/memory_write_barrier" class="dashAnchor">&nbsp;</a><a href="#a1b55a8ccbd47e4f6a3a2f2535a617cfd">&#9670;&#160;</a></span>memory_write_barrier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void memory_write_barrier </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a memory write barrier. </p>
<p>Some CPU and cache architectures do not automatically ensure consistency between the CPU cache, the instruction ordering, and the memory. A barrier makes sure every read that should be executed before the barrier will be complete before any more memory access operations can be done. </p>

</div>
</div>
<a id="a494968d912be534db226ea73050c57a1" name="a494968d912be534db226ea73050c57a1"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/parse_expression" class="dashAnchor">&nbsp;</a><a href="#a494968d912be534db226ea73050c57a1">&#9670;&#160;</a></span>parse_expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#a31809f9e3be3ab0398318f669d00a181">uint64</a> parse_expression </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an expression and return its value. </p>
<p>Expressions can contain numbers in various bases and simple arithmetic operations, as well as kernel debugger variables. This function is used to parse kernel debugger command arguments. </p>

</div>
</div>
<a id="a9625c33bb5e865f4f4bfb405517af6d6" name="a9625c33bb5e865f4f4bfb405517af6d6"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/release_read_seqlock" class="dashAnchor">&nbsp;</a><a href="#a9625c33bb5e865f4f4bfb405517af6d6">&#9670;&#160;</a></span>release_read_seqlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool release_read_seqlock </td>
          <td>(</td>
          <td class="paramtype">seqlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a></td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a read lock and check if the read operation was successful. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The lock count value returned by the correspondin <a class="el" href="#a4825cd4d3bba6655ef4a60fad05c76c4">acquire_read_seqlock</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there were no write access while the lock was read-locked, false otherwise. </dd></dl>

</div>
</div>
<a id="a16138efa0e5888489a42ae03b8b0a3e8" name="a16138efa0e5888489a42ae03b8b0a3e8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/release_spinlock" class="dashAnchor">&nbsp;</a><a href="#a16138efa0e5888489a42ae03b8b0a3e8">&#9670;&#160;</a></span>release_spinlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void release_spinlock </td>
          <td>(</td>
          <td class="paramtype">spinlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a previously acquired spinlock. </p>
<p>This will unblock any thread that is waiting on the spinlock. </p>

</div>
</div>
<a id="afb79c5c5f8993a88a73122af4d2108fc" name="afb79c5c5f8993a88a73122af4d2108fc"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/release_write_seqlock" class="dashAnchor">&nbsp;</a><a href="#afb79c5c5f8993a88a73122af4d2108fc">&#9670;&#160;</a></span>release_write_seqlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void release_write_seqlock </td>
          <td>(</td>
          <td class="paramtype">seqlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release a write lock on a seqlock. </p>
<p>This increments the counter before releasing the lock. </p>

</div>
</div>
<a id="a4e5341974a07906e4aa9e116eaf79cc3" name="a4e5341974a07906e4aa9e116eaf79cc3"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/remove_debugger_command" class="dashAnchor">&nbsp;</a><a href="#a4e5341974a07906e4aa9e116eaf79cc3">&#9670;&#160;</a></span>remove_debugger_command()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int remove_debugger_command </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">debugger_command_hook</td>          <td class="paramname"><span class="paramname"><em>hook</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a debugger command previously installed by <a class="el" href="#aabcab3a91e539d93094000ae3aa34874">add_debugger_command</a>. </p>
<p>It is important to remove the commands from a driver or module before it is unloaded, to avoid having commands that point to code that doesn't exist anymore. </p>

</div>
</div>
<a id="afb2a4d137cf6d933cfa9d2ec8e847512" name="afb2a4d137cf6d933cfa9d2ec8e847512"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/restore_interrupts" class="dashAnchor">&nbsp;</a><a href="#afb2a4d137cf6d933cfa9d2ec8e847512">&#9670;&#160;</a></span>restore_interrupts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void restore_interrupts </td>
          <td>(</td>
          <td class="paramtype">cpu_status</td>          <td class="paramname"><span class="paramname"><em>status</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restore interrupts to the previous state. </p>
<p>If interrupts were already disabled before the matching call to <a class="el" href="#a72fa1a0e57deaba8adf4f3deaf61de58">disable_interrupts</a>, do nothing. Otherwise, enable interrupts again. </p>

</div>
</div>
<a id="a94aac04f983cfac3fe77f6351cbda340" name="a94aac04f983cfac3fe77f6351cbda340"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/set_dprintf_enabled" class="dashAnchor">&nbsp;</a><a href="#a94aac04f983cfac3fe77f6351cbda340">&#9670;&#160;</a></span>set_dprintf_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool set_dprintf_enabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>new_state</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable dprintf log messages. </p>
<p>dprintf is used for debugging. It can be disabled to reduce the amount of logs from the kernel and drivers, which will also speed up the system in some cases. However, this makes debugging hardware and driver problems a lot more difficult. </p>

</div>
</div>
<a id="af81df33f3dc190048aa9c0215790eae0" name="af81df33f3dc190048aa9c0215790eae0"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/spawn_kernel_thread" class="dashAnchor">&nbsp;</a><a href="#af81df33f3dc190048aa9c0215790eae0">&#9670;&#160;</a></span>spawn_kernel_thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_id spawn_kernel_thread </td>
          <td>(</td>
          <td class="paramtype">thread_func</td>          <td class="paramname"><span class="paramname"><em>function</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a87905854573530ba20766196388ad2a1">int32</a></td>          <td class="paramname"><span class="paramname"><em>priority</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a kernel thread. </p>
<p>Similar to spawn_thread, but the thread will run in the kernel team. </p>

</div>
</div>
<a id="a55658e014bd73145dd09278148a6efca" name="a55658e014bd73145dd09278148a6efca"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/spin" class="dashAnchor">&nbsp;</a><a href="#a55658e014bd73145dd09278148a6efca">&#9670;&#160;</a></span>spin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void spin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a></td>          <td class="paramname"><span class="paramname"><em>microseconds</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Busy loop for the given time. </p>
<p>Some I/O operations may take a short while to complete. When the expected delay is less than a few hundred micrseconds, it is not worth locking the thread and calling the scheduler. In these situation, a busy loop is a better compromise, and the driver can continue its IO accesses in a reasonable time and without too many reschedulings. </p>

</div>
</div>
<a id="a27d43cda5bdbb3138ea9ed4cce3d4096" name="a27d43cda5bdbb3138ea9ed4cce3d4096"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/try_acquire_read_spinlock" class="dashAnchor">&nbsp;</a><a href="#a27d43cda5bdbb3138ea9ed4cce3d4096">&#9670;&#160;</a></span>try_acquire_read_spinlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_acquire_read_spinlock </td>
          <td>(</td>
          <td class="paramtype">rw_spinlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a rw_spinlock for reading, if available. </p>
<p>If the rw_spinlock is not currently write locked, add a read lock on it and return true. Otherwise, return false.</p>
<p>There can be multiple readers at the same time on an rw_spinlock, but there can be only one writer. </p>

</div>
</div>
<a id="a14928f8c093768ee25b38a86c59841d9" name="a14928f8c093768ee25b38a86c59841d9"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/try_acquire_write_seqlock" class="dashAnchor">&nbsp;</a><a href="#a14928f8c093768ee25b38a86c59841d9">&#9670;&#160;</a></span>try_acquire_write_seqlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_acquire_write_seqlock </td>
          <td>(</td>
          <td class="paramtype">seqlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a seqlock for writing, without waiting. </p>
<p>A seqlock is similar to an rw_spinlock in that it can be locked separately for reading and writing. However, it avoids writer starvation problems (when there are always reads being done and a writer can never acquire the write lock).</p>
<p>To achieve this, the readers are not actually locked. Instead, they are allowed to read the protected resource even while it is being written. The writer increments a counter whenever it acquires and releases the lock. When releasing a read lock, a reader can use this counter to compare against the value when it acquired its read lock. If the counter changed, that means there was a concurrent write access, and the read data is invalid. The reader can try to acquire a read lock again and read the updated value of the data. </p>

</div>
</div>
<a id="a2f25511f4aa660a5093b3afee70fd420" name="a2f25511f4aa660a5093b3afee70fd420"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/try_acquire_write_spinlock" class="dashAnchor">&nbsp;</a><a href="#a2f25511f4aa660a5093b3afee70fd420">&#9670;&#160;</a></span>try_acquire_write_spinlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_acquire_write_spinlock </td>
          <td>(</td>
          <td class="paramtype">rw_spinlock *</td>          <td class="paramname"><span class="paramname"><em>lock</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Acquire a rw_spinlock for writing, if available. </p>
<p>Check if no other thread is holding the lock, and in that case, acquires it immediately. Otherwise, return false. There is no wait for the rw_spinlock to become available.</p>
<p>Interrupts must be disabled, and recursive locking is not allowed. </p>

</div>
</div>
<a id="a85d833b56f3f70cf2b1933f88d691b97" name="a85d833b56f3f70cf2b1933f88d691b97"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/user_memcpy" class="dashAnchor">&nbsp;</a><a href="#a85d833b56f3f70cf2b1933f88d691b97">&#9670;&#160;</a></span>user_memcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> user_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy memory between userspace and kernelspace. </p>
<p>There are protections in place to avoid the kernel accidentally reading or writing to userspace memory. As a result, every access to userspace memory must be done with user_memcpy, user_strlcpy or user_memset.</p>
<p>For example, the buffers for a read, write or ioctl operation are handled in this way. </p>

</div>
</div>
<a id="a32e943a4b7f922f44129e75a5b2819ca" name="a32e943a4b7f922f44129e75a5b2819ca"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/user_memset" class="dashAnchor">&nbsp;</a><a href="#a32e943a4b7f922f44129e75a5b2819ca">&#9670;&#160;</a></span>user_memset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> user_memset </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>count</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set userspace memory. </p>
<p>Set memory to a specific byte value in the current userspace team. </p>

</div>
</div>
<a id="aeab13c9d9c7310125e5a80fcfc69b18f" name="aeab13c9d9c7310125e5a80fcfc69b18f"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Function/user_strlcpy" class="dashAnchor">&nbsp;</a><a href="#aeab13c9d9c7310125e5a80fcfc69b18f">&#9670;&#160;</a></span>user_strlcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t user_strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>to</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>from</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a string between userspace and kernel space. </p>
<p>Similar to strlcpy, but one of the source and destination must be in kernel space, and the other must be in userspace. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - KernelExport.h File Reference<br />
    Generated on Sat May 24 2025 23:12:16 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
