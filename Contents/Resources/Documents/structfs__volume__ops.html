<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: fs_volume_ops Struct Reference</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="structfs__volume__ops-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fs_volume_ops Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Operations vector for a volume.  
 <a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">General Operations</div></td></tr>
<tr class="memitem:aa1676e5e7ee8445b5597600a4d5705fb" id="r_aa1676e5e7ee8445b5597600a4d5705fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1676e5e7ee8445b5597600a4d5705fb">unmount</a> )(fs_volume *volume)</td></tr>
<tr class="memdesc:aa1676e5e7ee8445b5597600a4d5705fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts the given volume.  <br /></td></tr>
<tr class="separator:aa1676e5e7ee8445b5597600a4d5705fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8372d694a48671c1210018533eacbd" id="r_acc8372d694a48671c1210018533eacbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc8372d694a48671c1210018533eacbd">read_fs_info</a> )(fs_volume *volume, struct fs_info *info)</td></tr>
<tr class="memdesc:acc8372d694a48671c1210018533eacbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves general information about the volume.  <br /></td></tr>
<tr class="separator:acc8372d694a48671c1210018533eacbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4c9bcd3811563b84e187fc47b9518e" id="r_adb4c9bcd3811563b84e187fc47b9518e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb4c9bcd3811563b84e187fc47b9518e">write_fs_info</a> )(fs_volume *volume, const struct fs_info *info, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> mask)</td></tr>
<tr class="memdesc:adb4c9bcd3811563b84e187fc47b9518e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update filesystem information on the volume.  <br /></td></tr>
<tr class="separator:adb4c9bcd3811563b84e187fc47b9518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55195a725c0ad92f745de0ef8f44bebb" id="r_a55195a725c0ad92f745de0ef8f44bebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55195a725c0ad92f745de0ef8f44bebb">sync</a> )(fs_volume *volume)</td></tr>
<tr class="memdesc:a55195a725c0ad92f745de0ef8f44bebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize the cached data with the contents of the disk.  <br /></td></tr>
<tr class="separator:a55195a725c0ad92f745de0ef8f44bebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19ba0ea8ab896e6981ae95016fead91" id="r_ae19ba0ea8ab896e6981ae95016fead91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae19ba0ea8ab896e6981ae95016fead91">get_vnode</a> )(fs_volume *volume, ino_t id, fs_vnode *vnode, int *_type, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_flags, bool reenter)</td></tr>
<tr class="memdesc:ae19ba0ea8ab896e6981ae95016fead91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the private data handle to be associated with the node referred to by <em>id</em>.  <br /></td></tr>
<tr class="separator:ae19ba0ea8ab896e6981ae95016fead91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Index Directory and Operation</div></td></tr>
<tr class="memitem:ac5cf45722bf0bc6a0757725854410197" id="r_ac5cf45722bf0bc6a0757725854410197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5cf45722bf0bc6a0757725854410197">open_index_dir</a> )(fs_volume *volume, void **_cookie)</td></tr>
<tr class="memdesc:ac5cf45722bf0bc6a0757725854410197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the list of an indices as a directory.  <br /></td></tr>
<tr class="separator:ac5cf45722bf0bc6a0757725854410197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9edce070cae74117e5cc2e84e2774b" id="r_a1a9edce070cae74117e5cc2e84e2774b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a9edce070cae74117e5cc2e84e2774b">close_index_dir</a> )(fs_volume *volume, void *cookie)</td></tr>
<tr class="memdesc:a1a9edce070cae74117e5cc2e84e2774b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a 'directory' of indices.  <br /></td></tr>
<tr class="separator:a1a9edce070cae74117e5cc2e84e2774b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd23b60db25a0dd47c9ead620d00a98" id="r_afdd23b60db25a0dd47c9ead620d00a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdd23b60db25a0dd47c9ead620d00a98">free_index_dir_cookie</a> )(fs_volume *volume, void *cookie)</td></tr>
<tr class="memdesc:afdd23b60db25a0dd47c9ead620d00a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the <em>cookie</em> to the index 'directory'.  <br /></td></tr>
<tr class="separator:afdd23b60db25a0dd47c9ead620d00a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4976e57256a71208d7d6ee54a8cf05b7" id="r_a4976e57256a71208d7d6ee54a8cf05b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4976e57256a71208d7d6ee54a8cf05b7">read_index_dir</a> )(fs_volume *volume, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td></tr>
<tr class="memdesc:a4976e57256a71208d7d6ee54a8cf05b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next one or more index entries.  <br /></td></tr>
<tr class="separator:a4976e57256a71208d7d6ee54a8cf05b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4467a1f2287fa4742820fc11098569f5" id="r_a4467a1f2287fa4742820fc11098569f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4467a1f2287fa4742820fc11098569f5">rewind_index_dir</a> )(fs_volume *volume, void *cookie)</td></tr>
<tr class="memdesc:a4467a1f2287fa4742820fc11098569f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the index directory cookie to the first entry of the directory.  <br /></td></tr>
<tr class="separator:a4467a1f2287fa4742820fc11098569f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073d2a769f0455e3d57612fe656dd4ae" id="r_a073d2a769f0455e3d57612fe656dd4ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a073d2a769f0455e3d57612fe656dd4ae">create_index</a> )(fs_volume *volume, const char *name, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> type, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td></tr>
<tr class="memdesc:a073d2a769f0455e3d57612fe656dd4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new index.  <br /></td></tr>
<tr class="separator:a073d2a769f0455e3d57612fe656dd4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a58f6c5ecc18549218aa8a33cd60b7c" id="r_a3a58f6c5ecc18549218aa8a33cd60b7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a58f6c5ecc18549218aa8a33cd60b7c">remove_index</a> )(fs_volume *volume, const char *name)</td></tr>
<tr class="memdesc:a3a58f6c5ecc18549218aa8a33cd60b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the index with <em>name</em>.  <br /></td></tr>
<tr class="separator:a3a58f6c5ecc18549218aa8a33cd60b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0255483f93ae7d2f8369bfe8786b10" id="r_aea0255483f93ae7d2f8369bfe8786b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea0255483f93ae7d2f8369bfe8786b10">read_index_stat</a> )(fs_volume *volume, const char *name, struct stat *stat)</td></tr>
<tr class="memdesc:aea0255483f93ae7d2f8369bfe8786b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the <em>stat</em> of the index with a name.  <br /></td></tr>
<tr class="separator:aea0255483f93ae7d2f8369bfe8786b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Query Operations</div></td></tr>
<tr class="memitem:a8823449daefcf0cdb091e07a20960ae6" id="r_a8823449daefcf0cdb091e07a20960ae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8823449daefcf0cdb091e07a20960ae6">open_query</a> )(fs_volume *volume, const char *query, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags, port_id port, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> token, void **_cookie)</td></tr>
<tr class="memdesc:a8823449daefcf0cdb091e07a20960ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a query as a 'directory'.  <br /></td></tr>
<tr class="separator:a8823449daefcf0cdb091e07a20960ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfddc7c9bd13f8b3025c7b041fd2d95" id="r_abbfddc7c9bd13f8b3025c7b041fd2d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbfddc7c9bd13f8b3025c7b041fd2d95">close_query</a> )(fs_volume *volume, void *cookie)</td></tr>
<tr class="memdesc:abbfddc7c9bd13f8b3025c7b041fd2d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a 'directory' of a query.  <br /></td></tr>
<tr class="separator:abbfddc7c9bd13f8b3025c7b041fd2d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8341a851110d6ab3f40333561971c2cd" id="r_a8341a851110d6ab3f40333561971c2cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8341a851110d6ab3f40333561971c2cd">free_query_cookie</a> )(fs_volume *volume, void *cookie)</td></tr>
<tr class="memdesc:a8341a851110d6ab3f40333561971c2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a cookie of a query.  <br /></td></tr>
<tr class="separator:a8341a851110d6ab3f40333561971c2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588b1a2fec2aed96dd95e0b600c483c8" id="r_a588b1a2fec2aed96dd95e0b600c483c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a588b1a2fec2aed96dd95e0b600c483c8">read_query</a> )(fs_volume *volume, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td></tr>
<tr class="memdesc:a588b1a2fec2aed96dd95e0b600c483c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the next one or more entries matching the query.  <br /></td></tr>
<tr class="separator:a588b1a2fec2aed96dd95e0b600c483c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0582cfdfd7e8043184501bb18d7cb864" id="r_a0582cfdfd7e8043184501bb18d7cb864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0582cfdfd7e8043184501bb18d7cb864">rewind_query</a> )(fs_volume *volume, void *cookie)</td></tr>
<tr class="memdesc:a0582cfdfd7e8043184501bb18d7cb864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the query cookie to the first entry of the results.  <br /></td></tr>
<tr class="separator:a0582cfdfd7e8043184501bb18d7cb864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">FS Layer Operations</div></td></tr>
<tr class="memitem:a1032c35cb6e7c5dadc64b3bcfaf87a1f" id="r_a1032c35cb6e7c5dadc64b3bcfaf87a1f"><td class="memItemLeft" align="right" valign="top"><a id="a1032c35cb6e7c5dadc64b3bcfaf87a1f" name="a1032c35cb6e7c5dadc64b3bcfaf87a1f"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>all_layers_mounted</b> )(fs_volume *volume)</td></tr>
<tr class="memdesc:a1032c35cb6e7c5dadc64b3bcfaf87a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a1032c35cb6e7c5dadc64b3bcfaf87a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edad4eda5f267e201498dd1e5e724bd" id="r_a3edad4eda5f267e201498dd1e5e724bd"><td class="memItemLeft" align="right" valign="top"><a id="a3edad4eda5f267e201498dd1e5e724bd" name="a3edad4eda5f267e201498dd1e5e724bd"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>create_sub_vnode</b> )(fs_volume *volume, ino_t id, fs_vnode *vnode)</td></tr>
<tr class="memdesc:a3edad4eda5f267e201498dd1e5e724bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a3edad4eda5f267e201498dd1e5e724bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d22f56adabf29247ed5354df3f6209" id="r_a38d22f56adabf29247ed5354df3f6209"><td class="memItemLeft" align="right" valign="top"><a id="a38d22f56adabf29247ed5354df3f6209" name="a38d22f56adabf29247ed5354df3f6209"></a>
<a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>delete_sub_vnode</b> )(fs_volume *volume, fs_vnode *vnode)</td></tr>
<tr class="memdesc:a38d22f56adabf29247ed5354df3f6209"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: Document! <br /></td></tr>
<tr class="separator:a38d22f56adabf29247ed5354df3f6209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Operations vector for a volume. </p>
<p>See the <a class="el" href="fs_modules.html">introduction to file system modules</a> for an introduction to writing file systems. </p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a1a9edce070cae74117e5cc2e84e2774b" name="a1a9edce070cae74117e5cc2e84e2774b"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/close_index_dir" class="dashAnchor">&nbsp;</a><a href="#a1a9edce070cae74117e5cc2e84e2774b">&#9670;&#160;</a></span>close_index_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::close_index_dir) (fs_volume *volume, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a 'directory' of indices. </p>
<p>Note that you should free the cookie in the <a class="el" href="#afdd23b60db25a0dd47c9ead620d00a98" title="Free the cookie to the index &#39;directory&#39;.">free_index_dir_cookie()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie associated with this 'directory'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B_OK if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="abbfddc7c9bd13f8b3025c7b041fd2d95" name="abbfddc7c9bd13f8b3025c7b041fd2d95"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/close_query" class="dashAnchor">&nbsp;</a><a href="#abbfddc7c9bd13f8b3025c7b041fd2d95">&#9670;&#160;</a></span>close_query</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::close_query) (fs_volume *volume, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a 'directory' of a query. </p>
<p>Note that you should free the cookie in the <a class="el" href="#a8341a851110d6ab3f40333561971c2cd" title="Free a cookie of a query.">free_query_cookie()</a> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie that refers to this query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return <code>B_OK</code> if the creation succeeded, or return an error otherwise. </dd></dl>

</div>
</div>
<a id="a073d2a769f0455e3d57612fe656dd4ae" name="a073d2a769f0455e3d57612fe656dd4ae"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/create_index" class="dashAnchor">&nbsp;</a><a href="#a073d2a769f0455e3d57612fe656dd4ae">&#9670;&#160;</a></span>create_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::create_index) (fs_volume *volume, const char *name, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> type, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the new index. </td></tr>
    <tr><td class="paramname">type</td><td>The type of index. BFS implements the following types:<ul>
<li><code>B_INT32_TYPE</code> </li>
<li><code>B_UINT32_TYPE</code> </li>
<li><code>B_INT64_TYPE</code> </li>
<li><code>B_UINT64_TYPE</code> </li>
<li><code>B_FLOAT_TYPE</code> </li>
<li><code>B_DOUBLE_TYPE</code> </li>
<li><code>B_STRING_TYPE</code> </li>
<li><code>B_MIME_STRING_TYPE</code> </li>
</ul>
</td></tr>
    <tr><td class="paramname">flags</td><td>There are currently no extra flags specified. This parameter can be ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return <code>B_OK</code> if the creation succeeded, or return an error otherwise. </dd></dl>

</div>
</div>
<a id="afdd23b60db25a0dd47c9ead620d00a98" name="afdd23b60db25a0dd47c9ead620d00a98"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/free_index_dir_cookie" class="dashAnchor">&nbsp;</a><a href="#afdd23b60db25a0dd47c9ead620d00a98">&#9670;&#160;</a></span>free_index_dir_cookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::free_index_dir_cookie) (fs_volume *volume, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the <em>cookie</em> to the index 'directory'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie that should be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B_OK if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a8341a851110d6ab3f40333561971c2cd" name="a8341a851110d6ab3f40333561971c2cd"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/free_query_cookie" class="dashAnchor">&nbsp;</a><a href="#a8341a851110d6ab3f40333561971c2cd">&#9670;&#160;</a></span>free_query_cookie</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::free_query_cookie) (fs_volume *volume, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a cookie of a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The cookie that should be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return <code>B_OK</code> if the creation succeeded, or return an error otherwise. </dd></dl>

</div>
</div>
<a id="ae19ba0ea8ab896e6981ae95016fead91" name="ae19ba0ea8ab896e6981ae95016fead91"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/get_vnode" class="dashAnchor">&nbsp;</a><a href="#ae19ba0ea8ab896e6981ae95016fead91">&#9670;&#160;</a></span>get_vnode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::get_vnode) (fs_volume *volume, ino_t id, fs_vnode *vnode, int *_type, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_flags, bool reenter)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the private data handle to be associated with the node referred to by <em>id</em>. </p>
<p>Invoked by the VFS when it creates the vnode for the respective node. When the VFS no longer needs the vnode in memory (for example when memory is becoming tight), it will your file_system_module_info::put_vnode(), or file_system_module_info::remove_vnode() in case the vnode has been marked removed.</p>
<p>The hook has to initialize <em>vnode-&gt;private_node</em> with its handle created for the node and <em>vnode-&gt;ops</em> with the operation vector for the node. It also has to set <code>*_type</code> to the type of the node &ndash; as in <code>stat::st_mode</code> (the non-type bits can, but do not need to be cleared) &ndash; and <code>*_flags</code> to a bitwise OR of vnode flags to apply (cf. <a class="el" href="fs__interface_8h.html#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a> for what flags bits are possible).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">id</td><td>The ID of the node. </td></tr>
    <tr><td class="paramname">vnode</td><td>Pointer to a node object to be initialized. </td></tr>
    <tr><td class="paramname">_type</td><td>Pointer to a variable to be set to the node's type. </td></tr>
    <tr><td class="paramname">_flags</td><td>Pointer to a variable to be set to flags to apply to the vnode. </td></tr>
    <tr><td class="paramname">reenter</td><td><code>true</code> if the hook invocation has been caused by the FS itself, e.g. by invoking <a class="el" href="#ae19ba0ea8ab896e6981ae95016fead91" title="Creates the private data handle to be associated with the node referred to by id.">get_vnode()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="ac5cf45722bf0bc6a0757725854410197" name="ac5cf45722bf0bc6a0757725854410197"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/open_index_dir" class="dashAnchor">&nbsp;</a><a href="#ac5cf45722bf0bc6a0757725854410197">&#9670;&#160;</a></span>open_index_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::open_index_dir) (fs_volume *volume, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the list of an indices as a directory. </p>
<p>See <a class="el" href="fs_modules.html#concepts">Generic Concepts</a> on directories and iterators. Basically, the VFS uses the same way of traversing through indeces as it traverses through a directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_cookie</td><td>Pointer where the file system can store a directory cookie if the index directory is succesfully opened. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a8823449daefcf0cdb091e07a20960ae6" name="a8823449daefcf0cdb091e07a20960ae6"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/open_query" class="dashAnchor">&nbsp;</a><a href="#a8823449daefcf0cdb091e07a20960ae6">&#9670;&#160;</a></span>open_query</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::open_query) (fs_volume *volume, const char *query, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> flags, port_id port, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> token, void **_cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a query as a 'directory'. </p>
<p>TODO: query expressions should be documented and also the format for sending query updates over the port should be updated.</p>
<p>See <a class="el" href="fs_modules.html#concepts">Generic Concepts</a> on directories and iterators. Basically, the VFS uses the same way of traversing through indices as it traverses through a directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">query</td><td>The string that represents a query. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>Any combination of none or more of these flags:<ul>
<li><code>B_LIVE_QUERY</code> The query is live. When a query is live, it is constantly updated using the <em>port</em>. The FS must invoke the functions <a class="el" href="fs__interface_8h.html#a4a9de58136e078f3b99430a07b5e096e" title="Notifies listeners that an entry has entered the result set of a live query.">notify_query_entry_created()</a> and <a class="el" href="fs__interface_8h.html#a65efb61891fd7f412b7a06401f0e8e1a" title="Notifies listeners that an entry has left the result set of a live query.">notify_query_entry_removed()</a> whenever an entry starts respectively stops to match the query predicate.</li>
<li><code>B_QUERY_NON_INDEXED</code> Normally at least one of the attributes used in the query string should be indexed. If none is, this hook is allowed to fail, unless this flag is specified. Usually an implementation will simply add a wildcard match for any complete index ("name", "last_modified", or "size") to the query expression. </li>
</ul>
</td></tr>
    <tr><td class="paramdir"></td><td class="paramname">port</td><td>The id of the port where updates need to be sent to in case the query is live. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">token</td><td>A token that should be attached to the messages sent over the <em>port</em>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">_cookie</td><td>The cookie that will be used as 'directory' to traverse through the results of the query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return <code>B_OK</code> if the creation succeeded, or return an error otherwise. </dd></dl>

</div>
</div>
<a id="acc8372d694a48671c1210018533eacbd" name="acc8372d694a48671c1210018533eacbd"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_fs_info" class="dashAnchor">&nbsp;</a><a href="#acc8372d694a48671c1210018533eacbd">&#9670;&#160;</a></span>read_fs_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::read_fs_info) (fs_volume *volume, struct fs_info *info)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves general information about the volume. </p>
<p>The following fields of the <code>fs_info</code> structure need to be filled in:</p><ul>
<li><code>flags:</code> Flags applying to the volume, e.g. <code>B_FS_IS_READONLY</code>, <code>B_FS_HAS_ATTR</code>, etc.</li>
<li><code>block_size:</code> The size of blocks the volume data are organized in. Meaningful mainly for disk-based FSs, other FSs should use some reasonable value for computing <code>total_blocks</code> and <code>free_blocks</code>.</li>
<li><code>io_size:</code> Preferred size of the buffers passed to read() and write().</li>
<li><code>total_blocks:</code> Total number of blocks the volume contains.</li>
<li><code>free_blocks:</code> Number of free blocks on the volume.</li>
<li><code>total_nodes:</code> Maximal number of nodes the volume can contain. If there is no such limitation use <code>LONGLONG_MAX</code>.</li>
<li><code>free_nodes:</code> Number of additional nodes the volume could contain. If there is no such limitation use <code>LONGLONG_MAX</code>.</li>
<li><code>volume_name:</code> The name of the volume.</li>
</ul>
<p>The other values are filled in by the VFS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">info</td><td>Pointer to a pre-allocated variable the FS info shall be written to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. The error code will be ignored, though. </dd></dl>

</div>
</div>
<a id="a4976e57256a71208d7d6ee54a8cf05b7" name="a4976e57256a71208d7d6ee54a8cf05b7"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_index_dir" class="dashAnchor">&nbsp;</a><a href="#a4976e57256a71208d7d6ee54a8cf05b7">&#9670;&#160;</a></span>read_index_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::read_index_dir) (fs_volume *volume, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next one or more index entries. </p>
<p>This method should perform the same task as <a class="el" href="structfs__vnode__ops.html#a9db0d6e2faacb789b7c12e14b915e412" title="Reads the next one or more directory entries.">fs_vnode_ops::read_dir()</a>, except that the '.' and the '..' entries don't have to be present. </p>

</div>
</div>
<a id="aea0255483f93ae7d2f8369bfe8786b10" name="aea0255483f93ae7d2f8369bfe8786b10"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_index_stat" class="dashAnchor">&nbsp;</a><a href="#aea0255483f93ae7d2f8369bfe8786b10">&#9670;&#160;</a></span>read_index_stat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::read_index_stat) (fs_volume *volume, const char *name, struct stat *stat)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the <em>stat</em> of the index with a name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the index to be queried. </td></tr>
    <tr><td class="paramname">stat</td><td>A pointer to a structure where you should store the values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return <code>B_OK</code> if the creation succeeded, or return an error otherwise. </dd></dl>

</div>
</div>
<a id="a588b1a2fec2aed96dd95e0b600c483c8" name="a588b1a2fec2aed96dd95e0b600c483c8"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/read_query" class="dashAnchor">&nbsp;</a><a href="#a588b1a2fec2aed96dd95e0b600c483c8">&#9670;&#160;</a></span>read_query</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::read_query) (fs_volume *volume, void *cookie, struct dirent *buffer, size_t bufferSize, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> *_num)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the next one or more entries matching the query. </p>
<p>This hook function works pretty much the same way as <a class="el" href="structfs__vnode__ops.html#a9db0d6e2faacb789b7c12e14b915e412" title="Reads the next one or more directory entries.">fs_vnode_ops::read_dir()</a>, with the difference that it doesn't read the entries of a directory, but the entries matching the given query. Unlike the <a class="el" href="structfs__vnode__ops.html#a9db0d6e2faacb789b7c12e14b915e412" title="Reads the next one or more directory entries.">fs_vnode_ops::read_dir()</a> hook, this hook also has to fill in the dirent::d_pino field.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The query cookie as returned by <a class="el" href="#a8823449daefcf0cdb091e07a20960ae6" title="Open a query as a &#39;directory&#39;.">open_query()</a>. </td></tr>
    <tr><td class="paramname">buffer</td><td>Pointer to a pre-allocated buffer the directory entries shall be written to. </td></tr>
    <tr><td class="paramname">bufferSize</td><td>The size of <em>buffer</em> in bytes. </td></tr>
    <tr><td class="paramname">_num</td><td>Pointer to a pre-allocated variable, when invoked, containing the number of entries to be read, and into which the number of entries actually read shall be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a3a58f6c5ecc18549218aa8a33cd60b7c" name="a3a58f6c5ecc18549218aa8a33cd60b7c"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/remove_index" class="dashAnchor">&nbsp;</a><a href="#a3a58f6c5ecc18549218aa8a33cd60b7c">&#9670;&#160;</a></span>remove_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::remove_index) (fs_volume *volume, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove the index with <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the index to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>You should return <code>B_OK</code> if the creation succeeded, or return an error otherwise. </dd></dl>

</div>
</div>
<a id="a4467a1f2287fa4742820fc11098569f5" name="a4467a1f2287fa4742820fc11098569f5"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/rewind_index_dir" class="dashAnchor">&nbsp;</a><a href="#a4467a1f2287fa4742820fc11098569f5">&#9670;&#160;</a></span>rewind_index_dir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::rewind_index_dir) (fs_volume *volume, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the index directory cookie to the first entry of the directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The directory cookie as returned by <a class="el" href="#ac5cf45722bf0bc6a0757725854410197" title="Open the list of an indices as a directory.">open_index_dir()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a0582cfdfd7e8043184501bb18d7cb864" name="a0582cfdfd7e8043184501bb18d7cb864"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/rewind_query" class="dashAnchor">&nbsp;</a><a href="#a0582cfdfd7e8043184501bb18d7cb864">&#9670;&#160;</a></span>rewind_query</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::rewind_query) (fs_volume *volume, void *cookie)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the query cookie to the first entry of the results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">cookie</td><td>The query cookie as returned by <a class="el" href="#a8823449daefcf0cdb091e07a20960ae6" title="Open a query as a &#39;directory&#39;.">open_query()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. </dd></dl>

</div>
</div>
<a id="a55195a725c0ad92f745de0ef8f44bebb" name="a55195a725c0ad92f745de0ef8f44bebb"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/sync" class="dashAnchor">&nbsp;</a><a href="#a55195a725c0ad92f745de0ef8f44bebb">&#9670;&#160;</a></span>sync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::sync) (fs_volume *volume)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize the cached data with the contents of the disk. </p>
<p>The VFS layer sometimes wants you to synchronize any cached values with the data on the device.</p>
<p>This currently only happens when the POSIX <a class="el" href="#a55195a725c0ad92f745de0ef8f44bebb" title="Synchronize the cached data with the contents of the disk.">sync()</a> function is invoked, for example via the "sync" command line tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1676e5e7ee8445b5597600a4d5705fb" name="aa1676e5e7ee8445b5597600a4d5705fb"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/unmount" class="dashAnchor">&nbsp;</a><a href="#aa1676e5e7ee8445b5597600a4d5705fb">&#9670;&#160;</a></span>unmount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::unmount) (fs_volume *volume)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts the given volume. </p>
<p>Invoked by the VFS when it is asked to unmount the volume. The function must free all resources associated with the mounted volume, including the volume handle. Before <a class="el" href="#aa1676e5e7ee8445b5597600a4d5705fb" title="Unmounts the given volume.">unmount()</a> is called, the VFS calls file_system_module_info::put_vnode() respectively file_system_module_info::remove_vnode() for each of the volume's nodes. That is although the mount() hook called <a class="el" href="fs__interface_8h.html#a72ca7437ee63b0b91ade75d2d0a24413" title="Creates the vnode with ID vnodeID and associates it with the private data handle privateNode or just ...">publish_vnode()</a> for the volume's root node, <a class="el" href="#aa1676e5e7ee8445b5597600a4d5705fb" title="Unmounts the given volume.">unmount()</a> must not invoke <a class="el" href="fs__interface_8h.html#aca3e130d24090e360ed261d7e189df37" title="Surrenders a reference to the specified vnode.">put_vnode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, another error code otherwise. The error code will be ignored, though. </dd></dl>

</div>
</div>
<a id="adb4c9bcd3811563b84e187fc47b9518e" name="adb4c9bcd3811563b84e187fc47b9518e"></a>
<h2 class="memtitle"><span class="permalink"><a name="//apple_ref/cpp/Variable/write_fs_info" class="dashAnchor">&nbsp;</a><a href="#adb4c9bcd3811563b84e187fc47b9518e">&#9670;&#160;</a></span>write_fs_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a>(* fs_volume_ops::write_fs_info) (fs_volume *volume, const struct fs_info *info, <a class="el" href="SupportDefs_8h.html#a9a72138d173e1e5243078b8644d4a1c2">uint32</a> mask)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update filesystem information on the volume. </p>
<p>You are requested to update certain information on the given volume. The supplied <em>info</em> contains the new values filled in for the <em>mask</em>. Currently, the only possible mask is solely the <code>FS_WRITE_FSINFO_NAME</code>, which asks you to update the volume name represented by the value <code>volume_name</code> in the <code>fs_info</code> struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">volume</td><td>The volume object. </td></tr>
    <tr><td class="paramname">info</td><td>The structure that contains the new data. </td></tr>
    <tr><td class="paramname">mask</td><td>The values of the <em>info</em> that need to be updated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_OK</code> if everything went fine, if not, one of the error codes. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - fs_volume_ops Struct Reference<br />
    Generated on Sat May 24 2025 23:12:20 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
