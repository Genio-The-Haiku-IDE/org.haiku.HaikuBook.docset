<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.12.0"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: Writing drivers for USB devices</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Writing drivers for USB devices</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The introduction of USB standardized the way many devices connected to a whole range of different computers and operating systems. It introduced a standard that was capable of getting rid of all the legacy systems, such as the LPT, the PS/2 and serial ports. The plug and play nature of the standard was revolutionary at the time of its introduction, and it changed the way which operating systems interacted with devices.</p>
<p>With the grand standard that USB has become, Haiku has an implementation of it. It supports both the USB 1.1 and USB 2.0 specifications, and when Haiku R1 is released, it will support the three host controller standards: UHCI, OHCI and EHCI. The modularized design of Haiku's USB stack also paves the way for easy implementation of any future specifications, such as Wireless USB.</p>
<h1><a class="anchor" id="usb_modules_scope"></a>
The Scope of this Document</h1>
<p>This document is written for driver developers that need to interact with USB devices. The USB specification standardizes the communication between the host controller and the devices, and how devices should transfer data, but it does not prescribe a standard environment that Operating Systems should provide to the driver interfaces. As such, every operating system has its own interface for drivers, and so does Haiku.</p>
<p>This document will point driver developers to relevant parts of the USB module API and give a general impression of the workings of the USB stack. This document will not give information on the basics of writing drivers, or on how to use modules. Have a look elsewhere in this documentation for that. This document also assumes a basic knowledge of the USB specification, and on how you are supposed to interact with devices. See <a class="el" href="#usb_modules_resources">More Resources</a> for tutorials on the web if you are looking for a basic introduction on communication with the USB protocol.</p>
<h1><a class="anchor" id="usb_modules_structure"></a>
Structure of the Stack</h1>
<p>This section will outline how Haiku's USB stack is structured, and how you can interact with this stack.</p>
<p>The goal of the USB stack is to provide a few basic features for drivers interacting with USB devices. It is important that the stack maintains a continually updated device grid, so that the driver modules are always aware of the latest status. The stack should also facilitate communication between drivers and the devices, by abstracting the actual transferring of bits via the host controller hardware in the computer. The stack therefore should implement a intuitive interface to give driver developers access to all features and possibilities the USB specification offers, and at the same time it should abstract many of the small requirements and peculiarities of that specification.</p>
<p>The stack internally can be divided into two parts. The first part is the core module. This module, called <code>usb_busmanager</code>, performs all the operations required by the USB specification. For example, it performs the necessary low-level initialization when new devices are connected, or all the requirements when it comes to performing transfers. The core module also is the module that provides the abstractions to driver developers. The other part of the USB stack are the individual modules that control the different host controllers. Haiku supports the three types in existence: UHCI, OHCI and EHCI. These modules perform the communication between the core module and the hardware. As driver developer, you won't have to interact with these modules: the core module provides all the abstractions you need.</p>
<p>Thus, as a driver developer you are interfacing with the <code>usb_busmanager</code> module. On Haiku, this module implements two API's. The <code>v2</code> API, identical to the API offered by BeOS R5, can be found in the <code>USB2.h</code> file. However, for new drivers, or for ports, the recommended API is the <code>v3</code> API, defined in the <a class="el" href="USB3_8h.html" title="Interface for the USB module.">USB3.h</a> file. This API is identical to the one provided by Zeta. The <code>v2</code> API should be considered to be deprecated.</p>
<h1><a class="anchor" id="usb_modules_registration"></a>
Initial Steps: Driver Registration</h1>
<p>In order to be able to start using the USB stack to communicate with your devices, you will need to perform some actions. This section will outline those actions and will point you to their appropriate locations.</p>
<dl class="section note"><dt>Note</dt><dd>The code examples are based on the <code>usb_hid</code> driver written by Jerome Duval. Have a look at this driver for a complete working example.</dd></dl>
<p>The following example gives an overview of the requirements to open the USB module, and to start your driver registration in order to receive connect and disconnect events.</p>
<div class="fragment"><div class="line"><span class="comment">// Global variables and constants</span></div>
<div class="line"><a class="code hl_struct" href="structusb__module__info.html">usb_module_info</a> *gUsb;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> *kDriverName = <span class="stringliteral">&quot;usb_hid&quot;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structusb__support__descriptor.html">usb_support_descriptor</a> sSupportedDevices[1] = {</div>
<div class="line">    { USB_HID_DEVICE_CLASS, 0, 0, 0, 0 },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Prototype for the hooks that are called when devices are added or removed</span></div>
<div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> hid_device_added(<span class="keyword">const</span> <a class="code hl_typedef" href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a> *dev, <span class="keywordtype">void</span> **cookie);</div>
<div class="line"><span class="keyword">static</span> <a class="code hl_typedef" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> hid_device_removed(<span class="keywordtype">void</span> *cookie);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <a class="code hl_struct" href="structusb__notify__hooks.html">usb_notify_hooks</a> sNotifyHooks = {</div>
<div class="line">    hid_device_added,</div>
<div class="line">    hid_device_removed</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Driver initialization, called by the kernel when the driver is loaded</span></div>
<div class="line"><a class="code hl_typedef" href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a> </div>
<div class="line">init_driver(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (get_module(<a class="code hl_define" href="USB3_8h.html#a22b89f939badbd5ede71f3830811aeb5">B_USB_MODULE_NAME</a>, (module_info **)&amp;gUsb) != B_OK)</div>
<div class="line">        <span class="keywordflow">return</span> B_ERROR;</div>
<div class="line"> </div>
<div class="line">    gUsb-&gt;register_driver(kDriverName, sSupportedDevices, </div>
<div class="line">        1, <a class="code hl_define" href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>);</div>
<div class="line">    gUsb-&gt;install_notify(kDriverName, &amp;sNotifyHooks);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> B_OK;</div>
<div class="line">}</div>
<div class="ttc" id="aSupportDefs_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="SupportDefs_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Defines the constant NULL if it hasn't already been defined.</div><div class="ttdef"><b>Definition</b> SupportDefs.h:226</div></div>
<div class="ttc" id="aSupportDefs_8h_html_ab6735558965995709a53691ae913c81b"><div class="ttname"><a href="SupportDefs_8h.html#ab6735558965995709a53691ae913c81b">status_t</a></div><div class="ttdeci">int32 status_t</div><div class="ttdoc">Represents one of the status codes defined in Errors.h.</div><div class="ttdef"><b>Definition</b> SupportDefs.h:52</div></div>
<div class="ttc" id="aUSB3_8h_html_a22b89f939badbd5ede71f3830811aeb5"><div class="ttname"><a href="USB3_8h.html#a22b89f939badbd5ede71f3830811aeb5">B_USB_MODULE_NAME</a></div><div class="ttdeci">#define B_USB_MODULE_NAME</div><div class="ttdoc">The identifier string for the USB Stack interface module.</div><div class="ttdef"><b>Definition</b> USB3.h:261</div></div>
<div class="ttc" id="aUSB3_8h_html_a3d37000991026944a475b007c6f4fd28"><div class="ttname"><a href="USB3_8h.html#a3d37000991026944a475b007c6f4fd28">usb_device</a></div><div class="ttdeci">usb_id usb_device</div><div class="ttdoc">Uniquely identify USB devices.</div><div class="ttdef"><b>Definition</b> USB3.h:25</div></div>
<div class="ttc" id="astructusb__module__info_html"><div class="ttname"><a href="structusb__module__info.html">usb_module_info</a></div><div class="ttdoc">Interface for drivers to interact with Haiku's USB stack.</div><div class="ttdef"><b>Definition</b> USB3.h:85</div></div>
<div class="ttc" id="astructusb__notify__hooks_html"><div class="ttname"><a href="structusb__notify__hooks.html">usb_notify_hooks</a></div><div class="ttdoc">Hooks that the USB stack can callback in case of events.</div><div class="ttdef"><b>Definition</b> USB3.h:34</div></div>
<div class="ttc" id="astructusb__support__descriptor_html"><div class="ttname"><a href="structusb__support__descriptor.html">usb_support_descriptor</a></div><div class="ttdoc">Description of device descriptor that the driver can handle.</div><div class="ttdef"><b>Definition</b> USB3.h:39</div></div>
</div><!-- fragment --><p>Basically, this boils down to three steps. The first step is to acquire the <a class="el" href="structusb__module__info.html" title="Interface for drivers to interact with Haiku&#39;s USB stack.">usb_module_info</a> module. This struct contains a set of function pointers that you use to communicate with the stack. You can retrieve it like you would retrieve any other module.</p>
<p>As soon as you have done that you can start registering your driver in the stack. What you do is you pass a unique identifier to identify your driver, zero or more <a class="el" href="structusb__support__descriptor.html">support descriptors </a> to provide the stack with information on which devices you support, and the number of support descriptors you provided. The stack is very flexible with what patterns it accepts, so even the most complex driver will be able to pass its credentials. Have a look at the <code><a class="el" href="structusb__support__descriptor.html" title="Description of device descriptor that the driver can handle.">usb_support_descriptor</a></code> struct and the <code><a class="el" href="structusb__module__info.html#a2b2c925bdcf6c4fb1340aae74bf03a38" title="Register your driver.">usb_module_info::register_driver()</a></code> call for all the details.</p>
<p>The last step in initialization is to provide the stack with notification hooks. These are functions in your driver that the stack should call as soon as a device is attached or removed. Please perform this call after your internal driver data structures are initialized, because as soon as you perform this call, the usb stack will start searching for already attached devices that match the credentials. Have a look at <code><a class="el" href="structusb__module__info.html#afa9e83256575eba0371a6330c5550214" title="Install notify hooks for your driver.">usb_module_info::install_notify()</a></code> and the structure <code><a class="el" href="structusb__notify__hooks.html" title="Hooks that the USB stack can callback in case of events.">usb_notify_hooks</a></code> for the details on the signatures of your hooks.</p>
<h1><a class="anchor" id="usb_modules_changes"></a>
Handling Device Changes</h1>
<p>The USB stack will notify you of device connects and disconnects when they occur. You will receive notifications as soon as you have supplied the hooks to the stack, using <code><a class="el" href="structusb__module__info.html#afa9e83256575eba0371a6330c5550214" title="Install notify hooks for your driver.">usb_module_info::install_notify()</a></code> . This section will explain some of the details when it comes to handling device changes.</p>
<p>When a device is added, your supplied <a class="el" href="structusb__notify__hooks.html#adfa0d6a4f35e74e5274ae42831970c50" title="Called by the stack in case a device is added.">usb_notify_hooks::device_added()</a> hook will be called if its credentials matches one of your support descriptors. Because the stack runs through all the registered drivers, it could be that two or more drivers operate on the same device. The stack does not provide a locking mechanism to prevent two conflicting drivers to get in each others way. It is up to the device maker to have supplied such a mechanism.</p>
<dl class="section note"><dt>Note</dt><dd>In reality, it is very likely that your device will match at least one other driver, because Haiku supplies the <code>usb_raw</code> driver. This driver provides userland access to the usb devices and therefore it has a blank support descriptor that matches everything. The <code>usb_raw</code> driver will not conflict with your device interaction though (except when there is an userland application that tries to meddle with your device).</dd></dl>
<p>If your driver is willing to accept the supplied device, and your device_added() hook returns B_OK, the USB stack will ask the kernel to reload your published devices, so that your device is visible in userspace in the <code>/dev</code> tree.</p>
<p>The other event that the stack reports, device disconnection, should be handled by your <code><a class="el" href="structusb__notify__hooks.html#a8593a3f8e6f0ab4caed5bd0317e56909" title="Called by the stack in case a device you are using is removed.">usb_notify_hooks::device_removed()</a></code> hook. Because "plug and
	play" also means "unplug and leave", you should make sure your driver is capable of cleaning up in the likely event that the user removes their device, even during transfers. In your hook function, you have the ability to do clean up whatever there is to clean up, however, make sure that you cancel all the pending transfers. Use the <a class="el" href="structusb__module__info.html#a3fe38fcd6924611608d8958c6814f93e" title="Cancel pending transfers on a pipe. All the pending transfers will be cancelled. The stack will perfo...">usb_module_info::cancel_queued_transfers()</a> call for that end. Also, don't forget to free the cookie you supplied in your device_added() hook.</p>
<h1><a class="anchor" id="usb_modules_standard"></a>
Standard USB Operations</h1>
<p>One of the many conveniences of the Haiku USB API is the fact that many of the standard operations can be performed by simple function calls. As such, you won't have to build many of the standard requests the USB specification defines by hand. This section will outline all the different conveniences and will point you to where to look if you do need something more advanced.</p>
<h2><a class="anchor" id="usb_modules_standard_descriptors"></a>
Configurations, Interfaces and Descriptors</h2>
<p>Many standard USB operations have to do with configurations, interfaces and descriptors. All these operations are accessible by convenience functions.</p>
<p>The device descriptor is one of the first things you will be interested in if you want to check out a device. The device descriptor can be retrieved quite easily using the <code><a class="el" href="structusb__module__info.html#a87e309e0f458ffa63dd728ad4672f22c" title="Get the device descriptor.">usb_module_info::get_device_descriptor()</a></code> call. The retrieved descriptor complies to the one dictated by the USB standard.</p>
<p>Also important are configurations. Since every device has at least one configuration, you should be able to retrieve and manipulate configurations. You can use <code><a class="el" href="structusb__module__info.html#a61359a9b1bbd9ef858fdc2a1b40db120" title="Get a configuration descriptor by index.">usb_module_info::get_nth_configuration()</a></code> to get them. To set a configuration, you should use <code><a class="el" href="structusb__module__info.html#a100e008976fb16b2dba108488ddbc9a3" title="Change the current configuration.">usb_module_info::set_configuration()</a></code>. To get the active configuration, use <code><a class="el" href="structusb__module__info.html#ab1ab7fa09cd4df2193bc00660823acdc" title="Get the current configuration.">usb_module_info::get_configuration()</a></code>.</p>
<dl class="section attention"><dt>Attention</dt><dd>By default, Haiku's stack will set the configuration at offset zero, which is according to the standard, the default configuration. Do not rely on that if you first get the device, that the currently active configuration is the default configuration though. Another driver might have manipulated this device already.</dd></dl>
<p>Every configuration has associated interfaces. To make life easier, the stack automatically gets the interface descriptors (and their associated endpoints), and stores them in the <code><a class="el" href="structusb__configuration__info.html" title="Container for a specific configuration descriptor of a device.">usb_configuration_info</a></code> structure. This structure has a member called <a class="el" href="structusb__configuration__info.html#a1cbf462a2dc546e5e5b79215847b4a56"><code>interface</code> </a> which is of the type <code><a class="el" href="structusb__interface__list.html" title="List of interfaces available to a configuration.">usb_interface_list</a></code>. That object containts all the interfaces, including a pointer to the interface that is currently active. Each interface is described as a <code><a class="el" href="structusb__interface__info.html" title="Container for interface descriptors and their Haiku USB stack identifiers.">usb_interface_info</a></code>, which is a container for the interface, its associated endpoints and any unparsed descriptors. In order to change the active interface, you can use the stack's <code><a class="el" href="structusb__module__info.html#aa163487da04b51a86d6db0c309aaa706" title="Set an alternative interface. Not implemented.">usb_module_info::set_alt_interface()</a></code> call.</p>
<p>Endpoints, the basic units with which you can communicate, are stored as <code><a class="el" href="structusb__endpoint__info.html" title="Container for endpoint descriptors and their Haiku USB stack identifiers.">usb_endpoint_info</a></code> structures. Each of these structures carries the actual endpoint descriptor, and the accompanying usb_pipe handle that you can use to actually send and receive data.</p>
<p>The last point of interest are descriptors. As you have seen, Haiku caches all the relevant descriptors itself, however, you might want to retrieve any other type of descriptor that could be relevant for your device. The convenience function to use in such a case is the <code><a class="el" href="structusb__module__info.html#a3e01c2d5f14903e3ffbada712058adc5" title="Convenience function to get a descriptor from a device.">usb_module_info::get_descriptor()</a></code> call. This function takes all the parameters needed to build the actual descriptor, and performs the request over the default control pipe.</p>
<h2><a class="anchor" id="usb_modules_standard_features"></a>
Features</h2>
<p>Another one of the building blocks of USB are features. Every device should provide for a number of standard features, but the USB specification also leaves the option to using custom device specific features. Feature requests can be performed on devices, interfaces and pipes (which are tied to endpoints).</p>
<p>To set a feature, you can use the <code><a class="el" href="structusb__module__info.html#afcdaca35371964120d74adbbb7f51c95" title="Convenience function for standard control pipe set feature requests. Both the set_feature() and clear...">usb_module_info::set_feature()</a></code> call. To clear a feature, use the <code><a class="el" href="structusb__module__info.html#ae498a5af2db4b12c4a767622dff6447a" title="Convenience function for standard control pipe clear feature requests.">usb_module_info::clear_feature()</a></code> call. One of the most used feature calls is the call to clear a <code>USB_FEATURE_ENDPOINT_HALT</code> .</p>
<h2><a class="anchor" id="usb_modules_standard_other"></a>
Other Standard Calls</h2>
<p>To get the status of a device, an interface or an endpoint, you can use the <code><a class="el" href="structusb__module__info.html#a318e853caf08181ebce8a289b835bd8c" title="Convenience function for standard usb status requests.">usb_module_info::get_status()</a></code> call.</p>
<p>If you are using isochronous transfers, you can use the <code><a class="el" href="structusb__module__info.html#afdade807bed0bb42198484d31699836e" title="Set some pipe features.">usb_module_info::set_pipe_policy()</a></code> to set the properties of the isochronous pipe.</p>
<h1><a class="anchor" id="usb_modules_transfers"></a>
Data Transfers</h1>
<p>Transfering data is one of the basic building blocks of the USB protocol. This section will demonstrate how to perform transfers via the four different protocols the USB stack offers.</p>
<p>But first it is essential to show how to perform the transfers using the <code><a class="el" href="structusb__module__info.html" title="Interface for drivers to interact with Haiku&#39;s USB stack.">usb_module_info</a></code> interface. The interface provides five <code>queue_*</code> functions, with the asterix being one of the following: <code>bulk</code>, <code>bulk_v</code> (bulk transfers using a vector), <code>interrupt</code>, <code>isochronous</code> or <code>request</code> (over the standard control pipe). These five functions work asynchronously, which means that your driver is called back from a different thread when your transfer is finished.</p>
<p>The five functions share some arguments. The first argument is always the pipe that is associated with the endpoint (except for control transfers, these only work on the device in general). All of the functions accept a data buffer, and the length of that buffer. All of the functions require a <code><a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461" title="Callback function for asynchronous transfers.">usb_callback_func</a></code>, a function in your driver that can be called in case a transfer is finished. The functions also require a cookie that is provided to the callback function.</p>
<p>The working order is as follows: first you queue a transfer, then you handle the result in the callback function when it's done. The callback function will be called with a <em>status</em> argument, in which you can check whether or not the transfer actually succeeded. See this <a class="el" href="USB3_8h.html#a70db28579150fb8b41d38c43c1a6a461">description </a> for how your callback function should behave and what kind of status there might have been.</p>
<p>Finally, before going into the different transfer types, a note on buffer ownership. The usb stack keeps the internal buffers tidy, but the buffer you provide to the <code>queue_*</code> functions are yours. You are responsible for allocating and freeing them, and you may do with them whatever you like, <em>except</em> between queueing your transfer and the callback. During that period you should consider the USB stack the owner of the buffer.</p>
<h2><a class="anchor" id="usb_modules_transfers_control"></a>
Control Requests</h2>
<p>Control requests are done over the device wide control pipe which is provided by every device. Haiku's stack has two functions that you can use to perform custom requests (opposed to many of the <a class="el" href="#usb_modules_standard">standard operations</a>). Control transfers are the only transfers that you can perform synchronously as well as asynchronously. The functions you can use are <code><a class="el" href="structusb__module__info.html#a68e4ee4f5ce70aec8407f62701e67882" title="Send a generic, synchronous request over the default control pipe.">usb_module_info::send_request()</a></code> for synchronous requests and <code><a class="el" href="structusb__module__info.html#ac8e30a8407353bd17a3084a9bc139d71" title="Asynchronously queue a control pipe request.">usb_module_info::queue_request()</a></code> for asynchronous requests.</p>
<p>Many of the constants that you should use when performing can be found in the <a class="el" href="USB__spec_8h.html" title="General definitions as defined by the USB standard.">USB_spec.h</a> file which is automatically included if you include the main USB header. Have a look of how to use these constants in the following example:</p>
<div class="fragment"><div class="line"><span class="comment">// Send a request that is defined by the standard of this class. We retrieve</span></div>
<div class="line"><span class="comment">// a report from the device on one of its interfaces.</span></div>
<div class="line"><span class="comment">// This request is specified by the HID specification.</span></div>
<div class="line"> </div>
<div class="line">status = usb-&gt;send_request(dev,</div>
<div class="line">    <a class="code hl_define" href="USB__spec_8h.html#a1bae0bcd7c7151cc1b986c4512182422">USB_REQTYPE_INTERFACE_IN</a> | <a class="code hl_define" href="USB__spec_8h.html#a77d6d88e09fe3af350a57649e8f34c7f">USB_REQTYPE_CLASS</a>,</div>
<div class="line">    USB_REQUEST_HID_GET_REPORT, 0x0100 | report_id,</div>
<div class="line">    interfaceNumber, device-&gt;total_report_size,</div>
<div class="line">    device-&gt;buffer, &amp;actual);</div>
<div class="ttc" id="aUSB__spec_8h_html_a1bae0bcd7c7151cc1b986c4512182422"><div class="ttname"><a href="USB__spec_8h.html#a1bae0bcd7c7151cc1b986c4512182422">USB_REQTYPE_INTERFACE_IN</a></div><div class="ttdeci">#define USB_REQTYPE_INTERFACE_IN</div><div class="ttdoc">Interface. In.</div><div class="ttdef"><b>Definition</b> USB_spec.h:15</div></div>
<div class="ttc" id="aUSB__spec_8h_html_a77d6d88e09fe3af350a57649e8f34c7f"><div class="ttname"><a href="USB__spec_8h.html#a77d6d88e09fe3af350a57649e8f34c7f">USB_REQTYPE_CLASS</a></div><div class="ttdeci">#define USB_REQTYPE_CLASS</div><div class="ttdoc">Request that adheres to the specifications of the class.</div><div class="ttdef"><b>Definition</b> USB_spec.h:24</div></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>Both the <a class="el" href="structusb__module__info.html#a68e4ee4f5ce70aec8407f62701e67882"><em>send_request()</em> </a> and <a class="el" href="structusb__module__info.html#ac8e30a8407353bd17a3084a9bc139d71"><em>queue_request()</em> </a> functions can be used to perform standard usb requests. Avoid low-level operations, because the stack needs to keep its internal data structures consistent. If you need to perform one of the <a class="el" href="#usb_modules_standard">standard operations</a>, use the provided convenience functions.</dd></dl>
<h2><a class="anchor" id="usb_modules_transfers_interrupt"></a>
Interrupt</h2>
<p>Interrupt transfers apply to endpoints that receive data, or that can be polled in several instances of time. The intervals are determined by the endpoint descriptor.</p>
<p>To schedule a transfer, use <a class="el" href="structusb__module__info.html#a6997b487acef95cfad01738b39cd0e5b" title="Asynchronously queue an interrupt transfer.">usb_module_info::queue_interrupt()</a>. You only have to supply a buffer, the stack schedule the transfer in such a way that it will be performed within a certain timeframe. To create a continuous interrupt system, you should queue the next transfer in the callback function of the previous. The stack will make sure that the new transfer will be performed exactly after the required interval.</p>
<h2><a class="anchor" id="usb_modules_transfers_bulk"></a>
Bulk</h2>
<p>Bulk transfers are very similar to control transfers. They will be performed as soon as possible without stalling other transfers, and they transfer data. Bulk transfers are designed to transfer up to large amounts of data as efficiently as possible. Performing bulk transfers isn't difficult, you merely supply a buffer and the endpoint that should execute the request, and you're set.</p>
<p>Bulk transfers come in two flavours. The first is <a class="el" href="structusb__module__info.html#a251ba68003d8164d76b98ac3e0e5c5c3" title="Asynchronously queue a bulk transfer.">usb_module_info::queue_bulk()</a>, which takes a standard data buffer. The second flavour is the <a class="el" href="structusb__module__info.html#aa75e9761602b1cfeb844060e62d84b93" title="Asynchronously queue a bulk vector.">usb_module_info::queue_bulk_v()</a> function, which is designed to operate on (an array of) POSIX vectors. These functions only differ in the buffer they accept, they function in exactly the same way.</p>
<h2><a class="anchor" id="usb_modules_transfers_isochronous"></a>
Isochronous</h2>
<p>Isochronous transfers are not implemented on Haiku yet. As soon as they are, this section should contain information on how to queue them.</p>
<h1><a class="anchor" id="usb_modules_cleanup"></a>
Cleaning Up</h1>
<p>This section describes how to gracefully leave the stack after your driver is requested to shut down.</p>
<p>There are truely only two simple actions to perform. The first is to uninstall your notification hooks, using <code><a class="el" href="structusb__module__info.html#a83bcf60f29ceb298d9e6318e6e6e416a" title="Uninstall notify hooks for your driver.">usb_module_info::uninstall_notify()</a></code>. The second action is to 'put' the module.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div>
<div class="line">uninit_driver(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    usb-&gt;uninstall_notify(kDriverName);</div>
<div class="line">    put_module(<a class="code hl_define" href="USB3_8h.html#a22b89f939badbd5ede71f3830811aeb5">B_USB_MODULE_NAME</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="usb_modules_resources"></a>
More Resources</h1>
<p>This section should list more resources on the web. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - Writing drivers for USB devices<br />
    Generated on Sat May 24 2025 23:12:17 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.12.0
  </small></address>
</body>
</html>
